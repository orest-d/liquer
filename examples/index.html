<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Examples - LiQuer Docs</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">LiQuer Docs</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="..">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../query/">Query syntax</a>
</li>
                                    
<li >
    <a href="../guide/">General guide</a>
</li>
                                </ul>
                            </li>
                            <li class="active">
                                <a href="./">Examples</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../guide/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="disabled">
                                <a rel="prev" >
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#hdx-disaggregation-wizard">HDX disaggregation wizard</a></li>
        <li class="main "><a href="#integration-of-libhxl-example-of-a-custom-state-type">Integration of libhxl (example of a custom state type)</a></li>
        <li class="main "><a href="#reports-and-visualizations">Reports and visualizations</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="hdx-disaggregation-wizard">HDX disaggregation wizard</h1>
<p>LiQuer is a small server-side framework that can be quite helpful
when building data-oriented web applications.</p>
<p>One such example is HDX disaggregation wizard.
It is a tool solving a simple task:
splitting (disaggregating) a single data sheet (csv or xlsx)
into multiple sheets. Sheet is split by values in the specified column (or multiple columns).</p>
<p>Since this is a quite generic task (related to <em>group by</em>), this functionality is built into <code>liquer.ext.lq_pandas</code>.
The core of this feature is the <code>eq</code> command, filtering dataframe by specific values in a column,
e.g. <code>eq-a-123</code> keeps in the dataframe only rows where column <code>a</code> is 123.
Command <code>eq</code> (equal) accepts multiple column-value pairs, e.g. <code>eq-a-123-b-234</code>.
In HDX the convention is to use the first row for tags. To support this comvention, <code>teq</code> command (tag equal)
always keeps the first row of the dataframe. The disaggregation service supports both tagged and untagged data,
using either <code>eq</code> or <code>teq</code> for filtering, depending on the user input.</p>
<p>The complete flow is simple:
* fetch data (command <code>df_from</code>)
* find unique values in a column (or multiple columns) and use them
to create a list (table) of queries (command <code>split_df</code>)
* the queries use <code>eq</code> (or <code>teq</code>) to filter dataframe by value(s).</p>
<p>So, use a query like <code>df_from-URL/split_df-COLUMN</code>
and you will get a table with queries like <code>df_from-URL/eq-COLUMN-VALUE1</code>,
<code>df_from-URL/eq-COLUMN-VALUE2</code>.</p>
<p>A little detail regarding the split function:
There are actually four versions of this function - depending whether it is used for tagged or untagged document
and whether it is <em>quick</em> (or <em>query</em>) splits or full splits.
The quick version only provides raw LiQuer queries (not the complete URL),
The full split (<code>split_df</code> for untagged and <code>tsplit_df</code> for tagged data) execute all the split queries,
which might be slow. As a side effect, the results are cached (depending on the configuration, the example is using <code>FileCache('cache')</code>).</p>
<p>The complete user interface is in a single html file <code>hdx_wizard.html</code>, served by the flask server.
Inside the user interface, LiQuer service is called multiple times e.g. to get previews or metadata:
* Data previews uses the ability of LiQuer <code>lq_pandas</code> to convert dataframes to json, which can easily be read into javascript on the browser. First preview uses <code>head_df</code> command to display only a restricted part of the dataframe (<em>head</em>)
* <code>columns_info</code> command is used to get lit of columns and eventual tags
* <code>/api/build</code> service is used to build valid queries from javascript lists. This could be implemented directly in javascript,
build service is a way to remotely call <code>liquer.parser.encode</code>.</p>
<h1 id="integration-of-libhxl-example-of-a-custom-state-type">Integration of libhxl (example of a custom state type)</h1>
<p>Pandas is great, but there are other
good libraries too e.g. <a href="https://bitbucket.org/astanin/python-tabulate">tabulate</a>.
If you want to to use other data type (tabular or other),
it will typically require (besides some useful commands) defining how that data can be serialized.
This is done by implementing a <em>state type</em>.
State type does several things associated with state type handling,
but the most important role is handling serialization and deserialization.</p>
<p>One excelent library used for working with humanitarian data is
<a href="https://github.com/HXLStandard/libhxl-python">libhxl</a>.
Libhxl plays somewhat similar role as pandas: it reads, writes and manipulates tabular data - but it does as well understand <a href="http://hxlstandard.org">HXL</a>,
which pandas doesn't - hence the <code>liquer.ext.lq_hxl</code> module.
In order to allow libhxl objects to be used in liquer, 
we need to define a state type: <code>HxlStateType</code>.</p>
<pre><code class="python">import hxl
from liquer.state_types import StateType, register_state_type, mimetype_from_extension

class HxlStateType(StateType):
    def identifier(self):
        &quot;Define an unique string identifier for the state type&quot;
        return &quot;hxl_dataset&quot;
</code></pre>

<p>The <code>identifier</code> is important e.g. for caching, 
where it is stored as a part of metadata and it
tells what StateType should be used for deserialization.</p>
<pre><code class="python">    def default_extension(self):
        &quot;Default file extension for the state type&quot;
        return &quot;csv&quot;

    def is_type_of(self, data):
        &quot;Check if data is of this state type&quot;
        return isinstance(data, hxl.model.Dataset)
</code></pre>

<p>Default extension is used when the extension is not specified otherwise - for example if query does not end with a filename.</p>
<p>The <code>as_bytes</code> and <code>from_bytes</code> are two most important methods,
which take care of the serialization and deserialization.
A state data can be serialized into multiple formats (e.g. csv, html, json...), therefore <code>as_bytes</code> optionally accepts a file extension
and returns (besides the bytes) as well the mimetype.
Th mimetype (when queried through the liquer server) becomes a part of the web service response.</p>
<p>Note that serialization and deserialization do not necessarily need
to support the same formats. E.g. html is quite nice to support
in serialization, but it is too unspecific for a deserialization.</p>
<pre><code class="python">    def as_bytes(self, data, extension=None):
        &quot;&quot;&quot;Serialize data as bytes
        File extension may be provided and influence the serialization format.
        &quot;&quot;&quot;
        if extension is None:
            extension = self.default_extension()
        assert self.is_type_of(data)
        mimetype = mimetype_from_extension(extension)
        if extension == &quot;csv&quot;:
            output = &quot;&quot;.join(data.gen_csv(show_headers=True, show_tags=True))
            return output.encode(&quot;utf-8&quot;), mimetype
        elif extension == &quot;json&quot;:
            output = &quot;&quot;.join(data.gen_json(show_headers=True, show_tags=True))
            return output.encode(&quot;utf-8&quot;), mimetype
        else:
            raise Exception(
                f&quot;Serialization: file extension {extension} is not supported by HXL dataset type.&quot;)

    def from_bytes(self, b: bytes, extension=None):
        &quot;&quot;&quot;De-serialize data from bytes
        File extension may be provided and influence the serialization format.
        &quot;&quot;&quot;
        if extension is None:
            extension = self.default_extension()
        f = BytesIO()
        f.write(b)
        f.seek(0)

        if extension == &quot;csv&quot;:
            return hxl.data(f)
        raise Exception(
            f&quot;Deserialization: file extension {extension} is not supported by HXL dataset type.&quot;)
</code></pre>

<p>Sometimes a deep copy of state data is needed - e.g. to assure
that the data in the cache will not become unintentionally
modified. That's why the state type should define <code>copy</code> method.
Since libhxl dataset is immutable (?), it is OK to return just the data without making a copy. </p>
<pre><code class="python">    def copy(self, data):
        &quot;&quot;&quot;Make a deep copy of the data&quot;&quot;&quot;
        return data
</code></pre>

<p>Once the state type class is defined, a state type instance
is created and registered</p>
<pre><code class="python">HXL_DATASET_STATE_TYPE = HxlStateType()
register_state_type(hxl.Dataset, HXL_DATASET_STATE_TYPE)
register_state_type(hxl.io.HXLReader, HXL_DATASET_STATE_TYPE)
</code></pre>

<p>This is (currently) done for all relevant types.
State types are registered in a global <code>StateTypesRegistry</code>
object, which is responsible for registering and finding a state type
instance for any state data.</p>
<p>For more details see <code>liquer.ext.lq_hxl</code> module.</p>
<p>Actually, the state type may not define a serialization and/or deserialization. There are objects that either can't be reliably serialized
(e.g. matplotlib figure - as of time of writing)
or serialization is otherwise undesirable. Such state types would be perfectly legal - they just could be neither cached nor served by the liquer web server. However, they could be inside the query, e.g.
if matplotlib figure would be followed by image creation command,
the image could be both served and cached.</p>
<h1 id="reports-and-visualizations">Reports and visualizations</h1>
<p>With the help of LiQuer, it is very easy to create both resuable visualizations with multiple views
as well as documents viewable offline or suitable for printing.
There are multiple markups suitable for creating reports and visualisations,
but probably the easiest and most flexible are HTML documents.
In LiQuer html can be easily created by returning a html text from a command. </p>
<p>Creation of text is simplified by <code>evaluate_template</code> function, which processes a string (<em>template</em>)
containing LiQuer queries and replaces those queries by their results.</p>
<p>Report example is processing data from <a href="https://data.humdata.org/dataset/4fdcd4dc-5c2f-43af-a1e4-93c9b6539a27">Global Food Prices Database (WFP)</a>.
It contains monthly prices for various commodities.
To adapt the data to our needs we need a cople of extra commands:</p>
<p>Month and year are in two separate columns <code>mp_year</code> and <code>mp_month</code>. For charts we need dates in YYYY-MM-DD format, which we achieve with the following command:</p>
<pre><code class="python">@command
def datemy(df,y=&quot;mp_year&quot;,m=&quot;mp_month&quot;,target=&quot;date&quot;):
    df.loc[:,target]=[&quot;%04d-%02d-01&quot;%(int(year),int(month)) for year,month in zip(df[y],df[m])]
    return df
</code></pre>

<p>To make statistics, it's handy to use pandas groupby. As an example we show count of groups,
which used in the report to show number of observed prices in various markets:</p>
<pre><code class="python">
@command
def count(df, *groupby_columns):
    df.loc[:,&quot;count&quot;]=1
    return df.groupby(groupby_columns).count().reset_index().loc[:,list(groupby_columns)+[&quot;count&quot;]]
</code></pre>

<p>An example of a custom filter is a <em>greater or equal</em> command <code>geq</code>, used in the report
to cut away years before a start year:</p>
<pre><code class="python">@command
def geq(df, column, value:float):
    index = df.loc[:,column] &gt;= value 
    return df.loc[index,:]
</code></pre>

<p>This is somewhat similar to <code>eq</code> command from the pandas support module <code>liquer.ext.lq_pandas</code>,
but only supports numerical values, while the <code>eq</code> command is somewhat more general.</p>
<p>Pandas dataframe supports quite flexible method <code>to_html</code> for converting dataframes to html format.
Report uses for styling the popular css framework <a href="https://getbootstrap.com/">bootstrap</a> and to display the
tables nicely we just need to add some <a href="https://getbootstrap.com/docs/4.3/content/tables/">bootstrap css classes</a>.
Command as well prepends a link to the dataframe itself by the <code>link</code> command.
This tends to be very useful in practice, allowing to conviniently import underlying raw data into a spreadsheet.</p>
<pre><code class="python">@command
def table(state):
    df = state.get()
    html=evaluate_template(f&quot;&quot;&quot;&lt;a href=&quot;${state.query}/link-url-csv$&quot;&gt;(data)&lt;/a&gt; &quot;&quot;&quot;)
    return html+df.to_html(index=False, classes=&quot;table table-striped&quot;)
</code></pre>

<p>The core of the report is a <code>report</code> command. It can be applied on any dataframe containing suitable fields.
This allows a large degree of flexibility - arbitrary filters can be inserted into a command chain before the report.
For example, the current report can be restricted to specific markets, time periods or commodities without
any additional code, just by modifying the URL.</p>
<p>Report embeds a possibility to remove data pefore a <code>from_year</code>. This in principle could be done
by inserting a <code>geq</code> command before the report (which would work fine). Passing <code>from_year</code> as an argument
has an advantage, that the start year can become a part of the report (e.g. it can be used as a part of the title).</p>
<p>Main part of the report is a single template, evaluated with <code>evaluate_template</code>.
Note that LiQuer template uses as well string interpolation by <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498">python f string (PEP 498)</a>, which is a very powerful combination. </p>
<pre><code class="python">@command
def report(state, from_year=2017, linktype=None):
    state = state.with_caching(False)
    def makelink(url):
        if linktype is None:
            return url
        extension = url.split(&quot;.&quot;)[-1]
        return evaluate(f&quot;fetch-{encode_token(url)}/link-{linktype}-{extension}&quot;).get()

    try:
        source = state.sources[0]
    except:
        source = &quot;???&quot;

    LiQuer='&lt;a href=&quot;https://github.com/orest-d/liquer&quot;&gt;&amp;nbsp;LiQuer&amp;nbsp;&lt;/a&gt;'
    df = state.get()
    try:
        title = &quot;,&quot;.join(sorted(df.adm0_name.unique())) + f&quot; since {from_year}&quot;
    except:
        title = &quot;report&quot;
    return state.with_filename(&quot;report.html&quot;).with_data(evaluate_template(f&quot;&quot;&quot;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;{title}&lt;/title&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;{makelink('https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css')}&quot; integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;p-3 mb-2 bg-success text-white fixed-top shadow-sm&quot;&gt;
            &lt;a class=&quot;nav-link active&quot; href=&quot;https://data.humdata.org&quot;&gt;&lt;img src=&quot;{makelink('https://centre.humdata.org/wp-content/uploads/hdx_new_logo_accronym2.png')}&quot; style=&quot;height:30px;&quot; alt=&quot;HDX&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;bg-light fixed-bottom border-top&quot;&gt;
        Generated with {LiQuer} &lt;span class=&quot;float-right&quot;&gt;&amp;#169; 2019 Orest Dubay&lt;/span&gt;
        &lt;/div&gt;
        &lt;br/&gt;
        &lt;br/&gt;
        &lt;br/&gt;
        &lt;br/&gt;
        &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;div class=&quot;container-fluid&quot;&gt;
            &lt;div class=&quot;row&quot;&gt;
                Data originate from &lt;a href=&quot;{source}&quot;&gt;&amp;nbsp;{source}&amp;nbsp;&lt;/a&gt; were processed via a {LiQuer} service.
                Only data after {from_year} are shown (&lt;a href=&quot;${state.query}/datemy/geq-mp_year-{from_year}/link-url-csv$&quot;&gt;data&lt;/a&gt;),
                complete data are &lt;a href=&quot;${state.query}/datemy/link-url$&quot;&gt;&amp;nbsp;here&lt;/a&gt;. 
            &lt;/div&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-6&quot; style=&quot;height:50%;&quot;&gt;${state.query}/datemy/geq-mp_year-{from_year}/groupby_mean-mp_price-date-cm_name/plotly_chart-xys-date-mp_price-cm_name$&lt;/div&gt;
                &lt;div class=&quot;col-md-6&quot; style=&quot;height:50%;&quot;&gt;${state.query}/datemy/geq-mp_year-{from_year}/count-adm1_name/plotly_chart-piexs-count-adm1_name$&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-6&quot; style=&quot;height:50%;&quot;&gt;
                &lt;h2&gt;Average prices&lt;/h2&gt;
                ${state.query}/datemy/geq-mp_year-{from_year}/groupby_mean-mp_price-cm_name/table$&lt;/div&gt;
                &lt;div class=&quot;col-md-6&quot; style=&quot;height:50%;&quot;&gt;
                &lt;h2&gt;Observations&lt;/h2&gt;
                ${state.query}/datemy/geq-mp_year-{from_year}/count-adm1_name/table$&lt;/div&gt;
            &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
    &quot;&quot;&quot;))
</code></pre>

<p>Inside the <code>report</code> command some more magic is used to handle links and external resources.
Links are created by a nested function <code>makelink</code>. The main purpose is to allow three different regimes
of working with links:
* links to original sources (default),
* serving (proxying) resources through LiQuer service and
* dataurls.
<strong>Links to original sources</strong> are useful if the report is used from a web service: the report size is then relatively small
and thus the loading time is faster than for dataurls.</p>
<p><strong>Proxying resources</strong> through LiQuer service allows to cache resources by LiQuer. This may be useful on slower internet connections, when running the service without internet or behind a firewall.</p>
<p><strong>Dataurl</strong> link type allows saving the report as a single html file. Such a report can be used e.g. for offline browsing, archiving or sending by e-mail. All the assets are embedded inside the html file, so the report will work even when the LiQuer service
is not available. Note: The embedded LiQuer queries will of course not work offline, but if necessary, the data comming out from LiQuer can be turned to a dataurl with <code>link</code> command; type of the link can be controlled by <code>linktype</code> state variable. Assuming
<em>linktype</em> is not hardcoded (as in <code>table</code> command) all query links in the report could be turned to dataurls like this:</p>
<pre><code>filter-params/let-linktype-dataurl/report
</code></pre>

<p>This of course could lead to extremply large report files, so it should be used carefully.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
