<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>liquer.state_types API documentation</title>
<meta name="description" content="State types represent the additional properties of data types that can be used as a state:
- state type must be representable as a (short) string â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>liquer.state_types</code></h1>
</header>
<section id="section-intro">
<p>State types represent the additional properties of data types that can be used as a state:
- state type must be representable as a (short) string identifier
- state must be serializable (and deserializable) as bytes
- mime type must be known for a serialized form
State types are registered in a state type registry, where they can be looked up either by
a qualified type name or a state type identifier. (Therefore state type identifiers should be carefully chosen
to not to clash with qualified names. It is encouraged to only use lower case characters as state type identifiers.)</p>
<p>Intended use:
- state can be served via a web service,
- state can be serialized into a file, database or key/value store.</p>
<p>Deserialization requires (besides the byte representation of the data) as well identifier of the state type,
which identifies a registered state type and thus the deserialization method.
Though state type provides a prefered (default) format,
multiple formats may be used for serialization (and deserialization) if needed.
The serialization format is selected by file extension passed to serialization (as_bytes) or deserialization (from_bytes) method.
Since the format determines the mime type, as bytes return besides serialized data as well the actual mime type relevant for the serialization.</p>
<p>Note that for the successful serialization/deserialization strategy (e.g. for caching), the following approaches
can be used:
- use the default extension/format/mimetype - i.e. do not specify the extension or set extension=None in as_bytes/from_bytes
- specify fixed extension</p>
<p>Serialization/deserialization may as well keep being unspecified. In that case, the state the capability
of a state being cached or served is limited.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;State types represent the additional properties of data types that can be used as a state:
- state type must be representable as a (short) string identifier
- state must be serializable (and deserializable) as bytes
- mime type must be known for a serialized form
State types are registered in a state type registry, where they can be looked up either by
a qualified type name or a state type identifier. (Therefore state type identifiers should be carefully chosen
to not to clash with qualified names. It is encouraged to only use lower case characters as state type identifiers.)

Intended use:
- state can be served via a web service,
- state can be serialized into a file, database or key/value store.

Deserialization requires (besides the byte representation of the data) as well identifier of the state type,
which identifies a registered state type and thus the deserialization method.
Though state type provides a prefered (default) format,
multiple formats may be used for serialization (and deserialization) if needed.
The serialization format is selected by file extension passed to serialization (as_bytes) or deserialization (from_bytes) method.
Since the format determines the mime type, as bytes return besides serialized data as well the actual mime type relevant for the serialization.

Note that for the successful serialization/deserialization strategy (e.g. for caching), the following approaches
can be used:
- use the default extension/format/mimetype - i.e. do not specify the extension or set extension=None in as_bytes/from_bytes
- specify fixed extension

Serialization/deserialization may as well keep being unspecified. In that case, the state the capability
of a state being cached or served is limited.
&#34;&#34;&#34;

from io import BytesIO, StringIO
import json
from copy import deepcopy
import base64
import pickle
from liquer.constants import mimetype_from_extension, MIMETYPES


def get_type_qualname(cls):
    &#34;&#34;&#34;Get a string uniquely identifying the supplied class&#34;&#34;&#34;
    if isinstance(cls, str):
        return cls
    if cls.__module__ == &#34;__main__&#34;:
        return cls.__qualname__
    return f&#34;{cls.__module__}.{cls.__qualname__}&#34;


class StateTypesRegistry(object):
    &#34;&#34;&#34;State type registry takes care of registering and lookup of state types.
    It is typically accessed as a singleton via state_type_registry() function.

    default_state_type attribute is used if state type is not recognized.
    &#34;&#34;&#34;

    def __init__(self):
        self.state_types_dictionary = {}
        self.register(bytes, BytesStateType())
        self.register(str, TextStateType())
        self.register(dict, DictStateType())
        self.register(type(None), JsonStateType())
        self.register(int, JsonStateType())
        self.register(float, JsonStateType())
        self.default_state_type = PickleStateType()

    def register(self, type_qualname, state_type):
        &#34;&#34;&#34;Register a new state type for a qualified type name&#34;&#34;&#34;
        type_qualname = get_type_qualname(type_qualname)
        self.state_types_dictionary[type_qualname] = state_type
        self.state_types_dictionary[state_type.identifier()] = state_type
        return self

    def get(self, type_qualname):
        &#34;&#34;&#34;Get state type object for a qualified type name
        If the qualified type name is not recognized, default_state_type is returned.
        &#34;&#34;&#34;
        if type_qualname is None:
            return self.default_state_type
        type_qualname = get_type_qualname(type_qualname)
        return self.state_types_dictionary.get(type_qualname, self.default_state_type)

    def from_type_identifier(self, type_identifier):
        &#34;&#34;&#34;Get state type object for a qualified type name
        If the qualified type name is not recognized, default_state_type is returned.
        &#34;&#34;&#34;
        for x in self.state_types_dictionary.values():
            if x.identifier() == type_identifier:
                return x


_state_types_registry = None


def state_types_registry():
    &#34;&#34;&#34;Returns the global state types registry (singleton)&#34;&#34;&#34;
    global _state_types_registry
    if _state_types_registry is None:
        _state_types_registry = StateTypesRegistry()
    return _state_types_registry


def data_characteristics(data):
    &#34;&#34;&#34;Convenience function to return data characteristics for supplied data.
    Data characteristics must be a dictionary containing at least a &#34;description&#34;
    element with a string description of the data and a &#34;type_identifier&#34;.
    Type identifier is duplicate of the type identifier found in metadata, but makes
    the data characteristics self-contained.
    &#34;&#34;&#34;
    st = state_types_registry().get(get_type_qualname(type(data)))
    ch = st.data_characteristics(data)
    if not isinstance(ch, dict):
        raise Exception(
            f&#34;Data characteristics for {st.identifier()} must be a dictionary&#34;
        )
    ch[&#34;description&#34;] = ch.get(&#34;description&#34;, &#34;&#34;)
    ch[&#34;type_identifier&#34;] = ch.get(&#34;type_ident&#34;, st.identifier())
    return ch


def type_identifier_of(data):
    &#34;&#34;&#34;Convenience function to return a state type identifier for supplied data&#34;&#34;&#34;
    return state_types_registry().get(get_type_qualname(type(data))).identifier()


def state_type_from_type_identifier(type_identifier):
    &#34;&#34;&#34;Convenience function to return a state type for supplied type identifier&#34;&#34;&#34;

    return state_types_registry().from_type_identifier(type_identifier)


def register_state_type(type_qualname, state_type):
    &#34;&#34;&#34;Function to register new state type for a qualified type name
    type_qualname can be a string (module.ClassName) or a class/type object (not a data instance)
    &#34;&#34;&#34;
    type_qualname = get_type_qualname(type_qualname)
    state_types_registry().register(type_qualname, state_type)


def encode_state_data(data, extension=None):
    &#34;&#34;&#34;Helper function to encode state data.
    Extension decides which data format is used for encoding.
    If not supplied, a default extension defined for the state type is used.
    Returns a tuple with binary representation of the data, mime type and state type identifier.
    &#34;&#34;&#34;
    reg = state_types_registry()
    t = reg.get(get_type_qualname(type(data)))
    b, mime = t.as_bytes(data, extension=extension)
    return b, mime, t.identifier()


def decode_state_data(b, type_identifier, extension=None):
    &#34;&#34;&#34;Helper function to decode state data.
    Requires binary representation of the state data and state type identifier.
    Extension decides which data format is used for decoding.
    If not supplied, a default extension defined for the state type is used.
    Returns a tuple with binary representation of the data, mime type and state type identifier.
    &#34;&#34;&#34;
    t = state_types_registry().get(type_identifier)
    return t.from_bytes(b, extension=extension)


def copy_state_data(data):
    &#34;&#34;&#34;Helper function to get a deep copy of a state data.&#34;&#34;&#34;
    reg = state_types_registry()
    t = reg.get(get_type_qualname(type(data)))
    return t.copy(data)


class StateType(object):
    &#34;&#34;&#34;Abstract state type basis&#34;&#34;&#34;

    def identifier(self):
        &#34;&#34;&#34;String identifier of the state type&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define a state type identifier&#34;
        )

    def default_extension(self):
        &#34;&#34;&#34;Default file extension; determines the default data format
        Must be consistent with the default_mimetype.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;State type class must define the default extension&#34;)

    def default_filename(self):
        &#34;&#34;&#34;Default file name&#34;&#34;&#34;
        return &#34;data.&#34; + self.default_extension()

    def default_mimetype(self):
        &#34;&#34;&#34;Default mime type - must be consistent with the default_extension&#34;&#34;&#34;
        return MIMETYPES.get(self.default_extension(), &#34;text/plain&#34;)

    def is_type_of(self, data):
        &#34;&#34;&#34;Returns true if data is of this state type&#34;&#34;&#34;
        return False

    def as_bytes(self, data, extension=None):
        &#34;&#34;&#34;Serialize data as bytes.
        Data must be of this state type. Extension determines the serialization format. If none, default extension is used.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define serialization to bytes (as_bytes)&#34;
        )

    def from_bytes(self, b: bytes, extension=None):
        &#34;&#34;&#34;Deserialize data from bytes.
        Data must be a binary representation of this state type.
        Extension determines the serialization format. If none, default extension is used.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define deserialization from bytes (from_bytes)&#34;
        )

    def copy(self, data):
        &#34;&#34;&#34;Create a deep copy of data.
        Data must be of this state type.&#34;&#34;&#34;
        return self.from_bytes(self.as_bytes(data)[:])

    def data_characteristics(self, data):
        &#34;&#34;&#34;Create state-type-dependent data characteristics for supplied data.
        Returned data characteristics must be a dictionary containing at least a &#34;description&#34;
        element with a string description of the data and a &#34;type_identifier&#34;.
        Type identifier is duplicate of the type identifier found in metadata, but makes
        the data characteristics self-contained.

        This method should not be called directly, but via the data_characteristics function,
        which might fix and validate some issues.
        &#34;&#34;&#34;
        return dict(description=&#34;&#34;)


class DictStateType(StateType):
    &#34;&#34;&#34;JSON serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;dictionary&#34;

    def default_extension(self):
        return &#34;json&#34;

    def is_type_of(self, data):
        return isinstance(data, dict)

    def encode_element(self, data_element):
        if isinstance(data_element, (int, float, str)) or data_element is None:
            return json.dumps(data_element)
        else:
            reg = state_types_registry()
            t = reg.get(get_type_qualname(type(data_element)))
            extension = t.default_extension()
            b, mime = t.as_bytes(data_element, extension=extension)
            txt = base64.b64encode(b).decode(&#34;utf-8&#34;)
            return &#39;[%-10s, %-4s, &#34;%s&#34;]&#39; % (
                f&#39;&#34;{t.identifier()}&#34;&#39;,
                f&#39;&#34;{extension}&#34;&#39;,
                txt,
            )

    def decode_element(self, data_element_encoded):
        if isinstance(data_element_encoded, list):
            type_identifier, extension, b64 = data_element_encoded
            b = base64.b64decode(b64)
            return decode_state_data(b, type_identifier, extension)
        else:
            return data_element_encoded

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension == &#34;djson&#34;:
            d = &#34;{\n&#34;
            sep = &#34;&#34;
            for key, value in data.items():
                assert isinstance(key, str)
                d += sep
                d += &#34;%-20s%s&#34; % (f&#39;&#34;{key}&#34;:&#39;, self.encode_element(value))
                sep = &#34;,\n&#34;
            d += &#34;\n}&#34;
            return d.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;djson&#34;)
        elif extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;json&#34;)

        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()
        if extension == &#34;djson&#34;:
            d = {}
            for key, value in json.loads(b.decode(&#34;utf-8&#34;)).items():
                d[key] = self.decode_element(value)
            return d
        elif extension == &#34;json&#34;:
            return json.loads(b.decode(&#34;utf-8&#34;))

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        return dict(
            description=f&#34;Dictionary with {len(data)} items.&#34;,
            keys=sorted(str(k) for k in data.keys()),
        )


class JsonStateType(StateType):
    &#34;&#34;&#34;JSON serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;generic&#34;

    def default_extension(self):
        return &#34;json&#34;

    def is_type_of(self, data):
        return True

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), self.default_mimetype()
        elif extension in [&#34;html&#34;, &#34;htm&#34;]:
            if isinstance(data, str):
                return data.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;html&#34;)
            else:
                return (
                    f&#34;&lt;pre&gt;{json.dumps(data)}&lt;/pre&gt;&#34;.encode(&#34;utf-8&#34;),
                    mimetype_from_extension(&#34;html&#34;),
                )
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()

        assert extension == &#34;json&#34;
        return json.loads(b.decode(&#34;utf-8&#34;))

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        if isinstance(data, dict):
            return dict(
                description=f&#34;Dictionary with {len(data)} items.&#34;,
                keys=sorted(str(k) for k in data.keys()),
            )
        elif isinstance(data, dict):
            return dict(description=f&#34;Array with {len(data)} items.&#34;)
        elif isinstance(data, str):
            return dict(description=f&#34;Text {len(data)} characters long.&#34;)
        elif isinstance(data, bool):
            return dict(description=f&#34;Bool {data}&#34;)
        elif isinstance(data, int):
            return dict(description=f&#34;Integer {data}&#34;)
        elif isinstance(data, float):
            return dict(description=f&#34;Float {data}&#34;)
        elif data is None:
            return dict(description=f&#34;None&#34;)
        else:
            return dict(description=f&#34;Data of type {type(data)}&#34;)


class PickleStateType(StateType):
    &#34;&#34;&#34;Pickle-serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;pickle&#34;

    def default_extension(self):
        return &#34;pickle&#34;

    def is_type_of(self, data):
        return True

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension in [&#34;pkl&#34;, &#34;pickle&#34;]:
            return pickle.dumps(data), mimetype_from_extension(&#34;pickle&#34;)
        elif extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;json&#34;)
        elif extension in [&#34;html&#34;, &#34;htm&#34;]:
            if isinstance(data, str):
                return data.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;html&#34;)
            else:
                return (
                    f&#34;&lt;pre&gt;{json.dumps(data)}&lt;/pre&gt;&#34;.encode(&#34;utf-8&#34;),
                    mimetype_from_extension(&#34;html&#34;),
                )
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension in [&#34;pkl&#34;, &#34;pickle&#34;]:
            return pickle.loads(b)
        elif extension == &#34;json&#34;:
            return json.loads(b.decode(&#34;utf-8&#34;))
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        if isinstance(data, dict):
            return dict(
                description=f&#34;Dictionary with {len(data)} items.&#34;,
                keys=sorted(str(k) for k in data.keys()),
            )
        elif isinstance(data, dict):
            return dict(description=f&#34;Array with {len(data)} items.&#34;)
        elif isinstance(data, str):
            return dict(description=f&#34;Text {len(data)} characters long.&#34;)
        elif isinstance(data, bool):
            return dict(description=f&#34;Bool {data}&#34;)
        elif isinstance(data, int):
            return dict(description=f&#34;Integer {data}&#34;)
        elif isinstance(data, float):
            return dict(description=f&#34;Float {data}&#34;)
        elif data is None:
            return dict(description=f&#34;None&#34;)
        else:
            return dict(description=f&#34;Data of type {type(data)}&#34;)


class BytesStateType(StateType):
    &#34;&#34;&#34;Binary data&#34;&#34;&#34;

    def identifier(self):
        return &#34;bytes&#34;

    def default_extension(self):
        return &#34;b&#34;

    def default_mimetype(self):
        return &#34;application/octet-stream&#34;

    def is_type_of(self, data):
        return isinstance(data, bytes)

    def as_bytes(self, data, extension=None):
        return data, mimetype_from_extension(extension)

    def from_bytes(self, b: bytes, extension=None):
        return b

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        return dict(description=f&#34;{len(data)} bytes&#34;)


class TextStateType(StateType):
    &#34;&#34;&#34;Text data (string)&#34;&#34;&#34;

    def identifier(self):
        return &#34;text&#34;

    def default_extension(self):
        return &#34;txt&#34;

    def default_mimetype(self):
        return &#34;text/plain&#34;

    def is_type_of(self, data):
        return isinstance(data, str)

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()
            mime = self.default_mimetype()
        else:
            mime = mimetype_from_extension(extension, &#34;text/plain&#34;)
        return data.encode(&#34;utf-8&#34;), mime

    def from_bytes(self, b: bytes, extension=None):
        return b.decode(&#34;utf-8&#34;)

    def copy(self, data):
        return data[:]

    def data_characteristics(self, data):
        return dict(description=f&#34;Text {len(data)} characters long.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="liquer.state_types.copy_state_data"><code class="name flex">
<span>def <span class="ident">copy_state_data</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to get a deep copy of a state data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_state_data(data):
    &#34;&#34;&#34;Helper function to get a deep copy of a state data.&#34;&#34;&#34;
    reg = state_types_registry()
    t = reg.get(get_type_qualname(type(data)))
    return t.copy(data)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.data_characteristics"><code class="name flex">
<span>def <span class="ident">data_characteristics</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to return data characteristics for supplied data.
Data characteristics must be a dictionary containing at least a "description"
element with a string description of the data and a "type_identifier".
Type identifier is duplicate of the type identifier found in metadata, but makes
the data characteristics self-contained.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_characteristics(data):
    &#34;&#34;&#34;Convenience function to return data characteristics for supplied data.
    Data characteristics must be a dictionary containing at least a &#34;description&#34;
    element with a string description of the data and a &#34;type_identifier&#34;.
    Type identifier is duplicate of the type identifier found in metadata, but makes
    the data characteristics self-contained.
    &#34;&#34;&#34;
    st = state_types_registry().get(get_type_qualname(type(data)))
    ch = st.data_characteristics(data)
    if not isinstance(ch, dict):
        raise Exception(
            f&#34;Data characteristics for {st.identifier()} must be a dictionary&#34;
        )
    ch[&#34;description&#34;] = ch.get(&#34;description&#34;, &#34;&#34;)
    ch[&#34;type_identifier&#34;] = ch.get(&#34;type_ident&#34;, st.identifier())
    return ch</code></pre>
</details>
</dd>
<dt id="liquer.state_types.decode_state_data"><code class="name flex">
<span>def <span class="ident">decode_state_data</span></span>(<span>b, type_identifier, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to decode state data.
Requires binary representation of the state data and state type identifier.
Extension decides which data format is used for decoding.
If not supplied, a default extension defined for the state type is used.
Returns a tuple with binary representation of the data, mime type and state type identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_state_data(b, type_identifier, extension=None):
    &#34;&#34;&#34;Helper function to decode state data.
    Requires binary representation of the state data and state type identifier.
    Extension decides which data format is used for decoding.
    If not supplied, a default extension defined for the state type is used.
    Returns a tuple with binary representation of the data, mime type and state type identifier.
    &#34;&#34;&#34;
    t = state_types_registry().get(type_identifier)
    return t.from_bytes(b, extension=extension)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.encode_state_data"><code class="name flex">
<span>def <span class="ident">encode_state_data</span></span>(<span>data, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to encode state data.
Extension decides which data format is used for encoding.
If not supplied, a default extension defined for the state type is used.
Returns a tuple with binary representation of the data, mime type and state type identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_state_data(data, extension=None):
    &#34;&#34;&#34;Helper function to encode state data.
    Extension decides which data format is used for encoding.
    If not supplied, a default extension defined for the state type is used.
    Returns a tuple with binary representation of the data, mime type and state type identifier.
    &#34;&#34;&#34;
    reg = state_types_registry()
    t = reg.get(get_type_qualname(type(data)))
    b, mime = t.as_bytes(data, extension=extension)
    return b, mime, t.identifier()</code></pre>
</details>
</dd>
<dt id="liquer.state_types.get_type_qualname"><code class="name flex">
<span>def <span class="ident">get_type_qualname</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a string uniquely identifying the supplied class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_qualname(cls):
    &#34;&#34;&#34;Get a string uniquely identifying the supplied class&#34;&#34;&#34;
    if isinstance(cls, str):
        return cls
    if cls.__module__ == &#34;__main__&#34;:
        return cls.__qualname__
    return f&#34;{cls.__module__}.{cls.__qualname__}&#34;</code></pre>
</details>
</dd>
<dt id="liquer.state_types.register_state_type"><code class="name flex">
<span>def <span class="ident">register_state_type</span></span>(<span>type_qualname, state_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to register new state type for a qualified type name
type_qualname can be a string (module.ClassName) or a class/type object (not a data instance)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_state_type(type_qualname, state_type):
    &#34;&#34;&#34;Function to register new state type for a qualified type name
    type_qualname can be a string (module.ClassName) or a class/type object (not a data instance)
    &#34;&#34;&#34;
    type_qualname = get_type_qualname(type_qualname)
    state_types_registry().register(type_qualname, state_type)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.state_type_from_type_identifier"><code class="name flex">
<span>def <span class="ident">state_type_from_type_identifier</span></span>(<span>type_identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to return a state type for supplied type identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_type_from_type_identifier(type_identifier):
    &#34;&#34;&#34;Convenience function to return a state type for supplied type identifier&#34;&#34;&#34;

    return state_types_registry().from_type_identifier(type_identifier)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.state_types_registry"><code class="name flex">
<span>def <span class="ident">state_types_registry</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global state types registry (singleton)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_types_registry():
    &#34;&#34;&#34;Returns the global state types registry (singleton)&#34;&#34;&#34;
    global _state_types_registry
    if _state_types_registry is None:
        _state_types_registry = StateTypesRegistry()
    return _state_types_registry</code></pre>
</details>
</dd>
<dt id="liquer.state_types.type_identifier_of"><code class="name flex">
<span>def <span class="ident">type_identifier_of</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to return a state type identifier for supplied data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_identifier_of(data):
    &#34;&#34;&#34;Convenience function to return a state type identifier for supplied data&#34;&#34;&#34;
    return state_types_registry().get(get_type_qualname(type(data))).identifier()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="liquer.state_types.BytesStateType"><code class="flex name class">
<span>class <span class="ident">BytesStateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BytesStateType(StateType):
    &#34;&#34;&#34;Binary data&#34;&#34;&#34;

    def identifier(self):
        return &#34;bytes&#34;

    def default_extension(self):
        return &#34;b&#34;

    def default_mimetype(self):
        return &#34;application/octet-stream&#34;

    def is_type_of(self, data):
        return isinstance(data, bytes)

    def as_bytes(self, data, extension=None):
        return data, mimetype_from_extension(extension)

    def from_bytes(self, b: bytes, extension=None):
        return b

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        return dict(description=f&#34;{len(data)} bytes&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.state_types.DictStateType"><code class="flex name class">
<span>class <span class="ident">DictStateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>JSON serializable data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictStateType(StateType):
    &#34;&#34;&#34;JSON serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;dictionary&#34;

    def default_extension(self):
        return &#34;json&#34;

    def is_type_of(self, data):
        return isinstance(data, dict)

    def encode_element(self, data_element):
        if isinstance(data_element, (int, float, str)) or data_element is None:
            return json.dumps(data_element)
        else:
            reg = state_types_registry()
            t = reg.get(get_type_qualname(type(data_element)))
            extension = t.default_extension()
            b, mime = t.as_bytes(data_element, extension=extension)
            txt = base64.b64encode(b).decode(&#34;utf-8&#34;)
            return &#39;[%-10s, %-4s, &#34;%s&#34;]&#39; % (
                f&#39;&#34;{t.identifier()}&#34;&#39;,
                f&#39;&#34;{extension}&#34;&#39;,
                txt,
            )

    def decode_element(self, data_element_encoded):
        if isinstance(data_element_encoded, list):
            type_identifier, extension, b64 = data_element_encoded
            b = base64.b64decode(b64)
            return decode_state_data(b, type_identifier, extension)
        else:
            return data_element_encoded

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension == &#34;djson&#34;:
            d = &#34;{\n&#34;
            sep = &#34;&#34;
            for key, value in data.items():
                assert isinstance(key, str)
                d += sep
                d += &#34;%-20s%s&#34; % (f&#39;&#34;{key}&#34;:&#39;, self.encode_element(value))
                sep = &#34;,\n&#34;
            d += &#34;\n}&#34;
            return d.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;djson&#34;)
        elif extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;json&#34;)

        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()
        if extension == &#34;djson&#34;:
            d = {}
            for key, value in json.loads(b.decode(&#34;utf-8&#34;)).items():
                d[key] = self.decode_element(value)
            return d
        elif extension == &#34;json&#34;:
            return json.loads(b.decode(&#34;utf-8&#34;))

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        return dict(
            description=f&#34;Dictionary with {len(data)} items.&#34;,
            keys=sorted(str(k) for k in data.keys()),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.state_types.DictStateType.decode_element"><code class="name flex">
<span>def <span class="ident">decode_element</span></span>(<span>self, data_element_encoded)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_element(self, data_element_encoded):
    if isinstance(data_element_encoded, list):
        type_identifier, extension, b64 = data_element_encoded
        b = base64.b64decode(b64)
        return decode_state_data(b, type_identifier, extension)
    else:
        return data_element_encoded</code></pre>
</details>
</dd>
<dt id="liquer.state_types.DictStateType.encode_element"><code class="name flex">
<span>def <span class="ident">encode_element</span></span>(<span>self, data_element)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_element(self, data_element):
    if isinstance(data_element, (int, float, str)) or data_element is None:
        return json.dumps(data_element)
    else:
        reg = state_types_registry()
        t = reg.get(get_type_qualname(type(data_element)))
        extension = t.default_extension()
        b, mime = t.as_bytes(data_element, extension=extension)
        txt = base64.b64encode(b).decode(&#34;utf-8&#34;)
        return &#39;[%-10s, %-4s, &#34;%s&#34;]&#39; % (
            f&#39;&#34;{t.identifier()}&#34;&#39;,
            f&#39;&#34;{extension}&#34;&#39;,
            txt,
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.state_types.JsonStateType"><code class="flex name class">
<span>class <span class="ident">JsonStateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>JSON serializable data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonStateType(StateType):
    &#34;&#34;&#34;JSON serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;generic&#34;

    def default_extension(self):
        return &#34;json&#34;

    def is_type_of(self, data):
        return True

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), self.default_mimetype()
        elif extension in [&#34;html&#34;, &#34;htm&#34;]:
            if isinstance(data, str):
                return data.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;html&#34;)
            else:
                return (
                    f&#34;&lt;pre&gt;{json.dumps(data)}&lt;/pre&gt;&#34;.encode(&#34;utf-8&#34;),
                    mimetype_from_extension(&#34;html&#34;),
                )
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()

        assert extension == &#34;json&#34;
        return json.loads(b.decode(&#34;utf-8&#34;))

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        if isinstance(data, dict):
            return dict(
                description=f&#34;Dictionary with {len(data)} items.&#34;,
                keys=sorted(str(k) for k in data.keys()),
            )
        elif isinstance(data, dict):
            return dict(description=f&#34;Array with {len(data)} items.&#34;)
        elif isinstance(data, str):
            return dict(description=f&#34;Text {len(data)} characters long.&#34;)
        elif isinstance(data, bool):
            return dict(description=f&#34;Bool {data}&#34;)
        elif isinstance(data, int):
            return dict(description=f&#34;Integer {data}&#34;)
        elif isinstance(data, float):
            return dict(description=f&#34;Float {data}&#34;)
        elif data is None:
            return dict(description=f&#34;None&#34;)
        else:
            return dict(description=f&#34;Data of type {type(data)}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.state_types.PickleStateType"><code class="flex name class">
<span>class <span class="ident">PickleStateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Pickle-serializable data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PickleStateType(StateType):
    &#34;&#34;&#34;Pickle-serializable data.&#34;&#34;&#34;

    def identifier(self):
        return &#34;pickle&#34;

    def default_extension(self):
        return &#34;pickle&#34;

    def is_type_of(self, data):
        return True

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension in [&#34;pkl&#34;, &#34;pickle&#34;]:
            return pickle.dumps(data), mimetype_from_extension(&#34;pickle&#34;)
        elif extension == &#34;json&#34;:
            return json.dumps(data).encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;json&#34;)
        elif extension in [&#34;html&#34;, &#34;htm&#34;]:
            if isinstance(data, str):
                return data.encode(&#34;utf-8&#34;), mimetype_from_extension(&#34;html&#34;)
            else:
                return (
                    f&#34;&lt;pre&gt;{json.dumps(data)}&lt;/pre&gt;&#34;.encode(&#34;utf-8&#34;),
                    mimetype_from_extension(&#34;html&#34;),
                )
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def from_bytes(self, b: bytes, extension=None):
        if extension is None:
            extension = self.default_extension()

        if extension in [&#34;pkl&#34;, &#34;pickle&#34;]:
            return pickle.loads(b)
        elif extension == &#34;json&#34;:
            return json.loads(b.decode(&#34;utf-8&#34;))
        raise Exception(f&#34;Unsupported file extension: {extension}&#34;)

    def copy(self, data):
        return deepcopy(data)

    def data_characteristics(self, data):
        if isinstance(data, dict):
            return dict(
                description=f&#34;Dictionary with {len(data)} items.&#34;,
                keys=sorted(str(k) for k in data.keys()),
            )
        elif isinstance(data, dict):
            return dict(description=f&#34;Array with {len(data)} items.&#34;)
        elif isinstance(data, str):
            return dict(description=f&#34;Text {len(data)} characters long.&#34;)
        elif isinstance(data, bool):
            return dict(description=f&#34;Bool {data}&#34;)
        elif isinstance(data, int):
            return dict(description=f&#34;Integer {data}&#34;)
        elif isinstance(data, float):
            return dict(description=f&#34;Float {data}&#34;)
        elif data is None:
            return dict(description=f&#34;None&#34;)
        else:
            return dict(description=f&#34;Data of type {type(data)}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.state_types.StateType"><code class="flex name class">
<span>class <span class="ident">StateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract state type basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateType(object):
    &#34;&#34;&#34;Abstract state type basis&#34;&#34;&#34;

    def identifier(self):
        &#34;&#34;&#34;String identifier of the state type&#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define a state type identifier&#34;
        )

    def default_extension(self):
        &#34;&#34;&#34;Default file extension; determines the default data format
        Must be consistent with the default_mimetype.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;State type class must define the default extension&#34;)

    def default_filename(self):
        &#34;&#34;&#34;Default file name&#34;&#34;&#34;
        return &#34;data.&#34; + self.default_extension()

    def default_mimetype(self):
        &#34;&#34;&#34;Default mime type - must be consistent with the default_extension&#34;&#34;&#34;
        return MIMETYPES.get(self.default_extension(), &#34;text/plain&#34;)

    def is_type_of(self, data):
        &#34;&#34;&#34;Returns true if data is of this state type&#34;&#34;&#34;
        return False

    def as_bytes(self, data, extension=None):
        &#34;&#34;&#34;Serialize data as bytes.
        Data must be of this state type. Extension determines the serialization format. If none, default extension is used.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define serialization to bytes (as_bytes)&#34;
        )

    def from_bytes(self, b: bytes, extension=None):
        &#34;&#34;&#34;Deserialize data from bytes.
        Data must be a binary representation of this state type.
        Extension determines the serialization format. If none, default extension is used.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;State type class must define deserialization from bytes (from_bytes)&#34;
        )

    def copy(self, data):
        &#34;&#34;&#34;Create a deep copy of data.
        Data must be of this state type.&#34;&#34;&#34;
        return self.from_bytes(self.as_bytes(data)[:])

    def data_characteristics(self, data):
        &#34;&#34;&#34;Create state-type-dependent data characteristics for supplied data.
        Returned data characteristics must be a dictionary containing at least a &#34;description&#34;
        element with a string description of the data and a &#34;type_identifier&#34;.
        Type identifier is duplicate of the type identifier found in metadata, but makes
        the data characteristics self-contained.

        This method should not be called directly, but via the data_characteristics function,
        which might fix and validate some issues.
        &#34;&#34;&#34;
        return dict(description=&#34;&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.ext.dataframe_batches.StoredDataframeIteratorStateType" href="ext/dataframe_batches.html#liquer.ext.dataframe_batches.StoredDataframeIteratorStateType">StoredDataframeIteratorStateType</a></li>
<li><a title="liquer.ext.lq_datafusion.DatafusionContextStateType" href="ext/lq_datafusion.html#liquer.ext.lq_datafusion.DatafusionContextStateType">DatafusionContextStateType</a></li>
<li><a title="liquer.ext.lq_datafusion.DatafusionDataframeStateType" href="ext/lq_datafusion.html#liquer.ext.lq_datafusion.DatafusionDataframeStateType">DatafusionDataframeStateType</a></li>
<li>liquer.ext.lq_hxl.HxlStateType</li>
<li><a title="liquer.ext.lq_matplotlib.MatplotlibFigureStateType" href="ext/lq_matplotlib.html#liquer.ext.lq_matplotlib.MatplotlibFigureStateType">MatplotlibFigureStateType</a></li>
<li><a title="liquer.ext.lq_openpyxl.OpenpyxlWorkbookStateType" href="ext/lq_openpyxl.html#liquer.ext.lq_openpyxl.OpenpyxlWorkbookStateType">OpenpyxlWorkbookStateType</a></li>
<li><a title="liquer.ext.lq_pandas.DataframeStateType" href="ext/lq_pandas.html#liquer.ext.lq_pandas.DataframeStateType">DataframeStateType</a></li>
<li><a title="liquer.ext.lq_pil.PILImageStateType" href="ext/lq_pil.html#liquer.ext.lq_pil.PILImageStateType">PILImageStateType</a></li>
<li><a title="liquer.ext.lq_polars.PolarsDataframeStateType" href="ext/lq_polars.html#liquer.ext.lq_polars.PolarsDataframeStateType">PolarsDataframeStateType</a></li>
<li><a title="liquer.ext.lq_polars.PolarsLazyframeStateType" href="ext/lq_polars.html#liquer.ext.lq_polars.PolarsLazyframeStateType">PolarsLazyframeStateType</a></li>
<li><a title="liquer.ext.lq_polars.PolarsSQLContextStateType" href="ext/lq_polars.html#liquer.ext.lq_polars.PolarsSQLContextStateType">PolarsSQLContextStateType</a></li>
<li><a title="liquer.ext.lq_pptx.PPTXPresentationStateType" href="ext/lq_pptx.html#liquer.ext.lq_pptx.PPTXPresentationStateType">PPTXPresentationStateType</a></li>
<li><a title="liquer.state_types.BytesStateType" href="#liquer.state_types.BytesStateType">BytesStateType</a></li>
<li><a title="liquer.state_types.DictStateType" href="#liquer.state_types.DictStateType">DictStateType</a></li>
<li><a title="liquer.state_types.JsonStateType" href="#liquer.state_types.JsonStateType">JsonStateType</a></li>
<li><a title="liquer.state_types.PickleStateType" href="#liquer.state_types.PickleStateType">PickleStateType</a></li>
<li><a title="liquer.state_types.TextStateType" href="#liquer.state_types.TextStateType">TextStateType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.state_types.StateType.as_bytes"><code class="name flex">
<span>def <span class="ident">as_bytes</span></span>(<span>self, data, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize data as bytes.
Data must be of this state type. Extension determines the serialization format. If none, default extension is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_bytes(self, data, extension=None):
    &#34;&#34;&#34;Serialize data as bytes.
    Data must be of this state type. Extension determines the serialization format. If none, default extension is used.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;State type class must define serialization to bytes (as_bytes)&#34;
    )</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a deep copy of data.
Data must be of this state type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, data):
    &#34;&#34;&#34;Create a deep copy of data.
    Data must be of this state type.&#34;&#34;&#34;
    return self.from_bytes(self.as_bytes(data)[:])</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.data_characteristics"><code class="name flex">
<span>def <span class="ident">data_characteristics</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Create state-type-dependent data characteristics for supplied data.
Returned data characteristics must be a dictionary containing at least a "description"
element with a string description of the data and a "type_identifier".
Type identifier is duplicate of the type identifier found in metadata, but makes
the data characteristics self-contained.</p>
<p>This method should not be called directly, but via the data_characteristics function,
which might fix and validate some issues.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_characteristics(self, data):
    &#34;&#34;&#34;Create state-type-dependent data characteristics for supplied data.
    Returned data characteristics must be a dictionary containing at least a &#34;description&#34;
    element with a string description of the data and a &#34;type_identifier&#34;.
    Type identifier is duplicate of the type identifier found in metadata, but makes
    the data characteristics self-contained.

    This method should not be called directly, but via the data_characteristics function,
    which might fix and validate some issues.
    &#34;&#34;&#34;
    return dict(description=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.default_extension"><code class="name flex">
<span>def <span class="ident">default_extension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Default file extension; determines the default data format
Must be consistent with the default_mimetype.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_extension(self):
    &#34;&#34;&#34;Default file extension; determines the default data format
    Must be consistent with the default_mimetype.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;State type class must define the default extension&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.default_filename"><code class="name flex">
<span>def <span class="ident">default_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Default file name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_filename(self):
    &#34;&#34;&#34;Default file name&#34;&#34;&#34;
    return &#34;data.&#34; + self.default_extension()</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.default_mimetype"><code class="name flex">
<span>def <span class="ident">default_mimetype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Default mime type - must be consistent with the default_extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_mimetype(self):
    &#34;&#34;&#34;Default mime type - must be consistent with the default_extension&#34;&#34;&#34;
    return MIMETYPES.get(self.default_extension(), &#34;text/plain&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.from_bytes"><code class="name flex">
<span>def <span class="ident">from_bytes</span></span>(<span>self, b:Â bytes, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize data from bytes.
Data must be a binary representation of this state type.
Extension determines the serialization format. If none, default extension is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bytes(self, b: bytes, extension=None):
    &#34;&#34;&#34;Deserialize data from bytes.
    Data must be a binary representation of this state type.
    Extension determines the serialization format. If none, default extension is used.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;State type class must define deserialization from bytes (from_bytes)&#34;
    )</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.identifier"><code class="name flex">
<span>def <span class="ident">identifier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>String identifier of the state type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identifier(self):
    &#34;&#34;&#34;String identifier of the state type&#34;&#34;&#34;
    raise NotImplementedError(
        &#34;State type class must define a state type identifier&#34;
    )</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateType.is_type_of"><code class="name flex">
<span>def <span class="ident">is_type_of</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if data is of this state type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_type_of(self, data):
    &#34;&#34;&#34;Returns true if data is of this state type&#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.state_types.StateTypesRegistry"><code class="flex name class">
<span>class <span class="ident">StateTypesRegistry</span></span>
</code></dt>
<dd>
<div class="desc"><p>State type registry takes care of registering and lookup of state types.
It is typically accessed as a singleton via state_type_registry() function.</p>
<p>default_state_type attribute is used if state type is not recognized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateTypesRegistry(object):
    &#34;&#34;&#34;State type registry takes care of registering and lookup of state types.
    It is typically accessed as a singleton via state_type_registry() function.

    default_state_type attribute is used if state type is not recognized.
    &#34;&#34;&#34;

    def __init__(self):
        self.state_types_dictionary = {}
        self.register(bytes, BytesStateType())
        self.register(str, TextStateType())
        self.register(dict, DictStateType())
        self.register(type(None), JsonStateType())
        self.register(int, JsonStateType())
        self.register(float, JsonStateType())
        self.default_state_type = PickleStateType()

    def register(self, type_qualname, state_type):
        &#34;&#34;&#34;Register a new state type for a qualified type name&#34;&#34;&#34;
        type_qualname = get_type_qualname(type_qualname)
        self.state_types_dictionary[type_qualname] = state_type
        self.state_types_dictionary[state_type.identifier()] = state_type
        return self

    def get(self, type_qualname):
        &#34;&#34;&#34;Get state type object for a qualified type name
        If the qualified type name is not recognized, default_state_type is returned.
        &#34;&#34;&#34;
        if type_qualname is None:
            return self.default_state_type
        type_qualname = get_type_qualname(type_qualname)
        return self.state_types_dictionary.get(type_qualname, self.default_state_type)

    def from_type_identifier(self, type_identifier):
        &#34;&#34;&#34;Get state type object for a qualified type name
        If the qualified type name is not recognized, default_state_type is returned.
        &#34;&#34;&#34;
        for x in self.state_types_dictionary.values():
            if x.identifier() == type_identifier:
                return x</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="liquer.state_types.StateTypesRegistry.from_type_identifier"><code class="name flex">
<span>def <span class="ident">from_type_identifier</span></span>(<span>self, type_identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Get state type object for a qualified type name
If the qualified type name is not recognized, default_state_type is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_type_identifier(self, type_identifier):
    &#34;&#34;&#34;Get state type object for a qualified type name
    If the qualified type name is not recognized, default_state_type is returned.
    &#34;&#34;&#34;
    for x in self.state_types_dictionary.values():
        if x.identifier() == type_identifier:
            return x</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateTypesRegistry.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, type_qualname)</span>
</code></dt>
<dd>
<div class="desc"><p>Get state type object for a qualified type name
If the qualified type name is not recognized, default_state_type is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, type_qualname):
    &#34;&#34;&#34;Get state type object for a qualified type name
    If the qualified type name is not recognized, default_state_type is returned.
    &#34;&#34;&#34;
    if type_qualname is None:
        return self.default_state_type
    type_qualname = get_type_qualname(type_qualname)
    return self.state_types_dictionary.get(type_qualname, self.default_state_type)</code></pre>
</details>
</dd>
<dt id="liquer.state_types.StateTypesRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, type_qualname, state_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new state type for a qualified type name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, type_qualname, state_type):
    &#34;&#34;&#34;Register a new state type for a qualified type name&#34;&#34;&#34;
    type_qualname = get_type_qualname(type_qualname)
    self.state_types_dictionary[type_qualname] = state_type
    self.state_types_dictionary[state_type.identifier()] = state_type
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.state_types.TextStateType"><code class="flex name class">
<span>class <span class="ident">TextStateType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Text data (string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextStateType(StateType):
    &#34;&#34;&#34;Text data (string)&#34;&#34;&#34;

    def identifier(self):
        return &#34;text&#34;

    def default_extension(self):
        return &#34;txt&#34;

    def default_mimetype(self):
        return &#34;text/plain&#34;

    def is_type_of(self, data):
        return isinstance(data, str)

    def as_bytes(self, data, extension=None):
        if extension is None:
            extension = self.default_extension()
            mime = self.default_mimetype()
        else:
            mime = mimetype_from_extension(extension, &#34;text/plain&#34;)
        return data.encode(&#34;utf-8&#34;), mime

    def from_bytes(self, b: bytes, extension=None):
        return b.decode(&#34;utf-8&#34;)

    def copy(self, data):
        return data[:]

    def data_characteristics(self, data):
        return dict(description=f&#34;Text {len(data)} characters long.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="liquer" href="index.html">liquer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="liquer.state_types.copy_state_data" href="#liquer.state_types.copy_state_data">copy_state_data</a></code></li>
<li><code><a title="liquer.state_types.data_characteristics" href="#liquer.state_types.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.decode_state_data" href="#liquer.state_types.decode_state_data">decode_state_data</a></code></li>
<li><code><a title="liquer.state_types.encode_state_data" href="#liquer.state_types.encode_state_data">encode_state_data</a></code></li>
<li><code><a title="liquer.state_types.get_type_qualname" href="#liquer.state_types.get_type_qualname">get_type_qualname</a></code></li>
<li><code><a title="liquer.state_types.register_state_type" href="#liquer.state_types.register_state_type">register_state_type</a></code></li>
<li><code><a title="liquer.state_types.state_type_from_type_identifier" href="#liquer.state_types.state_type_from_type_identifier">state_type_from_type_identifier</a></code></li>
<li><code><a title="liquer.state_types.state_types_registry" href="#liquer.state_types.state_types_registry">state_types_registry</a></code></li>
<li><code><a title="liquer.state_types.type_identifier_of" href="#liquer.state_types.type_identifier_of">type_identifier_of</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="liquer.state_types.BytesStateType" href="#liquer.state_types.BytesStateType">BytesStateType</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.state_types.DictStateType" href="#liquer.state_types.DictStateType">DictStateType</a></code></h4>
<ul class="">
<li><code><a title="liquer.state_types.DictStateType.decode_element" href="#liquer.state_types.DictStateType.decode_element">decode_element</a></code></li>
<li><code><a title="liquer.state_types.DictStateType.encode_element" href="#liquer.state_types.DictStateType.encode_element">encode_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.state_types.JsonStateType" href="#liquer.state_types.JsonStateType">JsonStateType</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.state_types.PickleStateType" href="#liquer.state_types.PickleStateType">PickleStateType</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.state_types.StateType" href="#liquer.state_types.StateType">StateType</a></code></h4>
<ul class="">
<li><code><a title="liquer.state_types.StateType.as_bytes" href="#liquer.state_types.StateType.as_bytes">as_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.copy" href="#liquer.state_types.StateType.copy">copy</a></code></li>
<li><code><a title="liquer.state_types.StateType.data_characteristics" href="#liquer.state_types.StateType.data_characteristics">data_characteristics</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_extension" href="#liquer.state_types.StateType.default_extension">default_extension</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_filename" href="#liquer.state_types.StateType.default_filename">default_filename</a></code></li>
<li><code><a title="liquer.state_types.StateType.default_mimetype" href="#liquer.state_types.StateType.default_mimetype">default_mimetype</a></code></li>
<li><code><a title="liquer.state_types.StateType.from_bytes" href="#liquer.state_types.StateType.from_bytes">from_bytes</a></code></li>
<li><code><a title="liquer.state_types.StateType.identifier" href="#liquer.state_types.StateType.identifier">identifier</a></code></li>
<li><code><a title="liquer.state_types.StateType.is_type_of" href="#liquer.state_types.StateType.is_type_of">is_type_of</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.state_types.StateTypesRegistry" href="#liquer.state_types.StateTypesRegistry">StateTypesRegistry</a></code></h4>
<ul class="">
<li><code><a title="liquer.state_types.StateTypesRegistry.from_type_identifier" href="#liquer.state_types.StateTypesRegistry.from_type_identifier">from_type_identifier</a></code></li>
<li><code><a title="liquer.state_types.StateTypesRegistry.get" href="#liquer.state_types.StateTypesRegistry.get">get</a></code></li>
<li><code><a title="liquer.state_types.StateTypesRegistry.register" href="#liquer.state_types.StateTypesRegistry.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.state_types.TextStateType" href="#liquer.state_types.TextStateType">TextStateType</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>