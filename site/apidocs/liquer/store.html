<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>liquer.store API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>liquer.store</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from os import makedirs, name, remove
from pathlib import Path
import json
from io import BytesIO
from liquer.constants import *
import liquer.util as util
import hashlib
from liquer.metadata import Metadata
import traceback

&#34;&#34;&#34;Store is a flexible filesystem-like key-value store.
Stores support reading and writing of binary data and the associated metadata.
Data from the store can typically be accessed through the resource part of the query:

file/in/store.txt/-/some_command/another_command

This query is split to two parts by /-/, the first part is the resource query (file/in/store.txt),
and the second part is the standard query (some_command/another_command).
Query is interpreted as
- first read file/in/store.txt from store
- pass it as bytes to the query,
so it is equivalent to

another_command(some_command(store.get_bytes(&#39;file/in/store.txt&#39;)))

Stores can be combined and composed in various way (see e.g. mount function and method).
Various store types are supported: memory store (MemoryStore), local filesystem store (FileStore),
overlays and other. The FileSystemStore allows to mount ftp servers, zip and files via PyFilesystem2.

There is always a default main store, which can be obtained by get_store().
This is typically passed ty commands via context.store().

By convention, the folder &#34;web&#34; in the get_store() holds web interface and can be accessed via
/liquer/web url. 

&#34;&#34;&#34;

STORE = None
WEB_STORE = None


def get_store():
    &#34;&#34;&#34;Get global Store
    If no store is specified, a default store is created as a MountPointStore with indexer.
    Note that This will run the global indexer whenever the data is written into the store.
    See the StoreMixin.with_indexer method and the liquer.indexer module.
    &#34;&#34;&#34;
    global STORE
    if STORE is None:
        STORE = MountPointStore().with_indexer()
    return STORE


def set_store(store):
    &#34;Set global Store&#34;
    global STORE
    STORE = store


def get_web_store():
    &#34;&#34;&#34;Web store is the store for the /web folder.
    The purpose of this folder is to be able to efficiently serve web content.

    The web store is special in several ways:
    - It must be a mount point store, since the LiQuer plugins (e.g. the liquer_gui)
      mount sub folders with web applications into it.
    - The content of the store is accessible through liquer/web (as well as via liquer/api/store/data).
    - If the key points to a directory when accessed over liquer/web, the key/index.html is served.
    &#34;&#34;&#34;
    global WEB_STORE
    if WEB_STORE is None:
        WEB_STORE = MountPointStore()
        get_store().mount(&#34;web&#34;, WEB_STORE)
    return WEB_STORE


def mount(key, store=None):
    &#34;&#34;&#34;Mount a sub-store into the global store under the key.
    If store argument is a string or Path, it is interpreted as a path and converted to a FileStore
    &#34;&#34;&#34;
    if store is None:
        store = key
    if type(store) is str:
        store = FileStore(store)
    get_store().mount(key, store)


def mount_folder(key, path):
    get_store().mount(key, FileStore(path))


def web_mount(key, store=None):
    &#34;&#34;&#34;Like mount, but mounts into the web store. (see get_web_store)&#34;&#34;&#34;
    if store is None:
        store = key
    if type(store) is str:
        store = FileStore(store)
    get_web_store().mount(key, store)


def web_mount_folder(key, path):
    web_mount(key, FileStore(path))


class StoreException(Exception):
    &#34;&#34;&#34;General superclass for exceptions associated with a store&#34;&#34;&#34;
    def __init__(self, message, key=None, store=None):
        self.original_message = message
        if key is not None:
            k = key if store is None else store.to_root_key(key)
            message += f&#34;:\n  key: &#39;{k}&#39;&#34;
        if store is not None:
            message += f&#34;  store: {store}&#34;

        super().__init__(message)
        self.key = key
        self.store = store


class KeyNotFoundStoreException(StoreException):
    def __init__(self, message=&#34;Key not found in store&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)


class KeyNotSupportedStoreException(StoreException):
    def __init__(self, message=&#34;Key not supported in store&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)


class KeyRouteNotFoundStoreException(StoreException):
    def __init__(self, message=&#34;Key route not found&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)


class ReadOnlyStoreException(StoreException):
    def __init__(self, message=&#34;Key is read only&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)


class StoreMixin:
    &#34;Mixing adding extra functionality to stores.&#34;
    def with_overlay(self, overlay):
        &#34;&#34;&#34;Create an overlay over the store.
        Overlay store will be consulted first, when the key is not supported or not found in the overlay,
        the request will be passed to the current store (self).
        Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
        &#34;&#34;&#34;
        return OverlayStore(overlay, self)

    def with_fallback(self, fallback):
        &#34;&#34;&#34;Create a fallback for the store.
        When the key is not supported or not found in the current store (self),
        request will be passed to fallback.
        Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
        &#34;&#34;&#34;
        return OverlayStore(self, fallback)

    def mount(self, key, store):
        &#34;&#34;&#34;Mount a store in a mount-point&#34;&#34;&#34;
        if isinstance(self, MountPointStore):
            return self.mount(key, store)
        else:
            return MountPointStore(self).mount(key, store)

    def read_only(self):
        &#34;&#34;&#34;Create a read-only proxy for the store.&#34;&#34;&#34;
        if isinstance(self, ReadOnlyStore):
            return self
        else:
            return ReadOnlyStore(self)

    def with_indexer(self):
        &#34;&#34;&#34;Create a proxy store that will run indexer on each write.&#34;&#34;&#34;
        if isinstance(self, IndexerStore):
            return self
        else:
            return IndexerStore(self)


def key_name(key):
    &#34;&#34;&#34;Get name of the key - i.e. last component after slash.
    If key is None or empty, empty string is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return &#34;&#34;
    return str(key.split(&#34;/&#34;)[-1])


def key_name_without_extension(key):
    &#34;&#34;&#34;Get name without the fileextension of the key. If key is None or empty, None is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return None
    v = key_name(key).split(&#34;.&#34;)
    if len(v) &gt;= 2:
        return v[0]
    return None


def key_extension(key):
    &#34;&#34;&#34;Get fileextension of the key. If key is None or empty, None is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return None
    v = key_name(key).split(&#34;.&#34;)
    if len(v) &gt;= 2:
        return v[-1]
    return None


def join_key(key, name):
    &#34;&#34;&#34;Join key and name into a new key. If key is None or empty, name is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return name
    else:
        if key.endswith(&#34;/&#34;):
            return f&#34;{key}{name}&#34;
        else:
            return f&#34;{key}/{name}&#34;


def parent_key(key):
    &#34;&#34;&#34;Parent of the key (i.e. key without the last component)&#34;&#34;&#34;
    if key == &#34;&#34;:
        return None
    return &#34;/&#34;.join(key.split(&#34;/&#34;)[:-1])


class Store(StoreMixin):
    parent_store = None
    MD5_CHECKSUM = True

    def parent_key(self, key):
        &#34;For backwards compatibility only; use parent_key function&#34;
        return parent_key(key)

    def key_name(self, key):
        &#34;For backwards compatibility only; use key_name function&#34;
        return key_name(key)

    def join_key(self, key, name):
        &#34;For backwards compatibility only; use join_key function&#34;
        return join_key(key, name)

    def default_metadata(self, key, is_dir=False):
        if key is None:
            key = &#34;&#34;

        return dict(
            key=key,
            fileinfo=dict(name=key_name(key), is_dir=is_dir, filesystem_path=None),
        )

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        if data is not None:
            if type(data) != bytes:
                print(f&#34;WARNING: Non-binary data for &#39;{key}&#39;: type is {type(data)}&#34;)
        if key is None:
            key = &#34;&#34;
        metadata[&#34;key&#34;] = key
        update = update or data is not None
        if update:
            metadata[&#34;updated&#34;] = util.now()
        if data is not None:
            metadata[&#34;created&#34;] = metadata[&#34;updated&#34;]
        metadata[&#34;fileinfo&#34;] = metadata.get(&#34;fileinfo&#34;, {})
        metadata[&#34;fileinfo&#34;][&#34;name&#34;] = key_name(key)
        metadata[&#34;fileinfo&#34;][&#34;is_dir&#34;] = is_dir
        metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = metadata[&#34;fileinfo&#34;].get(
            &#34;filesystem_path&#34;
        )

        if data is not None:
            metadata[&#34;fileinfo&#34;][&#34;size&#34;] = len(data)
            if self.MD5_CHECKSUM and type(data) == bytes:
                metadata[&#34;fileinfo&#34;][&#34;md5&#34;] = hashlib.md5(data).hexdigest()

        if metadata.get(&#34;mimetype&#34;) is None:
            mimetype = mimetype_from_extension(key_extension(key))
            metadata[&#34;mimetype&#34;] = mimetype

        if metadata.get(&#34;type_identifier&#34;) is None:
            type_identifier = type_identifier_from_extension(key_extension(key))
            metadata[&#34;type_identifier&#34;] = type_identifier

        return Metadata(metadata).as_dict()

    def get_bytes(self, key):
        &#34;&#34;&#34;Get data as bytes&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def get_metadata(self, key):
        &#34;&#34;&#34;Get metadata&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        &#34;&#34;&#34;Store data and metadata.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def store_metadata(self, key, metadata):
        &#34;&#34;&#34;Store metadata only.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def remove(self, key):
        &#34;&#34;&#34;Remove data and metadata associated with the key.&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def removedir(self, key):
        &#34;&#34;&#34;Remove directory.
        The key must be a directory.
        It depends on the underlying store whether the directory must be empty.
        &#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def contains(self, key):
        &#34;&#34;&#34;Returns true if store contains the key.&#34;&#34;&#34;
        return key == &#34;&#34;

    def is_dir(self, key):
        &#34;&#34;&#34;Returns true if key is a directory.&#34;&#34;&#34;
        return key == &#34;&#34;

    def keys(self):
        &#34;&#34;&#34;List or iterator of all keys&#34;&#34;&#34;
        return []

    def listdir(self, key):
        &#34;&#34;&#34;Return names inside a directory specified by key.
        To get a key, names need to be joined with the key (key/name).
        Complete keys can be obtained with the listdir_keys method.
        &#34;&#34;&#34;
        return []

    def listdir_keys(self, key):
        &#34;&#34;&#34;Return keys inside a directory specified by key.&#34;&#34;&#34;
        if key in (&#34;&#34;, None):
            return self.listdir(key)
        else:
            return [self.join_key(key, k) for k in self.listdir(key)]

    def makedir(self, key):
        &#34;Make a directory&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        &#34;&#34;&#34;Return a file handle.
        This is not necessarily always well supported, but it is required to support PyFilesystem2.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def is_supported(self, key):
        &#34;&#34;&#34;Returns true when this store supports the supplied key.
        This allows layering Stores, e.g. by with_overlay, with_fallback
        and store selectively certain data (keys) in certain stores.
        &#34;&#34;&#34;
        return False

    def on_data_changed(self, key):
        &#34;&#34;&#34;Event handler called when the data is changed.&#34;&#34;&#34;
        pass

    def on_metadata_changed(self, key):
        &#34;&#34;&#34;Event handler called when the metadata is changed.&#34;&#34;&#34;
        pass

    def on_removed(self, key):
        &#34;&#34;&#34;Event handler called when the data or directory is removed.&#34;&#34;&#34;
        pass

    def to_root_key(self, key):
        &#34;&#34;&#34;Convert local store key to a key in a root store.
        This is can be used e.g. to convert a key valid in a mounted (child) store to
        a key of a root store.
        The to_root_key(key) in the root_store() should point to the same object as key in self.
        &#34;&#34;&#34;
        if self.parent_store is None:
            return key
        return self.parent_store.to_root_key(key)

    def root_store(self):
        &#34;&#34;&#34;Get the root store.
        Root store is the highest level store in the store system.
        The to_root_key(key) in the root_store() should point to the same object as key in self.
        &#34;&#34;&#34;
        if self.parent_store is None:
            return self
        return self.parent_store.root_store()

    def sync(self):
        pass

    def __str__(self):
        return f&#34;Empty store&#34;

    def __repr__(self):
        return f&#34;Store()&#34;


class FileStore(Store):
    METADATA = &#34;__metadata__&#34;

    def __init__(self, path):
        if isinstance(path, Path):
            self.path = path
        else:
            self.path = Path(path)

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        metadata = super().finalize_metadata(
            metadata, key=key, is_dir=is_dir, data=data, update=update
        )
        metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = str(self.path_for_key(key).resolve())
        return Metadata(metadata).as_dict()

    def path_for_key(self, key):
        if key in (None, &#34;&#34;):
            return self.path
        p = self.path / key
        assert p.name != self.METADATA
        return p

    def metadata_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return p.parent / self.METADATA / (p.name + &#34;.json&#34;)

    def get_bytes(self, key):
        if not self.path_for_key(key).exists():
            raise KeyNotFoundStoreException(key=key, store=self)
        with open(self.path_for_key(key), &#34;rb&#34;) as f:
            b = f.read()
        return b

    def get_metadata(self, key):
        p = self.path_for_key(key)
        metadata = self.default_metadata(key, p.is_dir())

        if p.is_dir():
            return self.finalize_metadata(metadata, key=key, is_dir=True)
        else:
            if self.path_for_key(key).exists():
                if self.metadata_path_for_key(key).exists():
                    with open(self.metadata_path_for_key(key)) as f:
                        try:
                            metadata.update(json.loads(f.read()))
                        except:
                            traceback.print_exc()
                            print(f&#34;Removing {key} due to corrupted metadata (a)&#34;)
                            self.remove(key)
                            raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    m = Metadata()
                    m.status = Status.EXTERNAL
                    return self.finalize_metadata(m.as_dict(), key=key)

            else:
                if self.metadata_path_for_key(key).exists():
                    with open(self.metadata_path_for_key(key)) as f:
                        try:
                            metadata.update(json.loads(f.read()))
                        except:
                            traceback.print_exc()
                            print(f&#34;Removing {key} due to corrupted metadata (b)&#34;)
                            self.remove(key)
                            raise KeyNotFoundStoreException(key=key, store=self)

                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
        return self.finalize_metadata(metadata, key=key, is_dir=False)

    def store(self, key, data, metadata):
        self.path_for_key(key).parent.mkdir(parents=True, exist_ok=True)
        self.path_for_key(key).write_bytes(data)
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.metadata_path_for_key(key).parent.mkdir(parents=True, exist_ok=True)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        with open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        try:
            self.path_for_key(key).unlink()
        except FileNotFoundError:
            pass
        try:
            self.metadata_path_for_key(key).unlink()
        except FileNotFoundError:
            pass

        self.on_removed(key)

    def removedir(self, key):
        (self.path_for_key(key) / self.METADATA).rmdir()
        self.path_for_key(key).rmdir()
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.path_for_key(key).exists()

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.path_for_key(key).is_dir()

    def keys(self, parent=None):
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                key = k if parent is None else parent + &#34;/&#34; + k
                yield key
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if self.is_dir(key):
            return [
                d.name
                for d in self.path_for_key(key).iterdir()
                if d.name != self.METADATA
            ]

    def makedir(self, key):
        self.path_for_key(key).mkdir(parents=True, exist_ok=True)
        (self.path_for_key(key) / self.METADATA).mkdir(parents=True, exist_ok=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        return open(self.path_for_key(key), mode)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;File store at {self.path}&#34;

    def __repr__(self):
        return f&#34;FileStore(&#39;{self.path}&#39;)&#34;


class MemoryStore(Store):
    def __init__(self):
        self.directories = set()
        self.data = {}
        self.metadata = {}

    def get_bytes(self, key):
        if key not in self.data:
            raise KeyNotFoundStoreException(key=key, store=self)
        return self.data[key]

    def get_metadata(self, key):
        if key in self.metadata:
            metadata = self.metadata[key]
        else:
            if not self.is_dir(key):
                raise KeyNotFoundStoreException(key=key, store=self)

            metadata = self.default_metadata(key, is_dir=True)

        return self.finalize_metadata(metadata, key=key, is_dir=self.is_dir(key))

    def store(self, key, data, metadata):
        self.makedir(self.parent_key(key))
        self.data[key] = data
        self.metadata[key] = self.finalize_metadata(
            metadata, key=key, is_dir=False, data=data
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.metadata[key] = metadata
        self.on_metadata_changed(key)

    def remove(self, key):
        try:
            self.directories.remove(key)
        except KeyError:
            pass
        try:
            del self.data[key]
        except KeyError:
            pass
        try:
            del self.metadata[key]
        except KeyError:
            pass
        self.on_removed(key)

    def removedir(self, key):
        if len(self.listdir(key)) == 0:
            try:
                self.directories.remove(key)
            except KeyError:
                pass
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return key in self.directories or key in self.data or key in self.metadata

    def is_dir(self, key):
        if key in (None, &#34;&#34;):
            return True
        return key in self.directories

    def keys(self):
        k = set()
        k.update(self.directories)
        k.update(self.data.keys())
        k.update(self.metadata.keys())
        return sorted(k)

    def listdir(self, key):
        if key in (&#34;&#34;, None):
            return sorted(
                set(k.split(&#34;/&#34;)[0] for k in self.keys() if k.split(&#34;/&#34;)[0] != &#34;&#34;)
            )
        if self.is_dir(key):
            return [key_name(k) for k in self.keys() if self.parent_key(k) == key]

    def makedir(self, key):
        while key not in (None, &#34;&#34;):
            self.directories.add(key)
            key = self.parent_key(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        if mode == &#34;rb&#34;:
            return BytesIO(self.data[key])
        raise Exception(&#34;openbin not supported for write yet&#34;)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;Memory store&#34;

    def __repr__(self):
        return f&#34;MemoryStore()&#34;


class ProxyStore(Store):
    &#34;&#34;&#34;Proxy to another store - can be used as a basis to override certain behaviour&#34;&#34;&#34;

    def __init__(self, store):
        self._store = store
        self._store.parent_store = self

    def sync(self):
        self._store.sync()

    def get_bytes(self, key):
        return self._store.get_bytes(key)

    def get_metadata(self, key):
        return self._store.get_metadata(key)

    def store(self, key, data, metadata):
        self._store.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self._store.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self._store.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self._store.remove(key)
        self.on_removed(key)

    def contains(self, key):
        return self._store.contains(key)

    def is_dir(self, key):
        return self._store.is_dir(key)

    def keys(self):
        return self._store.keys()

    def listdir(self, key):
        return self._store.listdir(key)

    def makedir(self, key):
        self._store.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self._store.openbin(key, mode, buffering)

    def is_supported(self, key):
        return self._store.is_supported(key)

    def __str__(self):
        return f&#34;proxy of {self._store}&#34;

    def __repr__(self):
        return f&#34;ProxyStore({repr(self._store)})&#34;


class IndexerStore(ProxyStore):
    &#34;&#34;&#34;Indexer proxy to another store - this will call indexer on storing.&#34;&#34;&#34;

    def store(self, key, data, metadata):
        from liquer.indexer import index

        metadata = self._store.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        metadata = index(key=self.to_root_key(key), query=metadata.get(&#34;query&#34;), data=data, metadata=metadata)
        self._store.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def mount(self, key, store):
        &#34;&#34;&#34;Mount a store in a mount-point&#34;&#34;&#34;
        r = self._store.mount(key, store)
        self.sync()
        return r

    def __str__(self):
        return f&#34;Indexing {self._store}&#34;

    def __repr__(self):
        return f&#34;IndexerStore({repr(self._store)})&#34;

class ReadOnlyStore(ProxyStore):
    &#34;&#34;&#34;Read only proxy to a store&#34;&#34;&#34;

    def store(self, key, data, metadata):
        raise ReadOnlyStoreException(key=key, store=self)

    def store_metadata(self, key, metadata):
        raise ReadOnlyStoreException(key=key, store=self)

    def remove(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def removedir(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def makedir(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def __str__(self):
        return f&#34;read only proxy of {self._store}&#34;

    def __repr__(self):
        return f&#34;ReadOnlyStore({repr(self._store)})&#34;


class OverlayStore(Store):
    &#34;&#34;&#34;Overlay store combines two stores: overlay and fallback.
    Overlay is used as a primary store for reading and writing.
    The fallback is used only for reading if key is not found in the overlay store (and is not removed).
    Thus the fallback store is never modified.
    &#34;&#34;&#34;

    def __init__(self, overlay, fallback):
        self.overlay = overlay
        self.fallback = fallback
        self.removed = set()

    def sync(self):
        self.overlay.sync()
        self.fallback.sync()

    def get_bytes(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                return self.overlay.get_bytes(key)
            else:
                return self.fallback.get_bytes(key)

    def get_metadata(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                return self.overlay.get_metadata(key)
            else:
                return self.fallback.get_metadata(key)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        try:
            self.removed.remove(key)
        except KeyError:
            pass
        self.overlay.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        try:
            self.removed.remove(key)
        except KeyError:
            pass
        self.overlay.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                self.overlay.remove(key)
            if self.fallback.contains(key):
                self.removed.add(key)
        self.on_removed(key)

    def removedir(self, key):
        if self.contains(key):
            if len(self.listdir(key)) == 0:
                if self.overlay.contains(key):
                    self.overlay.remove(key)
                else:
                    self.removed.add(key)
        self.on_removed(key)

    def contains(self, key):
        if key in self.removed:
            return False
        else:
            return self.overlay.contains(key) or self.fallback.contains(key)

    def is_dir(self, key):
        if key in self.removed:
            return False
        else:
            if self.overlay.contains(key):
                return self.overlay.is_dir(key)
            else:
                return self.fallback.is_dir(key)

    def keys(self):
        return sorted(
            set(self.overlay.keys())
            .union(self.fallback.keys())
            .difference(self.removed)
        )

    def listdir(self, key):
        if key.endswith(&#34;/&#34;):
            key = key[:-1]
        ld = self.overlay.listdir(key)
        d = set() if ld is None else set(ld)
        ld = self.fallback.listdir(key)
        d = d if ld is None else d.union(ld)
        return [x for x in sorted(d) if key + &#34;/&#34; + x not in self.removed]

    def makedir(self, key):
        if key in self.removed:
            self.removed.remove(key)
        self.overlay.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        if mode == &#34;rb&#34;:
            if self.overlay.contains(key):
                return self.overlay.openbin(key, mode, buffering)
            elif self.fallback.contains(key):
                return self.fallback.openbin(key, mode, buffering)
        elif mode == &#34;wb&#34;:
            return self.overlay.openbin(key, mode, buffering)

    def is_supported(self, key):
        return self.overlay.is_supported(key) or self.fallback.is_supported(key())

    def __str__(self):
        return f&#34;Overlay of ({self.overlay}) over ({self.fallback})&#34;

    def __repr__(self):
        return f&#34;OverlayStore({repr(self.overlay)},{repr(self.fallback)})&#34;


class RoutingStore(Store):
    def route_to(self, key):
        raise KeyRouteNotFoundStoreException(key=key, store=self)

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        metadata = super().finalize_metadata(
            metadata, key=key, is_dir=is_dir, data=data, update=update
        )
        return metadata

    def is_supported(self, key):
        try:
            store = self.route_to(key)
            if store is None:
                return False
            return store.is_supported(key)
        except KeyNotSupportedStoreException:
            return False

    def get_bytes(self, key):
        return self.route_to(key).get_bytes(key)

    def get_metadata(self, key):
        metadata = self.route_to(key).get_metadata(key)
        metadata[&#34;key&#34;] = key
        return metadata

    def store(self, key, data, metadata):
        self.route_to(key).store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.route_to(key).store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.route_to(key).remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.route_to(key).removedir(key)
        self.on_removed(key)

    def contains(self, key):
        return self.route_to(key).contains(key)

    def is_dir(self, key):
        return self.route_to(key).is_dir(key)

    def keys(self):
        raise NotImplementedError

    def listdir(self, key):
        return self.route_to(key).listdir(key)

    def makedir(self, key):
        self.route_to(key).makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self.route_to(key).openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Abstract routing store&#34;

    def __repr__(self):
        return f&#34;RoutingStore()&#34;


class KeyTranslatingStore(Store):
    def __init__(self, store):
        self.substore = store
        self.substore.parent_store = self

    def sync(self):
        self.substore.sync()

    def translate_key(self, key, inverse=False):
        return key

    def to_root_key(self, key):
        &#34;&#34;&#34;Convert local store key to a key in a root store.
        This is can be used e.g. to convert a key valid in a mounted (child) store to
        a key of a root store.
        &#34;&#34;&#34;
        key = self.translate_key(key, inverse=True)
        if self.parent_store is None:
            return key
        return self.parent_store.to_root_key(key)

    def is_supported(self, key):
        try:
            tkey = self.translate_key(key)
            if tkey is None:
                return False
            return self.substore.is_supported(tkey)
        except KeyNotSupportedStoreException:
            return False

    def get_bytes(self, key):
        return self.substore.get_bytes(self.translate_key(key))

    def get_metadata(self, key):
        tkey = self.translate_key(key)
        metadata = self.substore.get_metadata(tkey)
        metadata[&#34;key&#34;] = key
        if &#34;recipes_key&#34; in metadata:
            metadata[&#34;recipes_key&#34;] = self.translate_key(
                metadata[&#34;recipes_key&#34;], inverse=True
            )
        return metadata

    def store(self, key, data, metadata):
        self.substore.store(self.translate_key(key), data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.substore.store_metadata(self.translate_key(key), metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(self.translate_key(key))
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(self.translate_key(key))
        self.on_removed(key)

    def contains(self, key):
        return self.substore.contains(self.translate_key(key))

    def is_dir(self, key):
        return self.substore.is_dir(self.translate_key(key))

    def keys(self):
        for key in self.substore.keys():
            yield self.translate_key(key, inverse=True)

    def listdir(self, key):
        return self.substore.listdir(self.translate_key(key))

    def makedir(self, key):
        self.substore.makedir(self.translate_key(key))
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self.substore.openbin(
            self.translate_key(key), mode=mode, buffering=buffering
        )

    def __str__(self):
        return f&#34;Key translating store on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;KeyTranslatingStore({repr(self.substore)})&#34;


class PrefixStore(KeyTranslatingStore):
    def __init__(self, store, prefix):
        self.substore = store
        self.prefix = prefix
        self.substore.parent_store = self

    def translate_key(self, key, inverse=False):
        prefix = self.prefix + &#34;/&#34;
        if inverse:
            if key in (None, &#34;&#34;):
                return self.prefix
            else:
                return prefix + key
        else:
            if key == self.prefix:
                return &#34;&#34;
            else:
                if key.startswith(prefix):
                    return key[len(prefix) :]
                else:
                    raise KeyNotSupportedStoreException

    def contains(self, key):
        if key == self.prefix:
            return True
        return self.substore.contains(self.translate_key(key))

    def is_dir(self, key):
        if key == self.prefix:
            return True
        return self.substore.is_dir(self.translate_key(key))

    def __str__(self):
        return f&#34;Prefixed store {self.prefix} on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;PrefixStore({repr(self.substore)}, prefix={repr(self.prefix)})&#34;


class MountPointStore(RoutingStore):
    def __init__(self, default_store=None, routing_table=None):
        self.default_store = default_store
        if default_store is not None:
            self.default_store.parent_store = self
        self.routing_table = [] if routing_table is None else routing_table

    def sync(self):
        for key, store in self.routing_table:
            store.sync()
        if self.default_store is not None:
            self.default_store.sync()

    def umount(self, umount_key):
        for key, store in self.routing_table:
            if key == umount_key:
                store.parent_store = None
        self.routing_table = [
            (key, store) for key, store in self.routing_table if key != umount_key
        ]
        return self

    def mount(self, key, store):
        self.umount(key)
        prefix_store = PrefixStore(store, prefix=key)
        prefix_store.parent_store = self
        self.routing_table.append((key, prefix_store))
        self.sync()
        return self

    def route_to(self, key):
        for prefix, store in reversed(self.routing_table):
            if key == prefix:
                return store
            if not prefix.endswith(&#34;/&#34;):
                prefix += &#34;/&#34;
            if key.startswith(prefix):
                if store.is_supported(key):
                    return store
        if self.default_store is not None:
            return self.default_store
        raise KeyRouteNotFoundStoreException(key=key, store=self)

    def get_metadata(self, key):
        try:
            metadata = self.route_to(key).get_metadata(key)
            metadata[&#34;key&#34;] = key

            return metadata
        except KeyRouteNotFoundStoreException:
            if self.is_dir(key):
                return self.finalize_metadata({}, key, is_dir=True)
        raise KeyNotFoundStoreException(key=key, store=self)

    def is_dir(self, key):
        if key == &#34;&#34;:
            return True
        try:
            return self.route_to(key).is_dir(key)
        except KeyRouteNotFoundStoreException:
            for route, _ in reversed(self.routing_table):
                if route == key or route.startswith(key + &#34;/&#34;):
                    return self.finalize_metadata({}, key, is_dir=True)
        return False

    def keys(self):
        prefixes = []
        for prefix, store in reversed(self.routing_table):
            yield prefix
            if not prefix.endswith(&#34;/&#34;):
                prefix += &#34;/&#34;
            for key in store.keys():
                if any(key.startswith(p) for p in prefixes):
                    continue
                if key.startswith(prefix):
                    yield key
            prefixes.append(prefix)
        if self.default_store is not None:
            for key in self.default_store.keys():
                if any(key.startswith(p) for p in prefixes):
                    continue
                yield key

    def listdir(self, key):
        try:
            store = self.route_to(key)
        except KeyRouteNotFoundStoreException:
            store = None

        if store is None:
            d = set()
        else:
            d = set(store.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for prefix, _ in self.routing_table:
            if prefix.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = prefix.split(&#34;/&#34;)
                d.add(v[key_depth])
        if self.default_store is not None:
            for prefix in self.default_store.keys():
                if prefix.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                    v = prefix.split(&#34;/&#34;)
                    d.add(v[key_depth])

        return sorted(d)

    def removedir(self, key):
        for k, store in self.routing_table:
            if k == key:
                raise StoreException(
                    f&#34;Can&#39;t remove {key} because it is a mount point of {repr(store)}&#34;,
                    key=key,
                    store=self,
                )

        return self.route_to(key).removedir(key)

    def __str__(self):
        return f&#34;Mount point store routed by {self.routing_table} with default store {self.default_store}&#34;

    def __repr__(self):
        return f&#34;MountPointStore({repr(self.default_store)}, routing_table={repr(self.routing_table)})&#34;


class FileSystemStore(Store):
    &#34;&#34;&#34;A store that uses the [PyFilesystem2](https://docs.pyfilesystem.org/en/latest/) as a backend.

    Though it seems to be working fine in Linux, some issues were found in Windows.
    This seems to not work reliable due to different implementations of PyFilesystem2.
    Notably, listdir() sometimes returns list of recurently items in the subdirectories.
    
    Consider using FSSpecStore based on [fsspec](https://filesystem-spec.readthedocs.io/en/latest/),
    which should have a better support.
    &#34;&#34;&#34;
    METADATA = &#34;__metadata__&#34;

    def __init__(self, fs, path=&#34;&#34;):
        if isinstance(path, Path):
            self.path = path
        else:
            self.path = Path(path)
        self.fs = fs

    def path_for_key(self, key):
        if key in (None, &#34;&#34;):
            return str(self.path)
        p = self.path / key
        assert p.name != self.METADATA
        return str(p)

    def metadata_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return str(p.parent / self.METADATA / (p.name + &#34;.json&#34;))

    def metadata_dir_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return str(p.parent / self.METADATA)

    def get_bytes(self, key):
        if not self.fs.exists(self.path_for_key(key)):
            raise KeyNotFoundStoreException(
                f&#34;Can&#39;t find {self.path_for_key(key)} in filesystem {self.fs}&#34;,
                key=key,
                store=self,
            )
        return self.fs.readbytes(self.path_for_key(key))

    def get_metadata(self, key):
        p = self.path_for_key(key)
        isdir = self.fs.isdir(p)
        metadata = self.default_metadata(key, isdir)
        if isdir:
            return self.finalize_metadata(metadata, key, is_dir=True)
        else:
            if self.fs.exists(self.path_for_key(key)):
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.readtext(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (c)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)

            else:
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.readtext(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (d)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
            return self.finalize_metadata(metadata, key, is_dir=False)

    def store(self, key, data, metadata):
        self.fs.makedirs(self.path_for_key(self.parent_key(key)))
        self.fs.writebytes(self.path_for_key(key), data)
        assert self.fs.exists(self.path_for_key(key))
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        parent = self.metadata_dir_path_for_key(key)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.fs.makedirs(parent)
        with self.fs.open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        if not self.contains(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        if self.is_dir(key):
            raise KeyNotFoundStoreException(
                message=f&#34;Can&#39;t remove a directory {key}; use removedir&#34;,
                key=key,
                store=self,
            )
        try:
            self.fs.remove(self.path_for_key(key))
        except:
            pass
        try:
            self.fs.remove(self.metadata_path_for_key(key))
        except:
            pass
        self.on_removed(key)

    def removedir(self, key):
        metadir = self.path_for_key(key) + &#34;/&#34; + self.METADATA
        try:
            self.fs.removedir(metadir)
        except:
            pass
        self.fs.removedir(self.path_for_key(key))
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return self.fs.exists(self.path_for_key(key))

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.fs.isdir(self.path_for_key(key))

    def keys(self, parent=None):
        if parent is not None and key_name(parent) == self.METADATA:
            raise Exception(f&#34;Invalid key {parent}&#34;)
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                k=k.replace(&#34;\\&#34;,&#34;/&#34;)
                if key_name(k) == self.METADATA:
                    continue
                key=join_key(parent, k)
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if self.is_dir(key):
            listdir = [d.replace(&#39;\\&#39;,&#39;/&#39;) for d in self.fs.listdir(self.path_for_key(key)) if d is not None]
            if any(&#34;/&#34; in d for d in listdir):
                print(f&#34;WARNING - listdir on {repr(self)} not working properly&#34;)

            return [
                key_name(d)
                for d in listdir
                if key_name(d) != self.METADATA
                and f&#34;/{self.METADATA}/&#34; not in d
            ]

    def makedir(self, key):
        self.fs.makedir(self.path_for_key(key), recreate=True)
        self.fs.makedir(self.path_for_key(key) + &#34;/&#34; + self.METADATA, recreate=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        return self.fs.openbin(self.path_for_key(key), mode=mode, buffering=buffering)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;Filesystem {self.fs} store at {self.path}&#34;

    def __repr__(self):
        return f&#34;FileSystemStore({repr(self.fs)}, {repr(self.path)})&#34;


class FSSpecStore(Store):
    &#34;&#34;&#34;A store that uses the [fsspec](https://filesystem-spec.readthedocs.io/en/latest/) as a backend.
    &#34;&#34;&#34;
    METADATA = &#34;__metadata__&#34;

    def __init__(self, fs, prefix:str=&#34;&#34;):
        &#34;&#34;&#34;Create a new FSSpecStore out of a fsspec filesystem.
        prefix needs to be provided to form a valid fsspec url when concatenating with the key (via a slash).        
        When key is &#34;&#34;, the prefix is returned as is.
        &#34;&#34;&#34;
        self.prefix = prefix
        self.fs = fs

    def path_for_key(self, key):
        &#34;&#34;&#34;Convert key to a fsspec url.&#34;&#34;&#34;
        if key in(&#34;&#34;,None):
            return self.prefix
        assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
        if key in (None, &#34;&#34;):
            return self.prefix
        p = self.prefix + &#34;/&#34; + key
        return str(p)

    def metadata_path_for_key(self, key):
        &#34;&#34;&#34;Convert key to a fsspec url pointing to the metadata of the key.&#34;&#34;&#34;
        return self.metadata_dir_path_for_key(key) + &#34;/&#34; + key_name(key) + &#34;.json&#34;

    def metadata_dir_path_for_key(self, key):
        if key in(&#34;&#34;,None):
            return self.prefix+&#34;/&#34;+self.METADATA
        assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
        p = self.path_for_key(parent_key(key))
        return p + &#34;/&#34; + self.METADATA

    def get_bytes(self, key):
        if not self.fs.exists(self.path_for_key(key)):
            raise KeyNotFoundStoreException(
                f&#34;Can&#39;t find {self.path_for_key(key)} in filesystem {self.fs}&#34;,
                key=key,
                store=self,
            )
        return self.fs.read_bytes(self.path_for_key(key))

    def get_metadata(self, key):
        p = self.path_for_key(key)
        isdir = self.fs.isdir(p)
        metadata = self.default_metadata(key, isdir)
        if isdir:
            return self.finalize_metadata(metadata, key, is_dir=True)
        else:
            if self.fs.exists(self.path_for_key(key)):
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.read_text(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (c)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)

            else:
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.read_text(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (d)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
            return self.finalize_metadata(metadata, key, is_dir=False)

    def store(self, key, data, metadata):
        self.fs.makedirs(self.path_for_key(self.parent_key(key)))
        self.fs.write_bytes(self.path_for_key(key), data)
        assert self.fs.exists(self.path_for_key(key))
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        parent = self.metadata_dir_path_for_key(key)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.fs.makedirs(parent)
        with self.fs.open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        if not self.contains(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        if self.is_dir(key):
            raise KeyNotFoundStoreException(
                message=f&#34;Can&#39;t remove a directory {key}; use removedir&#34;,
                key=key,
                store=self,
            )
        try:
            self.fs.rm(self.path_for_key(key))
        except:
            pass
        try:
            self.fs.rm(self.metadata_path_for_key(key))
        except:
            pass
        self.on_removed(key)

    def removedir(self, key):
        metadir = self.path_for_key(key) + &#34;/&#34; + self.METADATA
        try:
            self.fs.rmdir(metadir)
        except:
            pass
        self.fs.rmdir(self.path_for_key(key))
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return self.fs.exists(self.path_for_key(key))

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.fs.isdir(self.path_for_key(key))

    def keys(self, parent=None):
        if parent is not None and key_name(parent) == self.METADATA:
            raise ValueError(f&#34;Invalid key {parent}&#34;)
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                if key_name(k) == self.METADATA:
                    continue                
                key = join_key(parent, k)
                yield key
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if key is None:
            key = &#34;&#34;
        if self.is_dir(key):
            listdir = self.fs.listdir(self.path_for_key(key), detail=False)
            names=set()
            for d in listdir:
                print(&#34;  - &#34;,d)
                if d.startswith(&#34;/&#34;):
                    d = d[len(key)+1:]
                if d.startswith(&#34;/&#34;):
                    d = d[1:]
                if key_name(d) != self.METADATA and f&#34;/{self.METADATA}/&#34; not in d and len(d) &gt; 0:
                    print(&#34;    name: &#34;,d.split(&#34;/&#34;)[0])
                    names.add(d.split(&#34;/&#34;)[0])
            return sorted(list(names))

    def makedir(self, key):
        self.fs.mkdir(self.path_for_key(key), recreate=True)
        self.fs.mkdir(self.path_for_key(key) + &#34;/&#34; + self.METADATA, recreate=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        return self.fs.open(self.path_for_key(key), mode=mode, buffering=buffering)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;fsspec {self.fs} store at {self.prefix}&#34;

    def __repr__(self):
        return f&#34;FSSpecStore({repr(self.fs)}, {repr(self.prefix)})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="liquer.store.get_store"><code class="name flex">
<span>def <span class="ident">get_store</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get global Store
If no store is specified, a default store is created as a MountPointStore with indexer.
Note that This will run the global indexer whenever the data is written into the store.
See the StoreMixin.with_indexer method and the liquer.indexer module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_store():
    &#34;&#34;&#34;Get global Store
    If no store is specified, a default store is created as a MountPointStore with indexer.
    Note that This will run the global indexer whenever the data is written into the store.
    See the StoreMixin.with_indexer method and the liquer.indexer module.
    &#34;&#34;&#34;
    global STORE
    if STORE is None:
        STORE = MountPointStore().with_indexer()
    return STORE</code></pre>
</details>
</dd>
<dt id="liquer.store.get_web_store"><code class="name flex">
<span>def <span class="ident">get_web_store</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Web store is the store for the /web folder.
The purpose of this folder is to be able to efficiently serve web content.</p>
<p>The web store is special in several ways:
- It must be a mount point store, since the LiQuer plugins (e.g. the liquer_gui)
mount sub folders with web applications into it.
- The content of the store is accessible through liquer/web (as well as via liquer/api/store/data).
- If the key points to a directory when accessed over liquer/web, the key/index.html is served.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_web_store():
    &#34;&#34;&#34;Web store is the store for the /web folder.
    The purpose of this folder is to be able to efficiently serve web content.

    The web store is special in several ways:
    - It must be a mount point store, since the LiQuer plugins (e.g. the liquer_gui)
      mount sub folders with web applications into it.
    - The content of the store is accessible through liquer/web (as well as via liquer/api/store/data).
    - If the key points to a directory when accessed over liquer/web, the key/index.html is served.
    &#34;&#34;&#34;
    global WEB_STORE
    if WEB_STORE is None:
        WEB_STORE = MountPointStore()
        get_store().mount(&#34;web&#34;, WEB_STORE)
    return WEB_STORE</code></pre>
</details>
</dd>
<dt id="liquer.store.join_key"><code class="name flex">
<span>def <span class="ident">join_key</span></span>(<span>key, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Join key and name into a new key. If key is None or empty, name is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_key(key, name):
    &#34;&#34;&#34;Join key and name into a new key. If key is None or empty, name is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return name
    else:
        if key.endswith(&#34;/&#34;):
            return f&#34;{key}{name}&#34;
        else:
            return f&#34;{key}/{name}&#34;</code></pre>
</details>
</dd>
<dt id="liquer.store.key_extension"><code class="name flex">
<span>def <span class="ident">key_extension</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get fileextension of the key. If key is None or empty, None is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_extension(key):
    &#34;&#34;&#34;Get fileextension of the key. If key is None or empty, None is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return None
    v = key_name(key).split(&#34;.&#34;)
    if len(v) &gt;= 2:
        return v[-1]
    return None</code></pre>
</details>
</dd>
<dt id="liquer.store.key_name"><code class="name flex">
<span>def <span class="ident">key_name</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get name of the key - i.e. last component after slash.
If key is None or empty, empty string is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_name(key):
    &#34;&#34;&#34;Get name of the key - i.e. last component after slash.
    If key is None or empty, empty string is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return &#34;&#34;
    return str(key.split(&#34;/&#34;)[-1])</code></pre>
</details>
</dd>
<dt id="liquer.store.key_name_without_extension"><code class="name flex">
<span>def <span class="ident">key_name_without_extension</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get name without the fileextension of the key. If key is None or empty, None is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_name_without_extension(key):
    &#34;&#34;&#34;Get name without the fileextension of the key. If key is None or empty, None is returned.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return None
    v = key_name(key).split(&#34;.&#34;)
    if len(v) &gt;= 2:
        return v[0]
    return None</code></pre>
</details>
</dd>
<dt id="liquer.store.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>key, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mount a sub-store into the global store under the key.
If store argument is a string or Path, it is interpreted as a path and converted to a FileStore</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(key, store=None):
    &#34;&#34;&#34;Mount a sub-store into the global store under the key.
    If store argument is a string or Path, it is interpreted as a path and converted to a FileStore
    &#34;&#34;&#34;
    if store is None:
        store = key
    if type(store) is str:
        store = FileStore(store)
    get_store().mount(key, store)</code></pre>
</details>
</dd>
<dt id="liquer.store.mount_folder"><code class="name flex">
<span>def <span class="ident">mount_folder</span></span>(<span>key, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount_folder(key, path):
    get_store().mount(key, FileStore(path))</code></pre>
</details>
</dd>
<dt id="liquer.store.parent_key"><code class="name flex">
<span>def <span class="ident">parent_key</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent of the key (i.e. key without the last component)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parent_key(key):
    &#34;&#34;&#34;Parent of the key (i.e. key without the last component)&#34;&#34;&#34;
    if key == &#34;&#34;:
        return None
    return &#34;/&#34;.join(key.split(&#34;/&#34;)[:-1])</code></pre>
</details>
</dd>
<dt id="liquer.store.set_store"><code class="name flex">
<span>def <span class="ident">set_store</span></span>(<span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Set global Store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_store(store):
    &#34;Set global Store&#34;
    global STORE
    STORE = store</code></pre>
</details>
</dd>
<dt id="liquer.store.web_mount"><code class="name flex">
<span>def <span class="ident">web_mount</span></span>(<span>key, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Like mount, but mounts into the web store. (see get_web_store)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def web_mount(key, store=None):
    &#34;&#34;&#34;Like mount, but mounts into the web store. (see get_web_store)&#34;&#34;&#34;
    if store is None:
        store = key
    if type(store) is str:
        store = FileStore(store)
    get_web_store().mount(key, store)</code></pre>
</details>
</dd>
<dt id="liquer.store.web_mount_folder"><code class="name flex">
<span>def <span class="ident">web_mount_folder</span></span>(<span>key, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def web_mount_folder(key, path):
    web_mount(key, FileStore(path))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="liquer.store.FSSpecStore"><code class="flex name class">
<span>class <span class="ident">FSSpecStore</span></span>
<span>(</span><span>fs, prefix:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>A store that uses the <a href="https://filesystem-spec.readthedocs.io/en/latest/">fsspec</a> as a backend.</p>
<p>Create a new FSSpecStore out of a fsspec filesystem.
prefix needs to be provided to form a valid fsspec url when concatenating with the key (via a slash).
<br>
When key is "", the prefix is returned as is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FSSpecStore(Store):
    &#34;&#34;&#34;A store that uses the [fsspec](https://filesystem-spec.readthedocs.io/en/latest/) as a backend.
    &#34;&#34;&#34;
    METADATA = &#34;__metadata__&#34;

    def __init__(self, fs, prefix:str=&#34;&#34;):
        &#34;&#34;&#34;Create a new FSSpecStore out of a fsspec filesystem.
        prefix needs to be provided to form a valid fsspec url when concatenating with the key (via a slash).        
        When key is &#34;&#34;, the prefix is returned as is.
        &#34;&#34;&#34;
        self.prefix = prefix
        self.fs = fs

    def path_for_key(self, key):
        &#34;&#34;&#34;Convert key to a fsspec url.&#34;&#34;&#34;
        if key in(&#34;&#34;,None):
            return self.prefix
        assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
        if key in (None, &#34;&#34;):
            return self.prefix
        p = self.prefix + &#34;/&#34; + key
        return str(p)

    def metadata_path_for_key(self, key):
        &#34;&#34;&#34;Convert key to a fsspec url pointing to the metadata of the key.&#34;&#34;&#34;
        return self.metadata_dir_path_for_key(key) + &#34;/&#34; + key_name(key) + &#34;.json&#34;

    def metadata_dir_path_for_key(self, key):
        if key in(&#34;&#34;,None):
            return self.prefix+&#34;/&#34;+self.METADATA
        assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
        p = self.path_for_key(parent_key(key))
        return p + &#34;/&#34; + self.METADATA

    def get_bytes(self, key):
        if not self.fs.exists(self.path_for_key(key)):
            raise KeyNotFoundStoreException(
                f&#34;Can&#39;t find {self.path_for_key(key)} in filesystem {self.fs}&#34;,
                key=key,
                store=self,
            )
        return self.fs.read_bytes(self.path_for_key(key))

    def get_metadata(self, key):
        p = self.path_for_key(key)
        isdir = self.fs.isdir(p)
        metadata = self.default_metadata(key, isdir)
        if isdir:
            return self.finalize_metadata(metadata, key, is_dir=True)
        else:
            if self.fs.exists(self.path_for_key(key)):
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.read_text(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (c)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)

            else:
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.read_text(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (d)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
            return self.finalize_metadata(metadata, key, is_dir=False)

    def store(self, key, data, metadata):
        self.fs.makedirs(self.path_for_key(self.parent_key(key)))
        self.fs.write_bytes(self.path_for_key(key), data)
        assert self.fs.exists(self.path_for_key(key))
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        parent = self.metadata_dir_path_for_key(key)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.fs.makedirs(parent)
        with self.fs.open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        if not self.contains(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        if self.is_dir(key):
            raise KeyNotFoundStoreException(
                message=f&#34;Can&#39;t remove a directory {key}; use removedir&#34;,
                key=key,
                store=self,
            )
        try:
            self.fs.rm(self.path_for_key(key))
        except:
            pass
        try:
            self.fs.rm(self.metadata_path_for_key(key))
        except:
            pass
        self.on_removed(key)

    def removedir(self, key):
        metadir = self.path_for_key(key) + &#34;/&#34; + self.METADATA
        try:
            self.fs.rmdir(metadir)
        except:
            pass
        self.fs.rmdir(self.path_for_key(key))
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return self.fs.exists(self.path_for_key(key))

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.fs.isdir(self.path_for_key(key))

    def keys(self, parent=None):
        if parent is not None and key_name(parent) == self.METADATA:
            raise ValueError(f&#34;Invalid key {parent}&#34;)
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                if key_name(k) == self.METADATA:
                    continue                
                key = join_key(parent, k)
                yield key
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if key is None:
            key = &#34;&#34;
        if self.is_dir(key):
            listdir = self.fs.listdir(self.path_for_key(key), detail=False)
            names=set()
            for d in listdir:
                print(&#34;  - &#34;,d)
                if d.startswith(&#34;/&#34;):
                    d = d[len(key)+1:]
                if d.startswith(&#34;/&#34;):
                    d = d[1:]
                if key_name(d) != self.METADATA and f&#34;/{self.METADATA}/&#34; not in d and len(d) &gt; 0:
                    print(&#34;    name: &#34;,d.split(&#34;/&#34;)[0])
                    names.add(d.split(&#34;/&#34;)[0])
            return sorted(list(names))

    def makedir(self, key):
        self.fs.mkdir(self.path_for_key(key), recreate=True)
        self.fs.mkdir(self.path_for_key(key) + &#34;/&#34; + self.METADATA, recreate=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        return self.fs.open(self.path_for_key(key), mode=mode, buffering=buffering)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;fsspec {self.fs} store at {self.prefix}&#34;

    def __repr__(self):
        return f&#34;FSSpecStore({repr(self.fs)}, {repr(self.prefix)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.store.FSSpecStore.METADATA"><code class="name">var <span class="ident">METADATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.FSSpecStore.metadata_dir_path_for_key"><code class="name flex">
<span>def <span class="ident">metadata_dir_path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_dir_path_for_key(self, key):
    if key in(&#34;&#34;,None):
        return self.prefix+&#34;/&#34;+self.METADATA
    assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
    p = self.path_for_key(parent_key(key))
    return p + &#34;/&#34; + self.METADATA</code></pre>
</details>
</dd>
<dt id="liquer.store.FSSpecStore.metadata_path_for_key"><code class="name flex">
<span>def <span class="ident">metadata_path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert key to a fsspec url pointing to the metadata of the key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_path_for_key(self, key):
    &#34;&#34;&#34;Convert key to a fsspec url pointing to the metadata of the key.&#34;&#34;&#34;
    return self.metadata_dir_path_for_key(key) + &#34;/&#34; + key_name(key) + &#34;.json&#34;</code></pre>
</details>
</dd>
<dt id="liquer.store.FSSpecStore.path_for_key"><code class="name flex">
<span>def <span class="ident">path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert key to a fsspec url.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_for_key(self, key):
    &#34;&#34;&#34;Convert key to a fsspec url.&#34;&#34;&#34;
    if key in(&#34;&#34;,None):
        return self.prefix
    assert key_name(key) != self.METADATA and (&#34;/&#34; + self.METADATA + &#34;/&#34;) not in key
    if key in (None, &#34;&#34;):
        return self.prefix
    p = self.prefix + &#34;/&#34; + key
    return str(p)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.FileStore"><code class="flex name class">
<span>class <span class="ident">FileStore</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileStore(Store):
    METADATA = &#34;__metadata__&#34;

    def __init__(self, path):
        if isinstance(path, Path):
            self.path = path
        else:
            self.path = Path(path)

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        metadata = super().finalize_metadata(
            metadata, key=key, is_dir=is_dir, data=data, update=update
        )
        metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = str(self.path_for_key(key).resolve())
        return Metadata(metadata).as_dict()

    def path_for_key(self, key):
        if key in (None, &#34;&#34;):
            return self.path
        p = self.path / key
        assert p.name != self.METADATA
        return p

    def metadata_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return p.parent / self.METADATA / (p.name + &#34;.json&#34;)

    def get_bytes(self, key):
        if not self.path_for_key(key).exists():
            raise KeyNotFoundStoreException(key=key, store=self)
        with open(self.path_for_key(key), &#34;rb&#34;) as f:
            b = f.read()
        return b

    def get_metadata(self, key):
        p = self.path_for_key(key)
        metadata = self.default_metadata(key, p.is_dir())

        if p.is_dir():
            return self.finalize_metadata(metadata, key=key, is_dir=True)
        else:
            if self.path_for_key(key).exists():
                if self.metadata_path_for_key(key).exists():
                    with open(self.metadata_path_for_key(key)) as f:
                        try:
                            metadata.update(json.loads(f.read()))
                        except:
                            traceback.print_exc()
                            print(f&#34;Removing {key} due to corrupted metadata (a)&#34;)
                            self.remove(key)
                            raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    m = Metadata()
                    m.status = Status.EXTERNAL
                    return self.finalize_metadata(m.as_dict(), key=key)

            else:
                if self.metadata_path_for_key(key).exists():
                    with open(self.metadata_path_for_key(key)) as f:
                        try:
                            metadata.update(json.loads(f.read()))
                        except:
                            traceback.print_exc()
                            print(f&#34;Removing {key} due to corrupted metadata (b)&#34;)
                            self.remove(key)
                            raise KeyNotFoundStoreException(key=key, store=self)

                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
        return self.finalize_metadata(metadata, key=key, is_dir=False)

    def store(self, key, data, metadata):
        self.path_for_key(key).parent.mkdir(parents=True, exist_ok=True)
        self.path_for_key(key).write_bytes(data)
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.metadata_path_for_key(key).parent.mkdir(parents=True, exist_ok=True)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        with open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        try:
            self.path_for_key(key).unlink()
        except FileNotFoundError:
            pass
        try:
            self.metadata_path_for_key(key).unlink()
        except FileNotFoundError:
            pass

        self.on_removed(key)

    def removedir(self, key):
        (self.path_for_key(key) / self.METADATA).rmdir()
        self.path_for_key(key).rmdir()
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.path_for_key(key).exists()

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.path_for_key(key).is_dir()

    def keys(self, parent=None):
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                key = k if parent is None else parent + &#34;/&#34; + k
                yield key
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if self.is_dir(key):
            return [
                d.name
                for d in self.path_for_key(key).iterdir()
                if d.name != self.METADATA
            ]

    def makedir(self, key):
        self.path_for_key(key).mkdir(parents=True, exist_ok=True)
        (self.path_for_key(key) / self.METADATA).mkdir(parents=True, exist_ok=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        return open(self.path_for_key(key), mode)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;File store at {self.path}&#34;

    def __repr__(self):
        return f&#34;FileStore(&#39;{self.path}&#39;)&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.store.FileStore.METADATA"><code class="name">var <span class="ident">METADATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.FileStore.finalize_metadata"><code class="name flex">
<span>def <span class="ident">finalize_metadata</span></span>(<span>self, metadata, key, is_dir=False, data=None, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
    metadata = super().finalize_metadata(
        metadata, key=key, is_dir=is_dir, data=data, update=update
    )
    metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = str(self.path_for_key(key).resolve())
    return Metadata(metadata).as_dict()</code></pre>
</details>
</dd>
<dt id="liquer.store.FileStore.metadata_path_for_key"><code class="name flex">
<span>def <span class="ident">metadata_path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_path_for_key(self, key):
    p = self.path / key
    assert p.name != self.METADATA
    return p.parent / self.METADATA / (p.name + &#34;.json&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.store.FileStore.path_for_key"><code class="name flex">
<span>def <span class="ident">path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_for_key(self, key):
    if key in (None, &#34;&#34;):
        return self.path
    p = self.path / key
    assert p.name != self.METADATA
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.FileSystemStore"><code class="flex name class">
<span>class <span class="ident">FileSystemStore</span></span>
<span>(</span><span>fs, path='')</span>
</code></dt>
<dd>
<div class="desc"><p>A store that uses the <a href="https://docs.pyfilesystem.org/en/latest/">PyFilesystem2</a> as a backend.</p>
<p>Though it seems to be working fine in Linux, some issues were found in Windows.
This seems to not work reliable due to different implementations of PyFilesystem2.
Notably, listdir() sometimes returns list of recurently items in the subdirectories.</p>
<p>Consider using FSSpecStore based on <a href="https://filesystem-spec.readthedocs.io/en/latest/">fsspec</a>,
which should have a better support.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileSystemStore(Store):
    &#34;&#34;&#34;A store that uses the [PyFilesystem2](https://docs.pyfilesystem.org/en/latest/) as a backend.

    Though it seems to be working fine in Linux, some issues were found in Windows.
    This seems to not work reliable due to different implementations of PyFilesystem2.
    Notably, listdir() sometimes returns list of recurently items in the subdirectories.
    
    Consider using FSSpecStore based on [fsspec](https://filesystem-spec.readthedocs.io/en/latest/),
    which should have a better support.
    &#34;&#34;&#34;
    METADATA = &#34;__metadata__&#34;

    def __init__(self, fs, path=&#34;&#34;):
        if isinstance(path, Path):
            self.path = path
        else:
            self.path = Path(path)
        self.fs = fs

    def path_for_key(self, key):
        if key in (None, &#34;&#34;):
            return str(self.path)
        p = self.path / key
        assert p.name != self.METADATA
        return str(p)

    def metadata_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return str(p.parent / self.METADATA / (p.name + &#34;.json&#34;))

    def metadata_dir_path_for_key(self, key):
        p = self.path / key
        assert p.name != self.METADATA
        return str(p.parent / self.METADATA)

    def get_bytes(self, key):
        if not self.fs.exists(self.path_for_key(key)):
            raise KeyNotFoundStoreException(
                f&#34;Can&#39;t find {self.path_for_key(key)} in filesystem {self.fs}&#34;,
                key=key,
                store=self,
            )
        return self.fs.readbytes(self.path_for_key(key))

    def get_metadata(self, key):
        p = self.path_for_key(key)
        isdir = self.fs.isdir(p)
        metadata = self.default_metadata(key, isdir)
        if isdir:
            return self.finalize_metadata(metadata, key, is_dir=True)
        else:
            if self.fs.exists(self.path_for_key(key)):
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.readtext(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (c)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)

            else:
                if self.fs.exists(self.metadata_path_for_key(key)):
                    try:
                        metadata.update(
                            json.loads(
                                self.fs.readtext(self.metadata_path_for_key(key))
                            )
                        )
                    except:
                        traceback.print_exc()
                        print(f&#34;Removing {key} due to corrupted metadata (d)&#34;)
                        self.remove(key)
                        raise KeyNotFoundStoreException(key=key, store=self)
                else:
                    raise KeyNotFoundStoreException(key=key, store=self)
            return self.finalize_metadata(metadata, key, is_dir=False)

    def store(self, key, data, metadata):
        self.fs.makedirs(self.path_for_key(self.parent_key(key)))
        self.fs.writebytes(self.path_for_key(key), data)
        assert self.fs.exists(self.path_for_key(key))
        self.store_metadata(
            key, self.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        parent = self.metadata_dir_path_for_key(key)
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.fs.makedirs(parent)
        with self.fs.open(self.metadata_path_for_key(key), &#34;w&#34;) as f:
            json.dump(metadata, f)
        self.on_metadata_changed(key)

    def remove(self, key):
        if not self.contains(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        if self.is_dir(key):
            raise KeyNotFoundStoreException(
                message=f&#34;Can&#39;t remove a directory {key}; use removedir&#34;,
                key=key,
                store=self,
            )
        try:
            self.fs.remove(self.path_for_key(key))
        except:
            pass
        try:
            self.fs.remove(self.metadata_path_for_key(key))
        except:
            pass
        self.on_removed(key)

    def removedir(self, key):
        metadir = self.path_for_key(key) + &#34;/&#34; + self.METADATA
        try:
            self.fs.removedir(metadir)
        except:
            pass
        self.fs.removedir(self.path_for_key(key))
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return self.fs.exists(self.path_for_key(key))

    def is_dir(self, key):
        if key in (&#34;&#34;, None):
            return True
        return self.fs.isdir(self.path_for_key(key))

    def keys(self, parent=None):
        if parent is not None and key_name(parent) == self.METADATA:
            raise Exception(f&#34;Invalid key {parent}&#34;)
        d = self.listdir(parent)
        if d is None:
            return []
        else:
            for k in d:
                k=k.replace(&#34;\\&#34;,&#34;/&#34;)
                if key_name(k) == self.METADATA:
                    continue
                key=join_key(parent, k)
                for kk in self.keys(key):
                    yield kk

    def listdir(self, key):
        if self.is_dir(key):
            listdir = [d.replace(&#39;\\&#39;,&#39;/&#39;) for d in self.fs.listdir(self.path_for_key(key)) if d is not None]
            if any(&#34;/&#34; in d for d in listdir):
                print(f&#34;WARNING - listdir on {repr(self)} not working properly&#34;)

            return [
                key_name(d)
                for d in listdir
                if key_name(d) != self.METADATA
                and f&#34;/{self.METADATA}/&#34; not in d
            ]

    def makedir(self, key):
        self.fs.makedir(self.path_for_key(key), recreate=True)
        self.fs.makedir(self.path_for_key(key) + &#34;/&#34; + self.METADATA, recreate=True)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;rb&#34;, buffering=-1):
        return self.fs.openbin(self.path_for_key(key), mode=mode, buffering=buffering)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;Filesystem {self.fs} store at {self.path}&#34;

    def __repr__(self):
        return f&#34;FileSystemStore({repr(self.fs)}, {repr(self.path)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.store.FileSystemStore.METADATA"><code class="name">var <span class="ident">METADATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.FileSystemStore.metadata_dir_path_for_key"><code class="name flex">
<span>def <span class="ident">metadata_dir_path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_dir_path_for_key(self, key):
    p = self.path / key
    assert p.name != self.METADATA
    return str(p.parent / self.METADATA)</code></pre>
</details>
</dd>
<dt id="liquer.store.FileSystemStore.metadata_path_for_key"><code class="name flex">
<span>def <span class="ident">metadata_path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_path_for_key(self, key):
    p = self.path / key
    assert p.name != self.METADATA
    return str(p.parent / self.METADATA / (p.name + &#34;.json&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.store.FileSystemStore.path_for_key"><code class="name flex">
<span>def <span class="ident">path_for_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_for_key(self, key):
    if key in (None, &#34;&#34;):
        return str(self.path)
    p = self.path / key
    assert p.name != self.METADATA
    return str(p)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.IndexerStore"><code class="flex name class">
<span>class <span class="ident">IndexerStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Indexer proxy to another store - this will call indexer on storing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndexerStore(ProxyStore):
    &#34;&#34;&#34;Indexer proxy to another store - this will call indexer on storing.&#34;&#34;&#34;

    def store(self, key, data, metadata):
        from liquer.indexer import index

        metadata = self._store.finalize_metadata(metadata, key=key, is_dir=False, data=data)
        metadata = index(key=self.to_root_key(key), query=metadata.get(&#34;query&#34;), data=data, metadata=metadata)
        self._store.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def mount(self, key, store):
        &#34;&#34;&#34;Mount a store in a mount-point&#34;&#34;&#34;
        r = self._store.mount(key, store)
        self.sync()
        return r

    def __str__(self):
        return f&#34;Indexing {self._store}&#34;

    def __repr__(self):
        return f&#34;IndexerStore({repr(self._store)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></li>
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.ProxyStore.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.ProxyStore.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.ProxyStore.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.ProxyStore.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.ProxyStore.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.ProxyStore.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.ProxyStore.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.ProxyStore.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.ProxyStore.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.ProxyStore.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.ProxyStore.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.ProxyStore.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.ProxyStore.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.ProxyStore.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.KeyNotFoundStoreException"><code class="flex name class">
<span>class <span class="ident">KeyNotFoundStoreException</span></span>
<span>(</span><span>message='Key not found in store', key=None, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General superclass for exceptions associated with a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyNotFoundStoreException(StoreException):
    def __init__(self, message=&#34;Key not found in store&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.StoreException" href="#liquer.store.StoreException">StoreException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="liquer.store.KeyNotSupportedStoreException"><code class="flex name class">
<span>class <span class="ident">KeyNotSupportedStoreException</span></span>
<span>(</span><span>message='Key not supported in store', key=None, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General superclass for exceptions associated with a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyNotSupportedStoreException(StoreException):
    def __init__(self, message=&#34;Key not supported in store&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.StoreException" href="#liquer.store.StoreException">StoreException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="liquer.store.KeyRouteNotFoundStoreException"><code class="flex name class">
<span>class <span class="ident">KeyRouteNotFoundStoreException</span></span>
<span>(</span><span>message='Key route not found', key=None, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General superclass for exceptions associated with a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyRouteNotFoundStoreException(StoreException):
    def __init__(self, message=&#34;Key route not found&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.StoreException" href="#liquer.store.StoreException">StoreException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="liquer.store.KeyTranslatingStore"><code class="flex name class">
<span>class <span class="ident">KeyTranslatingStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyTranslatingStore(Store):
    def __init__(self, store):
        self.substore = store
        self.substore.parent_store = self

    def sync(self):
        self.substore.sync()

    def translate_key(self, key, inverse=False):
        return key

    def to_root_key(self, key):
        &#34;&#34;&#34;Convert local store key to a key in a root store.
        This is can be used e.g. to convert a key valid in a mounted (child) store to
        a key of a root store.
        &#34;&#34;&#34;
        key = self.translate_key(key, inverse=True)
        if self.parent_store is None:
            return key
        return self.parent_store.to_root_key(key)

    def is_supported(self, key):
        try:
            tkey = self.translate_key(key)
            if tkey is None:
                return False
            return self.substore.is_supported(tkey)
        except KeyNotSupportedStoreException:
            return False

    def get_bytes(self, key):
        return self.substore.get_bytes(self.translate_key(key))

    def get_metadata(self, key):
        tkey = self.translate_key(key)
        metadata = self.substore.get_metadata(tkey)
        metadata[&#34;key&#34;] = key
        if &#34;recipes_key&#34; in metadata:
            metadata[&#34;recipes_key&#34;] = self.translate_key(
                metadata[&#34;recipes_key&#34;], inverse=True
            )
        return metadata

    def store(self, key, data, metadata):
        self.substore.store(self.translate_key(key), data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.substore.store_metadata(self.translate_key(key), metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(self.translate_key(key))
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(self.translate_key(key))
        self.on_removed(key)

    def contains(self, key):
        return self.substore.contains(self.translate_key(key))

    def is_dir(self, key):
        return self.substore.is_dir(self.translate_key(key))

    def keys(self):
        for key in self.substore.keys():
            yield self.translate_key(key, inverse=True)

    def listdir(self, key):
        return self.substore.listdir(self.translate_key(key))

    def makedir(self, key):
        self.substore.makedir(self.translate_key(key))
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self.substore.openbin(
            self.translate_key(key), mode=mode, buffering=buffering
        )

    def __str__(self):
        return f&#34;Key translating store on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;KeyTranslatingStore({repr(self.substore)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.store.PrefixStore" href="#liquer.store.PrefixStore">PrefixStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.KeyTranslatingStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self.substore.sync()</code></pre>
</details>
</dd>
<dt id="liquer.store.KeyTranslatingStore.to_root_key"><code class="name flex">
<span>def <span class="ident">to_root_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert local store key to a key in a root store.
This is can be used e.g. to convert a key valid in a mounted (child) store to
a key of a root store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_root_key(self, key):
    &#34;&#34;&#34;Convert local store key to a key in a root store.
    This is can be used e.g. to convert a key valid in a mounted (child) store to
    a key of a root store.
    &#34;&#34;&#34;
    key = self.translate_key(key, inverse=True)
    if self.parent_store is None:
        return key
    return self.parent_store.to_root_key(key)</code></pre>
</details>
</dd>
<dt id="liquer.store.KeyTranslatingStore.translate_key"><code class="name flex">
<span>def <span class="ident">translate_key</span></span>(<span>self, key, inverse=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate_key(self, key, inverse=False):
    return key</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.MemoryStore"><code class="flex name class">
<span>class <span class="ident">MemoryStore</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryStore(Store):
    def __init__(self):
        self.directories = set()
        self.data = {}
        self.metadata = {}

    def get_bytes(self, key):
        if key not in self.data:
            raise KeyNotFoundStoreException(key=key, store=self)
        return self.data[key]

    def get_metadata(self, key):
        if key in self.metadata:
            metadata = self.metadata[key]
        else:
            if not self.is_dir(key):
                raise KeyNotFoundStoreException(key=key, store=self)

            metadata = self.default_metadata(key, is_dir=True)

        return self.finalize_metadata(metadata, key=key, is_dir=self.is_dir(key))

    def store(self, key, data, metadata):
        self.makedir(self.parent_key(key))
        self.data[key] = data
        self.metadata[key] = self.finalize_metadata(
            metadata, key=key, is_dir=False, data=data
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        metadata = self.finalize_metadata(
            metadata, key=key, is_dir=self.is_dir(key), update=True
        )
        self.metadata[key] = metadata
        self.on_metadata_changed(key)

    def remove(self, key):
        try:
            self.directories.remove(key)
        except KeyError:
            pass
        try:
            del self.data[key]
        except KeyError:
            pass
        try:
            del self.metadata[key]
        except KeyError:
            pass
        self.on_removed(key)

    def removedir(self, key):
        if len(self.listdir(key)) == 0:
            try:
                self.directories.remove(key)
            except KeyError:
                pass
        self.on_removed(key)

    def contains(self, key):
        if key in (&#34;&#34;, None):
            return True

        return key in self.directories or key in self.data or key in self.metadata

    def is_dir(self, key):
        if key in (None, &#34;&#34;):
            return True
        return key in self.directories

    def keys(self):
        k = set()
        k.update(self.directories)
        k.update(self.data.keys())
        k.update(self.metadata.keys())
        return sorted(k)

    def listdir(self, key):
        if key in (&#34;&#34;, None):
            return sorted(
                set(k.split(&#34;/&#34;)[0] for k in self.keys() if k.split(&#34;/&#34;)[0] != &#34;&#34;)
            )
        if self.is_dir(key):
            return [key_name(k) for k in self.keys() if self.parent_key(k) == key]

    def makedir(self, key):
        while key not in (None, &#34;&#34;):
            self.directories.add(key)
            key = self.parent_key(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        if mode == &#34;rb&#34;:
            return BytesIO(self.data[key])
        raise Exception(&#34;openbin not supported for write yet&#34;)

    def is_supported(self, key):
        return True

    def __str__(self):
        return f&#34;Memory store&#34;

    def __repr__(self):
        return f&#34;MemoryStore()&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.MountPointStore"><code class="flex name class">
<span>class <span class="ident">MountPointStore</span></span>
<span>(</span><span>default_store=None, routing_table=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MountPointStore(RoutingStore):
    def __init__(self, default_store=None, routing_table=None):
        self.default_store = default_store
        if default_store is not None:
            self.default_store.parent_store = self
        self.routing_table = [] if routing_table is None else routing_table

    def sync(self):
        for key, store in self.routing_table:
            store.sync()
        if self.default_store is not None:
            self.default_store.sync()

    def umount(self, umount_key):
        for key, store in self.routing_table:
            if key == umount_key:
                store.parent_store = None
        self.routing_table = [
            (key, store) for key, store in self.routing_table if key != umount_key
        ]
        return self

    def mount(self, key, store):
        self.umount(key)
        prefix_store = PrefixStore(store, prefix=key)
        prefix_store.parent_store = self
        self.routing_table.append((key, prefix_store))
        self.sync()
        return self

    def route_to(self, key):
        for prefix, store in reversed(self.routing_table):
            if key == prefix:
                return store
            if not prefix.endswith(&#34;/&#34;):
                prefix += &#34;/&#34;
            if key.startswith(prefix):
                if store.is_supported(key):
                    return store
        if self.default_store is not None:
            return self.default_store
        raise KeyRouteNotFoundStoreException(key=key, store=self)

    def get_metadata(self, key):
        try:
            metadata = self.route_to(key).get_metadata(key)
            metadata[&#34;key&#34;] = key

            return metadata
        except KeyRouteNotFoundStoreException:
            if self.is_dir(key):
                return self.finalize_metadata({}, key, is_dir=True)
        raise KeyNotFoundStoreException(key=key, store=self)

    def is_dir(self, key):
        if key == &#34;&#34;:
            return True
        try:
            return self.route_to(key).is_dir(key)
        except KeyRouteNotFoundStoreException:
            for route, _ in reversed(self.routing_table):
                if route == key or route.startswith(key + &#34;/&#34;):
                    return self.finalize_metadata({}, key, is_dir=True)
        return False

    def keys(self):
        prefixes = []
        for prefix, store in reversed(self.routing_table):
            yield prefix
            if not prefix.endswith(&#34;/&#34;):
                prefix += &#34;/&#34;
            for key in store.keys():
                if any(key.startswith(p) for p in prefixes):
                    continue
                if key.startswith(prefix):
                    yield key
            prefixes.append(prefix)
        if self.default_store is not None:
            for key in self.default_store.keys():
                if any(key.startswith(p) for p in prefixes):
                    continue
                yield key

    def listdir(self, key):
        try:
            store = self.route_to(key)
        except KeyRouteNotFoundStoreException:
            store = None

        if store is None:
            d = set()
        else:
            d = set(store.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for prefix, _ in self.routing_table:
            if prefix.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = prefix.split(&#34;/&#34;)
                d.add(v[key_depth])
        if self.default_store is not None:
            for prefix in self.default_store.keys():
                if prefix.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                    v = prefix.split(&#34;/&#34;)
                    d.add(v[key_depth])

        return sorted(d)

    def removedir(self, key):
        for k, store in self.routing_table:
            if k == key:
                raise StoreException(
                    f&#34;Can&#39;t remove {key} because it is a mount point of {repr(store)}&#34;,
                    key=key,
                    store=self,
                )

        return self.route_to(key).removedir(key)

    def __str__(self):
        return f&#34;Mount point store routed by {self.routing_table} with default store {self.default_store}&#34;

    def __repr__(self):
        return f&#34;MountPointStore({repr(self.default_store)}, routing_table={repr(self.routing_table)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.RoutingStore" href="#liquer.store.RoutingStore">RoutingStore</a></li>
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.MountPointStore.route_to"><code class="name flex">
<span>def <span class="ident">route_to</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route_to(self, key):
    for prefix, store in reversed(self.routing_table):
        if key == prefix:
            return store
        if not prefix.endswith(&#34;/&#34;):
            prefix += &#34;/&#34;
        if key.startswith(prefix):
            if store.is_supported(key):
                return store
    if self.default_store is not None:
        return self.default_store
    raise KeyRouteNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.MountPointStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    for key, store in self.routing_table:
        store.sync()
    if self.default_store is not None:
        self.default_store.sync()</code></pre>
</details>
</dd>
<dt id="liquer.store.MountPointStore.umount"><code class="name flex">
<span>def <span class="ident">umount</span></span>(<span>self, umount_key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def umount(self, umount_key):
    for key, store in self.routing_table:
        if key == umount_key:
            store.parent_store = None
    self.routing_table = [
        (key, store) for key, store in self.routing_table if key != umount_key
    ]
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.RoutingStore" href="#liquer.store.RoutingStore">RoutingStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.RoutingStore.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.RoutingStore.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.RoutingStore.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.RoutingStore.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.RoutingStore.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.RoutingStore.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.RoutingStore.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.RoutingStore.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.RoutingStore.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.RoutingStore.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.RoutingStore.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.RoutingStore.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.RoutingStore.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.RoutingStore.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.RoutingStore.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.RoutingStore.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.RoutingStore.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.RoutingStore.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.RoutingStore.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.RoutingStore.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.RoutingStore.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.RoutingStore.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.RoutingStore.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.RoutingStore.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.RoutingStore.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.RoutingStore.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.RoutingStore.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.OverlayStore"><code class="flex name class">
<span>class <span class="ident">OverlayStore</span></span>
<span>(</span><span>overlay, fallback)</span>
</code></dt>
<dd>
<div class="desc"><p>Overlay store combines two stores: overlay and fallback.
Overlay is used as a primary store for reading and writing.
The fallback is used only for reading if key is not found in the overlay store (and is not removed).
Thus the fallback store is never modified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OverlayStore(Store):
    &#34;&#34;&#34;Overlay store combines two stores: overlay and fallback.
    Overlay is used as a primary store for reading and writing.
    The fallback is used only for reading if key is not found in the overlay store (and is not removed).
    Thus the fallback store is never modified.
    &#34;&#34;&#34;

    def __init__(self, overlay, fallback):
        self.overlay = overlay
        self.fallback = fallback
        self.removed = set()

    def sync(self):
        self.overlay.sync()
        self.fallback.sync()

    def get_bytes(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                return self.overlay.get_bytes(key)
            else:
                return self.fallback.get_bytes(key)

    def get_metadata(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                return self.overlay.get_metadata(key)
            else:
                return self.fallback.get_metadata(key)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        try:
            self.removed.remove(key)
        except KeyError:
            pass
        self.overlay.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        try:
            self.removed.remove(key)
        except KeyError:
            pass
        self.overlay.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        if key not in self.removed:
            if self.overlay.contains(key):
                self.overlay.remove(key)
            if self.fallback.contains(key):
                self.removed.add(key)
        self.on_removed(key)

    def removedir(self, key):
        if self.contains(key):
            if len(self.listdir(key)) == 0:
                if self.overlay.contains(key):
                    self.overlay.remove(key)
                else:
                    self.removed.add(key)
        self.on_removed(key)

    def contains(self, key):
        if key in self.removed:
            return False
        else:
            return self.overlay.contains(key) or self.fallback.contains(key)

    def is_dir(self, key):
        if key in self.removed:
            return False
        else:
            if self.overlay.contains(key):
                return self.overlay.is_dir(key)
            else:
                return self.fallback.is_dir(key)

    def keys(self):
        return sorted(
            set(self.overlay.keys())
            .union(self.fallback.keys())
            .difference(self.removed)
        )

    def listdir(self, key):
        if key.endswith(&#34;/&#34;):
            key = key[:-1]
        ld = self.overlay.listdir(key)
        d = set() if ld is None else set(ld)
        ld = self.fallback.listdir(key)
        d = d if ld is None else d.union(ld)
        return [x for x in sorted(d) if key + &#34;/&#34; + x not in self.removed]

    def makedir(self, key):
        if key in self.removed:
            self.removed.remove(key)
        self.overlay.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        mode = dict(r=&#34;rb&#34;, w=&#34;wb&#34;).get(mode, mode)
        if mode == &#34;rb&#34;:
            if self.overlay.contains(key):
                return self.overlay.openbin(key, mode, buffering)
            elif self.fallback.contains(key):
                return self.fallback.openbin(key, mode, buffering)
        elif mode == &#34;wb&#34;:
            return self.overlay.openbin(key, mode, buffering)

    def is_supported(self, key):
        return self.overlay.is_supported(key) or self.fallback.is_supported(key())

    def __str__(self):
        return f&#34;Overlay of ({self.overlay}) over ({self.fallback})&#34;

    def __repr__(self):
        return f&#34;OverlayStore({repr(self.overlay)},{repr(self.fallback)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.OverlayStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self.overlay.sync()
    self.fallback.sync()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.PrefixStore"><code class="flex name class">
<span>class <span class="ident">PrefixStore</span></span>
<span>(</span><span>store, prefix)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrefixStore(KeyTranslatingStore):
    def __init__(self, store, prefix):
        self.substore = store
        self.prefix = prefix
        self.substore.parent_store = self

    def translate_key(self, key, inverse=False):
        prefix = self.prefix + &#34;/&#34;
        if inverse:
            if key in (None, &#34;&#34;):
                return self.prefix
            else:
                return prefix + key
        else:
            if key == self.prefix:
                return &#34;&#34;
            else:
                if key.startswith(prefix):
                    return key[len(prefix) :]
                else:
                    raise KeyNotSupportedStoreException

    def contains(self, key):
        if key == self.prefix:
            return True
        return self.substore.contains(self.translate_key(key))

    def is_dir(self, key):
        if key == self.prefix:
            return True
        return self.substore.is_dir(self.translate_key(key))

    def __str__(self):
        return f&#34;Prefixed store {self.prefix} on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;PrefixStore({repr(self.substore)}, prefix={repr(self.prefix)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.KeyTranslatingStore" href="#liquer.store.KeyTranslatingStore">KeyTranslatingStore</a></li>
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.PrefixStore.translate_key"><code class="name flex">
<span>def <span class="ident">translate_key</span></span>(<span>self, key, inverse=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate_key(self, key, inverse=False):
    prefix = self.prefix + &#34;/&#34;
    if inverse:
        if key in (None, &#34;&#34;):
            return self.prefix
        else:
            return prefix + key
    else:
        if key == self.prefix:
            return &#34;&#34;
        else:
            if key.startswith(prefix):
                return key[len(prefix) :]
            else:
                raise KeyNotSupportedStoreException</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.KeyTranslatingStore" href="#liquer.store.KeyTranslatingStore">KeyTranslatingStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.KeyTranslatingStore.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.to_root_key" href="#liquer.store.KeyTranslatingStore.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.ProxyStore"><code class="flex name class">
<span>class <span class="ident">ProxyStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Proxy to another store - can be used as a basis to override certain behaviour</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProxyStore(Store):
    &#34;&#34;&#34;Proxy to another store - can be used as a basis to override certain behaviour&#34;&#34;&#34;

    def __init__(self, store):
        self._store = store
        self._store.parent_store = self

    def sync(self):
        self._store.sync()

    def get_bytes(self, key):
        return self._store.get_bytes(key)

    def get_metadata(self, key):
        return self._store.get_metadata(key)

    def store(self, key, data, metadata):
        self._store.store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self._store.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self._store.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self._store.remove(key)
        self.on_removed(key)

    def contains(self, key):
        return self._store.contains(key)

    def is_dir(self, key):
        return self._store.is_dir(key)

    def keys(self):
        return self._store.keys()

    def listdir(self, key):
        return self._store.listdir(key)

    def makedir(self, key):
        self._store.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self._store.openbin(key, mode, buffering)

    def is_supported(self, key):
        return self._store.is_supported(key)

    def __str__(self):
        return f&#34;proxy of {self._store}&#34;

    def __repr__(self):
        return f&#34;ProxyStore({repr(self._store)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.store.IndexerStore" href="#liquer.store.IndexerStore">IndexerStore</a></li>
<li><a title="liquer.store.ReadOnlyStore" href="#liquer.store.ReadOnlyStore">ReadOnlyStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.ProxyStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self._store.sync()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.ReadOnlyStore"><code class="flex name class">
<span>class <span class="ident">ReadOnlyStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Read only proxy to a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadOnlyStore(ProxyStore):
    &#34;&#34;&#34;Read only proxy to a store&#34;&#34;&#34;

    def store(self, key, data, metadata):
        raise ReadOnlyStoreException(key=key, store=self)

    def store_metadata(self, key, metadata):
        raise ReadOnlyStoreException(key=key, store=self)

    def remove(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def removedir(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def makedir(self, key):
        raise ReadOnlyStoreException(key=key, store=self)

    def __str__(self):
        return f&#34;read only proxy of {self._store}&#34;

    def __repr__(self):
        return f&#34;ReadOnlyStore({repr(self._store)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></li>
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.ProxyStore.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.ProxyStore.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.ProxyStore.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.ProxyStore.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.ProxyStore.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.ProxyStore.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.ProxyStore.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.ProxyStore.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.ProxyStore.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.ProxyStore.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.ProxyStore.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.ProxyStore.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.ProxyStore.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.ProxyStore.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.ProxyStore.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.ProxyStore.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.ProxyStore.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.ReadOnlyStoreException"><code class="flex name class">
<span>class <span class="ident">ReadOnlyStoreException</span></span>
<span>(</span><span>message='Key is read only', key=None, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General superclass for exceptions associated with a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadOnlyStoreException(StoreException):
    def __init__(self, message=&#34;Key is read only&#34;, key=None, store=None):
        super().__init__(message=message, key=key, store=store)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.StoreException" href="#liquer.store.StoreException">StoreException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="liquer.store.RoutingStore"><code class="flex name class">
<span>class <span class="ident">RoutingStore</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingStore(Store):
    def route_to(self, key):
        raise KeyRouteNotFoundStoreException(key=key, store=self)

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        metadata = super().finalize_metadata(
            metadata, key=key, is_dir=is_dir, data=data, update=update
        )
        return metadata

    def is_supported(self, key):
        try:
            store = self.route_to(key)
            if store is None:
                return False
            return store.is_supported(key)
        except KeyNotSupportedStoreException:
            return False

    def get_bytes(self, key):
        return self.route_to(key).get_bytes(key)

    def get_metadata(self, key):
        metadata = self.route_to(key).get_metadata(key)
        metadata[&#34;key&#34;] = key
        return metadata

    def store(self, key, data, metadata):
        self.route_to(key).store(key, data, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        self.route_to(key).store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.route_to(key).remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.route_to(key).removedir(key)
        self.on_removed(key)

    def contains(self, key):
        return self.route_to(key).contains(key)

    def is_dir(self, key):
        return self.route_to(key).is_dir(key)

    def keys(self):
        raise NotImplementedError

    def listdir(self, key):
        return self.route_to(key).listdir(key)

    def makedir(self, key):
        self.route_to(key).makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        return self.route_to(key).openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Abstract routing store&#34;

    def __repr__(self):
        return f&#34;RoutingStore()&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.store.MountPointStore" href="#liquer.store.MountPointStore">MountPointStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.RoutingStore.finalize_metadata"><code class="name flex">
<span>def <span class="ident">finalize_metadata</span></span>(<span>self, metadata, key, is_dir=False, data=None, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
    metadata = super().finalize_metadata(
        metadata, key=key, is_dir=is_dir, data=data, update=update
    )
    return metadata</code></pre>
</details>
</dd>
<dt id="liquer.store.RoutingStore.route_to"><code class="name flex">
<span>def <span class="ident">route_to</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route_to(self, key):
    raise KeyRouteNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.Store"><code class="flex name class">
<span>class <span class="ident">Store</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Store(StoreMixin):
    parent_store = None
    MD5_CHECKSUM = True

    def parent_key(self, key):
        &#34;For backwards compatibility only; use parent_key function&#34;
        return parent_key(key)

    def key_name(self, key):
        &#34;For backwards compatibility only; use key_name function&#34;
        return key_name(key)

    def join_key(self, key, name):
        &#34;For backwards compatibility only; use join_key function&#34;
        return join_key(key, name)

    def default_metadata(self, key, is_dir=False):
        if key is None:
            key = &#34;&#34;

        return dict(
            key=key,
            fileinfo=dict(name=key_name(key), is_dir=is_dir, filesystem_path=None),
        )

    def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
        if data is not None:
            if type(data) != bytes:
                print(f&#34;WARNING: Non-binary data for &#39;{key}&#39;: type is {type(data)}&#34;)
        if key is None:
            key = &#34;&#34;
        metadata[&#34;key&#34;] = key
        update = update or data is not None
        if update:
            metadata[&#34;updated&#34;] = util.now()
        if data is not None:
            metadata[&#34;created&#34;] = metadata[&#34;updated&#34;]
        metadata[&#34;fileinfo&#34;] = metadata.get(&#34;fileinfo&#34;, {})
        metadata[&#34;fileinfo&#34;][&#34;name&#34;] = key_name(key)
        metadata[&#34;fileinfo&#34;][&#34;is_dir&#34;] = is_dir
        metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = metadata[&#34;fileinfo&#34;].get(
            &#34;filesystem_path&#34;
        )

        if data is not None:
            metadata[&#34;fileinfo&#34;][&#34;size&#34;] = len(data)
            if self.MD5_CHECKSUM and type(data) == bytes:
                metadata[&#34;fileinfo&#34;][&#34;md5&#34;] = hashlib.md5(data).hexdigest()

        if metadata.get(&#34;mimetype&#34;) is None:
            mimetype = mimetype_from_extension(key_extension(key))
            metadata[&#34;mimetype&#34;] = mimetype

        if metadata.get(&#34;type_identifier&#34;) is None:
            type_identifier = type_identifier_from_extension(key_extension(key))
            metadata[&#34;type_identifier&#34;] = type_identifier

        return Metadata(metadata).as_dict()

    def get_bytes(self, key):
        &#34;&#34;&#34;Get data as bytes&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def get_metadata(self, key):
        &#34;&#34;&#34;Get metadata&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        &#34;&#34;&#34;Store data and metadata.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def store_metadata(self, key, metadata):
        &#34;&#34;&#34;Store metadata only.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def remove(self, key):
        &#34;&#34;&#34;Remove data and metadata associated with the key.&#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def removedir(self, key):
        &#34;&#34;&#34;Remove directory.
        The key must be a directory.
        It depends on the underlying store whether the directory must be empty.
        &#34;&#34;&#34;
        raise KeyNotFoundStoreException(key=key, store=self)

    def contains(self, key):
        &#34;&#34;&#34;Returns true if store contains the key.&#34;&#34;&#34;
        return key == &#34;&#34;

    def is_dir(self, key):
        &#34;&#34;&#34;Returns true if key is a directory.&#34;&#34;&#34;
        return key == &#34;&#34;

    def keys(self):
        &#34;&#34;&#34;List or iterator of all keys&#34;&#34;&#34;
        return []

    def listdir(self, key):
        &#34;&#34;&#34;Return names inside a directory specified by key.
        To get a key, names need to be joined with the key (key/name).
        Complete keys can be obtained with the listdir_keys method.
        &#34;&#34;&#34;
        return []

    def listdir_keys(self, key):
        &#34;&#34;&#34;Return keys inside a directory specified by key.&#34;&#34;&#34;
        if key in (&#34;&#34;, None):
            return self.listdir(key)
        else:
            return [self.join_key(key, k) for k in self.listdir(key)]

    def makedir(self, key):
        &#34;Make a directory&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        &#34;&#34;&#34;Return a file handle.
        This is not necessarily always well supported, but it is required to support PyFilesystem2.&#34;&#34;&#34;
        raise KeyNotSupportedStoreException(key=key, store=self)

    def is_supported(self, key):
        &#34;&#34;&#34;Returns true when this store supports the supplied key.
        This allows layering Stores, e.g. by with_overlay, with_fallback
        and store selectively certain data (keys) in certain stores.
        &#34;&#34;&#34;
        return False

    def on_data_changed(self, key):
        &#34;&#34;&#34;Event handler called when the data is changed.&#34;&#34;&#34;
        pass

    def on_metadata_changed(self, key):
        &#34;&#34;&#34;Event handler called when the metadata is changed.&#34;&#34;&#34;
        pass

    def on_removed(self, key):
        &#34;&#34;&#34;Event handler called when the data or directory is removed.&#34;&#34;&#34;
        pass

    def to_root_key(self, key):
        &#34;&#34;&#34;Convert local store key to a key in a root store.
        This is can be used e.g. to convert a key valid in a mounted (child) store to
        a key of a root store.
        The to_root_key(key) in the root_store() should point to the same object as key in self.
        &#34;&#34;&#34;
        if self.parent_store is None:
            return key
        return self.parent_store.to_root_key(key)

    def root_store(self):
        &#34;&#34;&#34;Get the root store.
        Root store is the highest level store in the store system.
        The to_root_key(key) in the root_store() should point to the same object as key in self.
        &#34;&#34;&#34;
        if self.parent_store is None:
            return self
        return self.parent_store.root_store()

    def sync(self):
        pass

    def __str__(self):
        return f&#34;Empty store&#34;

    def __repr__(self):
        return f&#34;Store()&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.recipes.NewRecipeSpecStore" href="recipes.html#liquer.recipes.NewRecipeSpecStore">NewRecipeSpecStore</a></li>
<li><a title="liquer.recipes.RecipeStore" href="recipes.html#liquer.recipes.RecipeStore">RecipeStore</a></li>
<li><a title="liquer.remote_store.RemoteStore" href="remote_store.html#liquer.remote_store.RemoteStore">RemoteStore</a></li>
<li><a title="liquer.s3_store.S3Store" href="s3_store.html#liquer.s3_store.S3Store">S3Store</a></li>
<li><a title="liquer.store.FSSpecStore" href="#liquer.store.FSSpecStore">FSSpecStore</a></li>
<li><a title="liquer.store.FileStore" href="#liquer.store.FileStore">FileStore</a></li>
<li><a title="liquer.store.FileSystemStore" href="#liquer.store.FileSystemStore">FileSystemStore</a></li>
<li><a title="liquer.store.KeyTranslatingStore" href="#liquer.store.KeyTranslatingStore">KeyTranslatingStore</a></li>
<li><a title="liquer.store.MemoryStore" href="#liquer.store.MemoryStore">MemoryStore</a></li>
<li><a title="liquer.store.OverlayStore" href="#liquer.store.OverlayStore">OverlayStore</a></li>
<li><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></li>
<li><a title="liquer.store.RoutingStore" href="#liquer.store.RoutingStore">RoutingStore</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.store.Store.MD5_CHECKSUM"><code class="name">var <span class="ident">MD5_CHECKSUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="liquer.store.Store.parent_store"><code class="name">var <span class="ident">parent_store</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.Store.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if store contains the key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, key):
    &#34;&#34;&#34;Returns true if store contains the key.&#34;&#34;&#34;
    return key == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.default_metadata"><code class="name flex">
<span>def <span class="ident">default_metadata</span></span>(<span>self, key, is_dir=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_metadata(self, key, is_dir=False):
    if key is None:
        key = &#34;&#34;

    return dict(
        key=key,
        fileinfo=dict(name=key_name(key), is_dir=is_dir, filesystem_path=None),
    )</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.finalize_metadata"><code class="name flex">
<span>def <span class="ident">finalize_metadata</span></span>(<span>self, metadata, key, is_dir=False, data=None, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize_metadata(self, metadata, key, is_dir=False, data=None, update=False):
    if data is not None:
        if type(data) != bytes:
            print(f&#34;WARNING: Non-binary data for &#39;{key}&#39;: type is {type(data)}&#34;)
    if key is None:
        key = &#34;&#34;
    metadata[&#34;key&#34;] = key
    update = update or data is not None
    if update:
        metadata[&#34;updated&#34;] = util.now()
    if data is not None:
        metadata[&#34;created&#34;] = metadata[&#34;updated&#34;]
    metadata[&#34;fileinfo&#34;] = metadata.get(&#34;fileinfo&#34;, {})
    metadata[&#34;fileinfo&#34;][&#34;name&#34;] = key_name(key)
    metadata[&#34;fileinfo&#34;][&#34;is_dir&#34;] = is_dir
    metadata[&#34;fileinfo&#34;][&#34;filesystem_path&#34;] = metadata[&#34;fileinfo&#34;].get(
        &#34;filesystem_path&#34;
    )

    if data is not None:
        metadata[&#34;fileinfo&#34;][&#34;size&#34;] = len(data)
        if self.MD5_CHECKSUM and type(data) == bytes:
            metadata[&#34;fileinfo&#34;][&#34;md5&#34;] = hashlib.md5(data).hexdigest()

    if metadata.get(&#34;mimetype&#34;) is None:
        mimetype = mimetype_from_extension(key_extension(key))
        metadata[&#34;mimetype&#34;] = mimetype

    if metadata.get(&#34;type_identifier&#34;) is None:
        type_identifier = type_identifier_from_extension(key_extension(key))
        metadata[&#34;type_identifier&#34;] = type_identifier

    return Metadata(metadata).as_dict()</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.get_bytes"><code class="name flex">
<span>def <span class="ident">get_bytes</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data as bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bytes(self, key):
    &#34;&#34;&#34;Get data as bytes&#34;&#34;&#34;
    raise KeyNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(self, key):
    &#34;&#34;&#34;Get metadata&#34;&#34;&#34;
    raise KeyNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.is_dir"><code class="name flex">
<span>def <span class="ident">is_dir</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if key is a directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dir(self, key):
    &#34;&#34;&#34;Returns true if key is a directory.&#34;&#34;&#34;
    return key == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.is_supported"><code class="name flex">
<span>def <span class="ident">is_supported</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true when this store supports the supplied key.
This allows layering Stores, e.g. by with_overlay, with_fallback
and store selectively certain data (keys) in certain stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_supported(self, key):
    &#34;&#34;&#34;Returns true when this store supports the supplied key.
    This allows layering Stores, e.g. by with_overlay, with_fallback
    and store selectively certain data (keys) in certain stores.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.join_key"><code class="name flex">
<span>def <span class="ident">join_key</span></span>(<span>self, key, name)</span>
</code></dt>
<dd>
<div class="desc"><p>For backwards compatibility only; use join_key function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_key(self, key, name):
    &#34;For backwards compatibility only; use join_key function&#34;
    return join_key(key, name)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.key_name"><code class="name flex">
<span>def <span class="ident">key_name</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>For backwards compatibility only; use key_name function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_name(self, key):
    &#34;For backwards compatibility only; use key_name function&#34;
    return key_name(key)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List or iterator of all keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;List or iterator of all keys&#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.listdir"><code class="name flex">
<span>def <span class="ident">listdir</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return names inside a directory specified by key.
To get a key, names need to be joined with the key (key/name).
Complete keys can be obtained with the listdir_keys method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir(self, key):
    &#34;&#34;&#34;Return names inside a directory specified by key.
    To get a key, names need to be joined with the key (key/name).
    Complete keys can be obtained with the listdir_keys method.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.listdir_keys"><code class="name flex">
<span>def <span class="ident">listdir_keys</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return keys inside a directory specified by key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir_keys(self, key):
    &#34;&#34;&#34;Return keys inside a directory specified by key.&#34;&#34;&#34;
    if key in (&#34;&#34;, None):
        return self.listdir(key)
    else:
        return [self.join_key(key, k) for k in self.listdir(key)]</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.makedir"><code class="name flex">
<span>def <span class="ident">makedir</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makedir(self, key):
    &#34;Make a directory&#34;
    raise KeyNotSupportedStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.on_data_changed"><code class="name flex">
<span>def <span class="ident">on_data_changed</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Event handler called when the data is changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_data_changed(self, key):
    &#34;&#34;&#34;Event handler called when the data is changed.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.on_metadata_changed"><code class="name flex">
<span>def <span class="ident">on_metadata_changed</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Event handler called when the metadata is changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_metadata_changed(self, key):
    &#34;&#34;&#34;Event handler called when the metadata is changed.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.on_removed"><code class="name flex">
<span>def <span class="ident">on_removed</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Event handler called when the data or directory is removed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_removed(self, key):
    &#34;&#34;&#34;Event handler called when the data or directory is removed.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.openbin"><code class="name flex">
<span>def <span class="ident">openbin</span></span>(<span>self, key, mode='r', buffering=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a file handle.
This is not necessarily always well supported, but it is required to support PyFilesystem2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
    &#34;&#34;&#34;Return a file handle.
    This is not necessarily always well supported, but it is required to support PyFilesystem2.&#34;&#34;&#34;
    raise KeyNotSupportedStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.parent_key"><code class="name flex">
<span>def <span class="ident">parent_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>For backwards compatibility only; use parent_key function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parent_key(self, key):
    &#34;For backwards compatibility only; use parent_key function&#34;
    return parent_key(key)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove data and metadata associated with the key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key):
    &#34;&#34;&#34;Remove data and metadata associated with the key.&#34;&#34;&#34;
    raise KeyNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.removedir"><code class="name flex">
<span>def <span class="ident">removedir</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove directory.
The key must be a directory.
It depends on the underlying store whether the directory must be empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removedir(self, key):
    &#34;&#34;&#34;Remove directory.
    The key must be a directory.
    It depends on the underlying store whether the directory must be empty.
    &#34;&#34;&#34;
    raise KeyNotFoundStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.root_store"><code class="name flex">
<span>def <span class="ident">root_store</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the root store.
Root store is the highest level store in the store system.
The to_root_key(key) in the root_store() should point to the same object as key in self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def root_store(self):
    &#34;&#34;&#34;Get the root store.
    Root store is the highest level store in the store system.
    The to_root_key(key) in the root_store() should point to the same object as key in self.
    &#34;&#34;&#34;
    if self.parent_store is None:
        return self
    return self.parent_store.root_store()</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, key, data, metadata)</span>
</code></dt>
<dd>
<div class="desc"><p>Store data and metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, key, data, metadata):
    &#34;&#34;&#34;Store data and metadata.&#34;&#34;&#34;
    raise KeyNotSupportedStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.store_metadata"><code class="name flex">
<span>def <span class="ident">store_metadata</span></span>(<span>self, key, metadata)</span>
</code></dt>
<dd>
<div class="desc"><p>Store metadata only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_metadata(self, key, metadata):
    &#34;&#34;&#34;Store metadata only.&#34;&#34;&#34;
    raise KeyNotSupportedStoreException(key=key, store=self)</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    pass</code></pre>
</details>
</dd>
<dt id="liquer.store.Store.to_root_key"><code class="name flex">
<span>def <span class="ident">to_root_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert local store key to a key in a root store.
This is can be used e.g. to convert a key valid in a mounted (child) store to
a key of a root store.
The to_root_key(key) in the root_store() should point to the same object as key in self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_root_key(self, key):
    &#34;&#34;&#34;Convert local store key to a key in a root store.
    This is can be used e.g. to convert a key valid in a mounted (child) store to
    a key of a root store.
    The to_root_key(key) in the root_store() should point to the same object as key in self.
    &#34;&#34;&#34;
    if self.parent_store is None:
        return key
    return self.parent_store.to_root_key(key)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.StoreMixin.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.StoreMixin.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.store.StoreException"><code class="flex name class">
<span>class <span class="ident">StoreException</span></span>
<span>(</span><span>message, key=None, store=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General superclass for exceptions associated with a store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoreException(Exception):
    &#34;&#34;&#34;General superclass for exceptions associated with a store&#34;&#34;&#34;
    def __init__(self, message, key=None, store=None):
        self.original_message = message
        if key is not None:
            k = key if store is None else store.to_root_key(key)
            message += f&#34;:\n  key: &#39;{k}&#39;&#34;
        if store is not None:
            message += f&#34;  store: {store}&#34;

        super().__init__(message)
        self.key = key
        self.store = store</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.store.KeyNotFoundStoreException" href="#liquer.store.KeyNotFoundStoreException">KeyNotFoundStoreException</a></li>
<li><a title="liquer.store.KeyNotSupportedStoreException" href="#liquer.store.KeyNotSupportedStoreException">KeyNotSupportedStoreException</a></li>
<li><a title="liquer.store.KeyRouteNotFoundStoreException" href="#liquer.store.KeyRouteNotFoundStoreException">KeyRouteNotFoundStoreException</a></li>
<li><a title="liquer.store.ReadOnlyStoreException" href="#liquer.store.ReadOnlyStoreException">ReadOnlyStoreException</a></li>
</ul>
</dd>
<dt id="liquer.store.StoreMixin"><code class="flex name class">
<span>class <span class="ident">StoreMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoreMixin:
    &#34;Mixing adding extra functionality to stores.&#34;
    def with_overlay(self, overlay):
        &#34;&#34;&#34;Create an overlay over the store.
        Overlay store will be consulted first, when the key is not supported or not found in the overlay,
        the request will be passed to the current store (self).
        Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
        &#34;&#34;&#34;
        return OverlayStore(overlay, self)

    def with_fallback(self, fallback):
        &#34;&#34;&#34;Create a fallback for the store.
        When the key is not supported or not found in the current store (self),
        request will be passed to fallback.
        Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
        &#34;&#34;&#34;
        return OverlayStore(self, fallback)

    def mount(self, key, store):
        &#34;&#34;&#34;Mount a store in a mount-point&#34;&#34;&#34;
        if isinstance(self, MountPointStore):
            return self.mount(key, store)
        else:
            return MountPointStore(self).mount(key, store)

    def read_only(self):
        &#34;&#34;&#34;Create a read-only proxy for the store.&#34;&#34;&#34;
        if isinstance(self, ReadOnlyStore):
            return self
        else:
            return ReadOnlyStore(self)

    def with_indexer(self):
        &#34;&#34;&#34;Create a proxy store that will run indexer on each write.&#34;&#34;&#34;
        if isinstance(self, IndexerStore):
            return self
        else:
            return IndexerStore(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.store.StoreMixin.mount"><code class="name flex">
<span>def <span class="ident">mount</span></span>(<span>self, key, store)</span>
</code></dt>
<dd>
<div class="desc"><p>Mount a store in a mount-point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount(self, key, store):
    &#34;&#34;&#34;Mount a store in a mount-point&#34;&#34;&#34;
    if isinstance(self, MountPointStore):
        return self.mount(key, store)
    else:
        return MountPointStore(self).mount(key, store)</code></pre>
</details>
</dd>
<dt id="liquer.store.StoreMixin.read_only"><code class="name flex">
<span>def <span class="ident">read_only</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a read-only proxy for the store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_only(self):
    &#34;&#34;&#34;Create a read-only proxy for the store.&#34;&#34;&#34;
    if isinstance(self, ReadOnlyStore):
        return self
    else:
        return ReadOnlyStore(self)</code></pre>
</details>
</dd>
<dt id="liquer.store.StoreMixin.with_fallback"><code class="name flex">
<span>def <span class="ident">with_fallback</span></span>(<span>self, fallback)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a fallback for the store.
When the key is not supported or not found in the current store (self),
request will be passed to fallback.
Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_fallback(self, fallback):
    &#34;&#34;&#34;Create a fallback for the store.
    When the key is not supported or not found in the current store (self),
    request will be passed to fallback.
    Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
    &#34;&#34;&#34;
    return OverlayStore(self, fallback)</code></pre>
</details>
</dd>
<dt id="liquer.store.StoreMixin.with_indexer"><code class="name flex">
<span>def <span class="ident">with_indexer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a proxy store that will run indexer on each write.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_indexer(self):
    &#34;&#34;&#34;Create a proxy store that will run indexer on each write.&#34;&#34;&#34;
    if isinstance(self, IndexerStore):
        return self
    else:
        return IndexerStore(self)</code></pre>
</details>
</dd>
<dt id="liquer.store.StoreMixin.with_overlay"><code class="name flex">
<span>def <span class="ident">with_overlay</span></span>(<span>self, overlay)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an overlay over the store.
Overlay store will be consulted first, when the key is not supported or not found in the overlay,
the request will be passed to the current store (self).
Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_overlay(self, overlay):
    &#34;&#34;&#34;Create an overlay over the store.
    Overlay store will be consulted first, when the key is not supported or not found in the overlay,
    the request will be passed to the current store (self).
    Note: a.with_overlay(b) is the same as b.with_fallback(a). Both methods create an OverlayStore instance.
    &#34;&#34;&#34;
    return OverlayStore(overlay, self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="liquer" href="index.html">liquer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="liquer.store.get_store" href="#liquer.store.get_store">get_store</a></code></li>
<li><code><a title="liquer.store.get_web_store" href="#liquer.store.get_web_store">get_web_store</a></code></li>
<li><code><a title="liquer.store.join_key" href="#liquer.store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.key_extension" href="#liquer.store.key_extension">key_extension</a></code></li>
<li><code><a title="liquer.store.key_name" href="#liquer.store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.key_name_without_extension" href="#liquer.store.key_name_without_extension">key_name_without_extension</a></code></li>
<li><code><a title="liquer.store.mount" href="#liquer.store.mount">mount</a></code></li>
<li><code><a title="liquer.store.mount_folder" href="#liquer.store.mount_folder">mount_folder</a></code></li>
<li><code><a title="liquer.store.parent_key" href="#liquer.store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.set_store" href="#liquer.store.set_store">set_store</a></code></li>
<li><code><a title="liquer.store.web_mount" href="#liquer.store.web_mount">web_mount</a></code></li>
<li><code><a title="liquer.store.web_mount_folder" href="#liquer.store.web_mount_folder">web_mount_folder</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="liquer.store.FSSpecStore" href="#liquer.store.FSSpecStore">FSSpecStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.FSSpecStore.METADATA" href="#liquer.store.FSSpecStore.METADATA">METADATA</a></code></li>
<li><code><a title="liquer.store.FSSpecStore.metadata_dir_path_for_key" href="#liquer.store.FSSpecStore.metadata_dir_path_for_key">metadata_dir_path_for_key</a></code></li>
<li><code><a title="liquer.store.FSSpecStore.metadata_path_for_key" href="#liquer.store.FSSpecStore.metadata_path_for_key">metadata_path_for_key</a></code></li>
<li><code><a title="liquer.store.FSSpecStore.path_for_key" href="#liquer.store.FSSpecStore.path_for_key">path_for_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.FileStore" href="#liquer.store.FileStore">FileStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.FileStore.METADATA" href="#liquer.store.FileStore.METADATA">METADATA</a></code></li>
<li><code><a title="liquer.store.FileStore.finalize_metadata" href="#liquer.store.FileStore.finalize_metadata">finalize_metadata</a></code></li>
<li><code><a title="liquer.store.FileStore.metadata_path_for_key" href="#liquer.store.FileStore.metadata_path_for_key">metadata_path_for_key</a></code></li>
<li><code><a title="liquer.store.FileStore.path_for_key" href="#liquer.store.FileStore.path_for_key">path_for_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.FileSystemStore" href="#liquer.store.FileSystemStore">FileSystemStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.FileSystemStore.METADATA" href="#liquer.store.FileSystemStore.METADATA">METADATA</a></code></li>
<li><code><a title="liquer.store.FileSystemStore.metadata_dir_path_for_key" href="#liquer.store.FileSystemStore.metadata_dir_path_for_key">metadata_dir_path_for_key</a></code></li>
<li><code><a title="liquer.store.FileSystemStore.metadata_path_for_key" href="#liquer.store.FileSystemStore.metadata_path_for_key">metadata_path_for_key</a></code></li>
<li><code><a title="liquer.store.FileSystemStore.path_for_key" href="#liquer.store.FileSystemStore.path_for_key">path_for_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.IndexerStore" href="#liquer.store.IndexerStore">IndexerStore</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.KeyNotFoundStoreException" href="#liquer.store.KeyNotFoundStoreException">KeyNotFoundStoreException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.KeyNotSupportedStoreException" href="#liquer.store.KeyNotSupportedStoreException">KeyNotSupportedStoreException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.KeyRouteNotFoundStoreException" href="#liquer.store.KeyRouteNotFoundStoreException">KeyRouteNotFoundStoreException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.KeyTranslatingStore" href="#liquer.store.KeyTranslatingStore">KeyTranslatingStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.KeyTranslatingStore.sync" href="#liquer.store.KeyTranslatingStore.sync">sync</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.to_root_key" href="#liquer.store.KeyTranslatingStore.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.KeyTranslatingStore.translate_key" href="#liquer.store.KeyTranslatingStore.translate_key">translate_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.MemoryStore" href="#liquer.store.MemoryStore">MemoryStore</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.MountPointStore" href="#liquer.store.MountPointStore">MountPointStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.MountPointStore.route_to" href="#liquer.store.MountPointStore.route_to">route_to</a></code></li>
<li><code><a title="liquer.store.MountPointStore.sync" href="#liquer.store.MountPointStore.sync">sync</a></code></li>
<li><code><a title="liquer.store.MountPointStore.umount" href="#liquer.store.MountPointStore.umount">umount</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.OverlayStore" href="#liquer.store.OverlayStore">OverlayStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.OverlayStore.sync" href="#liquer.store.OverlayStore.sync">sync</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.PrefixStore" href="#liquer.store.PrefixStore">PrefixStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.PrefixStore.translate_key" href="#liquer.store.PrefixStore.translate_key">translate_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.ProxyStore" href="#liquer.store.ProxyStore">ProxyStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.ProxyStore.sync" href="#liquer.store.ProxyStore.sync">sync</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.ReadOnlyStore" href="#liquer.store.ReadOnlyStore">ReadOnlyStore</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.ReadOnlyStoreException" href="#liquer.store.ReadOnlyStoreException">ReadOnlyStoreException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.RoutingStore" href="#liquer.store.RoutingStore">RoutingStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.RoutingStore.finalize_metadata" href="#liquer.store.RoutingStore.finalize_metadata">finalize_metadata</a></code></li>
<li><code><a title="liquer.store.RoutingStore.route_to" href="#liquer.store.RoutingStore.route_to">route_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.Store" href="#liquer.store.Store">Store</a></code></h4>
<ul class="two-column">
<li><code><a title="liquer.store.Store.MD5_CHECKSUM" href="#liquer.store.Store.MD5_CHECKSUM">MD5_CHECKSUM</a></code></li>
<li><code><a title="liquer.store.Store.contains" href="#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.default_metadata" href="#liquer.store.Store.default_metadata">default_metadata</a></code></li>
<li><code><a title="liquer.store.Store.finalize_metadata" href="#liquer.store.Store.finalize_metadata">finalize_metadata</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.parent_store" href="#liquer.store.Store.parent_store">parent_store</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.sync" href="#liquer.store.Store.sync">sync</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="#liquer.store.Store.to_root_key">to_root_key</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.store.StoreException" href="#liquer.store.StoreException">StoreException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.store.StoreMixin" href="#liquer.store.StoreMixin">StoreMixin</a></code></h4>
<ul class="">
<li><code><a title="liquer.store.StoreMixin.mount" href="#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.StoreMixin.read_only" href="#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_fallback" href="#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_indexer" href="#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.StoreMixin.with_overlay" href="#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>