<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>liquer.server.blueprint API documentation</title>
<meta name="description" content="[Flask](https://flask.palletsprojects.com) blueprint for LiQuer server" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>liquer.server.blueprint</code></h1>
</header>
<section id="section-intro">
<p><a href="https://flask.palletsprojects.com">Flask</a> blueprint for LiQuer server</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;[Flask](https://flask.palletsprojects.com) blueprint for LiQuer server&#34;&#34;&#34;
import logging
from flask import Blueprint, jsonify, redirect, send_file, request, make_response, abort
from liquer.query import evaluate
from liquer.state_types import encode_state_data, state_types_registry
from liquer.commands import command_registry
from liquer.state import get_vars
from liquer.cache import get_cache
from liquer.store import get_store, KeyNotFoundStoreException
import io
import traceback

app = Blueprint(&#34;liquer&#34;, __name__, static_folder=&#34;static&#34;)
logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


@app.route(&#34;/&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
@app.route(&#34;/index.html&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def index():
    &#34;&#34;&#34;Link to a LiQuer main service page&#34;&#34;&#34;
    return redirect(&#34;/liquer/static/index.html&#34;)


@app.route(&#34;/info.html&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def info():
    &#34;&#34;&#34;Info page&#34;&#34;&#34;
    return &#34;&#34;&#34;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;LiQuer&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;LiQuer server&lt;/h1&gt;
        For more info, see the &lt;a href=&#34;https://github.com/orest-d/liquer&#34;&gt;repository&lt;/a&gt;.
    &lt;/body&gt;    
&lt;/html&gt;
&#34;&#34;&#34;


def response(state):
    &#34;&#34;&#34;Create flask response from a State&#34;&#34;&#34;
    b, mimetype, type_identifier = encode_state_data(
        state.get(), extension=state.extension
    )
    filename = state.metadata.get(&#34;filename&#34;)
    if filename is None:
        filename = state_types_registry().get(type_identifier).default_filename()
    r = make_response(b)

    r.headers.set(&#34;Content-Type&#34;, mimetype)
    if mimetype not in [
        &#34;application/json&#34;,
        &#34;text/plain&#34;,
        &#34;text/html&#34;,
        &#34;text/csv&#34;,
        &#34;image/png&#34;,
        &#34;image/svg+xml&#34;,
    ]:
        r.headers.set(&#34;Content-Disposition&#34;, &#34;attachment&#34;, filename=filename)
    return r


@app.route(&#34;/q/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def serve(query):
    &#34;&#34;&#34;Main service for evaluating queries&#34;&#34;&#34;
    try:
        kwargs = request.get_json(force=True)
    except:
        kwargs = {}
    assert type(kwargs) == dict
    for k, v in request.args.items():
        kwargs[k] = v

    try:
        return response(evaluate(query, extra_parameters=kwargs))
    except:
        traceback.print_exc()
        abort(500)


@app.route(&#34;/submit/&lt;path:query&gt;&#34;)
def detached_serve(query):
    &#34;&#34;&#34;Main service for evaluating queries&#34;&#34;&#34;
    from liquer.pool import evaluate_in_background

    evaluate_in_background(query)
    return jsonify(dict(status=&#34;OK&#34;, message=&#34;Submitted&#34;, query=query))


@app.route(&#34;/api/cache/get/&lt;path:query&gt;&#34;)
def cache_get(query):
    &#34;&#34;&#34;Get cached data&#34;&#34;&#34;
    state = get_cache().get(query)
    if state is None:
        abort(404)
    return response(state)


@app.route(&#34;/api/cache/meta/&lt;path:query&gt;&#34;)
def cache_get_metadata(query):
    &#34;&#34;&#34;Get cached metadata&#34;&#34;&#34;
    metadata = get_cache().get_metadata(query)
    if metadata == False:
        metadata = dict(query=query, status=&#34;not available&#34;, cached=False) # FIXME
    return jsonify(metadata)


@app.route(&#34;/api/cache/meta/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def cache_store_metadata(query):
    &#34;&#34;&#34;Store metadata in cache.
    Allows to use liquer server as a remote cache.
    &#34;&#34;&#34;
    metadata = request.get_json(force=True)
    try:
        result_code = get_cache().store_metadata(metadata)
        result = dict(
            query=query, result=result_code, status=&#34;OK&#34;, message=&#34;OK&#34;, traceback=&#34;&#34;
        )
    except Exception as e:
        result = dict(
            query=query,
            result=False,
            status=&#34;ERROR&#34;,
            message=str(e),
            traceback=traceback.format_exc(),
        )

    return jsonify(result)


@app.route(&#34;/api/cache/remove/&lt;path:query&gt;&#34;)
def cache_remove(query):
    &#34;&#34;&#34;interface to cache remove&#34;&#34;&#34;
    r = get_cache().remove(query)
    return jsonify(dict(query=query, removed=r))


@app.route(&#34;/api/cache/contains/&lt;path:query&gt;&#34;)
def cache_contains(query):
    &#34;&#34;&#34;interface to cache contains&#34;&#34;&#34;
    contains = get_cache().contains(query)
    return jsonify(dict(query=query, cached=contains))


@app.route(&#34;/api/cache/keys.json&#34;)
def cache_keys():
    &#34;&#34;&#34;interface to cache keys&#34;&#34;&#34;
    keys = dict(keys=list(get_cache().keys()))
    return jsonify(keys)


@app.route(&#34;/api/cache/clean&#34;)
def cache_clean():
    &#34;&#34;&#34;interface to cache clean&#34;&#34;&#34;
    get_cache().clean()
    n = len(list(get_cache().keys()))
    keys = dict(status=&#34;OK&#34;, message=f&#34;Cache cleaned, {n} keys left&#34;)
    return jsonify(keys)


@app.route(&#34;/api/commands.json&#34;)
def commands():
    &#34;&#34;&#34;Returns a list of commands in json format&#34;&#34;&#34;
    return jsonify(command_registry().as_dict())


@app.route(&#34;/api/debug-json/&lt;path:query&gt;&#34;)
def debug_json(query):
    &#34;&#34;&#34;Debug query - returns metadata from a state after a query is evaluated&#34;&#34;&#34;
    state = evaluate(query)
    state_json = state.as_dict()
    return jsonify(state_json)


@app.route(&#34;/api/build&#34;, methods=[&#34;POST&#34;])
def build():
    &#34;&#34;&#34;Build a query from a posted decoded query (list of lists of strings).
    Result is a dictionary with encoded query and link.
    &#34;&#34;&#34;
    from liquer.parser import encode

    query = encode(request.get_json(force=True)[&#34;ql&#34;])
    link = (
        get_vars().get(&#34;server&#34;, &#34;http://localhost&#34;)
        + get_vars().get(&#34;api_path&#34;, &#34;/q/&#34;)
        + query
    )
    return jsonify(dict(query=query, link=link, message=&#34;OK&#34;, status=&#34;OK&#34;))


@app.route(&#34;/api/register_command/&lt;data&gt;&#34;, methods=[&#34;GET&#34;])
def register_command(data):
    &#34;&#34;&#34;Remote command registration service.
    This has to be enabled by liquer.commands.enable_remote_registration()

    WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
    therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
    (e.g. on localhost or intranet where only trusted users have access).
    This is on by default on Jupyter server extension.
    &#34;&#34;&#34;
    return jsonify(command_registry().register_remote_serialized(data.encode(&#34;ascii&#34;)))


@app.route(&#34;/api/register_command/&#34;, methods=[&#34;POST&#34;])
def register_command1():
    &#34;&#34;&#34;Remote command registration service.
    This has to be enabled by liquer.commands.enable_remote_registration()

    WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
    therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
    (e.g. on localhost or intranet where only trusted users have access).
    This is on by default on Jupyter server extension.
    &#34;&#34;&#34;
    data = request.get_data()
    return jsonify(command_registry().register_remote_serialized(data))


@app.route(&#34;/api/store/data/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def store_get(query):
    &#34;&#34;&#34;Get data from store. Equivalent to Store.get_bytes.
    Content type (MIME) is obtained from the metadata.
    &#34;&#34;&#34;
    store = get_store()
    try:
        metadata = store.get_metadata(query)
        mimetype = metadata.get(&#34;mimetype&#34;, &#34;application/octet-stream&#34;)
        r = make_response(store.get_bytes(query))
        r.headers.set(&#34;Content-Type&#34;, mimetype)
        return r
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response


@app.route(&#34;/web/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def web_store_get(query):
    &#34;&#34;&#34;Shortcut to the &#39;web&#39; directory in the store.
    Similar to /store/data/web, except the index.html is automatically added if query is a directory.
    The &#39;web&#39; directory hosts web applications and visualization tools, e.g. liquer-pcv or liquer-gui.
    &#34;&#34;&#34;
    store = get_store()
    try:
        query = &#34;web/&#34; + query
        if query.endswith(&#34;/&#34;):
            query += &#34;index.html&#34;
        if store.is_dir(query):
            query += &#34;/index.html&#34;
        metadata = store.get_metadata(query)
        mimetype = metadata.get(&#34;mimetype&#34;, &#34;application/octet-stream&#34;)
        r = make_response(store.get_bytes(query))
        r.headers.set(&#34;Content-Type&#34;, mimetype)
        return r
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/data/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def store_set(query):
    &#34;&#34;&#34;Set data in store. Equivalent to Store.store.
    Unlike store method, which stores both data and metadata in one call,
    the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
    either before or after the api/store/data POST.
    &#34;&#34;&#34;
    store = get_store()
    try:
        metadata = store.get_metadata(query)
    except KeyNotFoundStoreException:
        metadata = {}
        traceback.print_exc()
    try:
        data = request.get_data()
        store.store(query, data, metadata)
        return jsonify(dict(query=query, message=&#34;Data stored&#34;, status=&#34;OK&#34;))
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response


@app.route(&#34;/api/store/upload/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def store_upload(query):
    &#34;&#34;&#34;Upload data to store - similar to /api/store/data, but using upload. Equivalent to Store.store.
    Unlike store method, which stores both data and metadata in one call,
    the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
    either before or after the api/store/data POST.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        if &#34;file&#34; not in request.files:
            response = jsonify(
                dict(
                    query=query,
                    message=&#34;Request does not contain &#39;file&#39;&#34;,
                    status=&#34;ERROR&#34;,
                )
            )
            response.status = &#34;404&#34;
            return response
        file = request.files[&#34;file&#34;]
        if file.filename == &#34;&#34;:
            response = jsonify(
                dict(
                    query=query,
                    message=&#34;Request contains &#39;file&#39; with an empty filename&#34;,
                    status=&#34;ERROR&#34;,
                )
            )
            response.status = &#34;404&#34;
            return response

        try:
            data = file.read()
        except:
            response = jsonify(
                dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
            )
            response.status = &#34;404&#34;
            return response
        store = get_store()
        try:
            metadata = store.get_metadata(query)
        except KeyNotFoundStoreException:
            metadata = {}
            traceback.print_exc()
        try:
            store.store(query, data, metadata)
            return jsonify(
                dict(query=query, message=&#34;Data stored&#34;, size=len(data), status=&#34;OK&#34;)
            )
        except:
            response = jsonify(
                dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
            )
            response.status = &#34;404&#34;
            return response

    r = make_response(
        f&#34;&#34;&#34;
    &lt;!doctype html&gt;
    &lt;title&gt;Upload File&lt;/title&gt;
    &lt;h1&gt;Upload to {query}&lt;/h1&gt;
    &lt;form method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
      &lt;input type=&#34;file&#34; name=&#34;file&#34;/&gt;
      &lt;input type=&#34;submit&#34; value=&#34;Upload&#34;/&gt;
    &lt;/form&gt;
    &#34;&#34;&#34;
    )

    r.headers.set(&#34;Content-Type&#34;, &#34;text/html&#34;)
    return r


@app.route(&#34;/api/store/metadata/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def store_get_metadata(query):
    store = get_store()
    metadata = store.get_metadata(query)
    return jsonify(metadata)


@app.route(&#34;/api/store/metadata/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def store_set_metadata(query):
    store = get_store()
    try:
        metadata = request.get_json(force=True)
        store.store_metadata(query, metadata)

        return jsonify(dict(query=query, message=&#34;Metadata stored&#34;, status=&#34;OK&#34;))
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response


@app.route(&#34;/api/stored_metadata/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def get_stored_metadata(query):
    &#34;&#34;&#34;Get metadata stored in a store or cache&#34;&#34;&#34;
    import liquer.tools

    metadata = liquer.tools.get_stored_metadata(query)
    return jsonify(metadata)


@app.route(&#34;/api/store/remove/&lt;path:query&gt;&#34;)
def store_remove(query):
    store = get_store()
    try:
        store.remove(query)
        return jsonify(dict(query=query, message=f&#34;Removed {query}&#34;, status=&#34;OK&#34;))
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/removedir/&lt;path:query&gt;&#34;)
def store_removedir(query):
    store = get_store()
    try:
        store.removedir(query)
        return jsonify(
            dict(query=query, message=f&#34;Removed directory {query}&#34;, status=&#34;OK&#34;)
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/contains/&lt;path:query&gt;&#34;)
def store_contains(query):
    store = get_store()
    try:
        contains = store.contains(query)
        return jsonify(
            dict(
                query=query, message=f&#34;Contains {query}&#34;, contains=contains, status=&#34;OK&#34;
            )
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/is_dir/&lt;path:query&gt;&#34;)
def store_is_dir(query):
    store = get_store()
    try:
        is_dir = store.is_dir(query)
        return jsonify(
            dict(
                query=query, message=f&#34;Is directory {query}&#34;, is_dir=is_dir, status=&#34;OK&#34;
            )
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/keys&#34;)
def store_keys():
    store = get_store()
    try:
        keys = store.keys()
        return jsonify(
            dict(query=None, message=f&#34;Keys obtained&#34;, keys=keys, status=&#34;OK&#34;)
        )
    except:
        return jsonify(dict(query=None, message=traceback.format_exc(), status=&#34;ERROR&#34;))


@app.route(&#34;/api/store/listdir/&lt;path:query&gt;&#34;)
def store_listdir(query):
    store = get_store()
    try:
        listdir = store.listdir(query)
        return jsonify(
            dict(query=query, message=f&#34;Keys obtained&#34;, listdir=listdir, status=&#34;OK&#34;)
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )


@app.route(&#34;/api/store/makedir/&lt;path:query&gt;&#34;)
def store_makedir(query):
    store = get_store()
    try:
        store.makedir(query)
        return jsonify(dict(query=query, message=f&#34;Makedir succeeded&#34;, status=&#34;OK&#34;))
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="liquer.server.blueprint.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a query from a posted decoded query (list of lists of strings).
Result is a dictionary with encoded query and link.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/build&#34;, methods=[&#34;POST&#34;])
def build():
    &#34;&#34;&#34;Build a query from a posted decoded query (list of lists of strings).
    Result is a dictionary with encoded query and link.
    &#34;&#34;&#34;
    from liquer.parser import encode

    query = encode(request.get_json(force=True)[&#34;ql&#34;])
    link = (
        get_vars().get(&#34;server&#34;, &#34;http://localhost&#34;)
        + get_vars().get(&#34;api_path&#34;, &#34;/q/&#34;)
        + query
    )
    return jsonify(dict(query=query, link=link, message=&#34;OK&#34;, status=&#34;OK&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_clean"><code class="name flex">
<span>def <span class="ident">cache_clean</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>interface to cache clean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/clean&#34;)
def cache_clean():
    &#34;&#34;&#34;interface to cache clean&#34;&#34;&#34;
    get_cache().clean()
    n = len(list(get_cache().keys()))
    keys = dict(status=&#34;OK&#34;, message=f&#34;Cache cleaned, {n} keys left&#34;)
    return jsonify(keys)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_contains"><code class="name flex">
<span>def <span class="ident">cache_contains</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>interface to cache contains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/contains/&lt;path:query&gt;&#34;)
def cache_contains(query):
    &#34;&#34;&#34;interface to cache contains&#34;&#34;&#34;
    contains = get_cache().contains(query)
    return jsonify(dict(query=query, cached=contains))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_get"><code class="name flex">
<span>def <span class="ident">cache_get</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cached data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/get/&lt;path:query&gt;&#34;)
def cache_get(query):
    &#34;&#34;&#34;Get cached data&#34;&#34;&#34;
    state = get_cache().get(query)
    if state is None:
        abort(404)
    return response(state)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_get_metadata"><code class="name flex">
<span>def <span class="ident">cache_get_metadata</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cached metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/meta/&lt;path:query&gt;&#34;)
def cache_get_metadata(query):
    &#34;&#34;&#34;Get cached metadata&#34;&#34;&#34;
    metadata = get_cache().get_metadata(query)
    if metadata == False:
        metadata = dict(query=query, status=&#34;not available&#34;, cached=False) # FIXME
    return jsonify(metadata)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_keys"><code class="name flex">
<span>def <span class="ident">cache_keys</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>interface to cache keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/keys.json&#34;)
def cache_keys():
    &#34;&#34;&#34;interface to cache keys&#34;&#34;&#34;
    keys = dict(keys=list(get_cache().keys()))
    return jsonify(keys)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_remove"><code class="name flex">
<span>def <span class="ident">cache_remove</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>interface to cache remove</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/remove/&lt;path:query&gt;&#34;)
def cache_remove(query):
    &#34;&#34;&#34;interface to cache remove&#34;&#34;&#34;
    r = get_cache().remove(query)
    return jsonify(dict(query=query, removed=r))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.cache_store_metadata"><code class="name flex">
<span>def <span class="ident">cache_store_metadata</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Store metadata in cache.
Allows to use liquer server as a remote cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/cache/meta/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def cache_store_metadata(query):
    &#34;&#34;&#34;Store metadata in cache.
    Allows to use liquer server as a remote cache.
    &#34;&#34;&#34;
    metadata = request.get_json(force=True)
    try:
        result_code = get_cache().store_metadata(metadata)
        result = dict(
            query=query, result=result_code, status=&#34;OK&#34;, message=&#34;OK&#34;, traceback=&#34;&#34;
        )
    except Exception as e:
        result = dict(
            query=query,
            result=False,
            status=&#34;ERROR&#34;,
            message=str(e),
            traceback=traceback.format_exc(),
        )

    return jsonify(result)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.commands"><code class="name flex">
<span>def <span class="ident">commands</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of commands in json format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/commands.json&#34;)
def commands():
    &#34;&#34;&#34;Returns a list of commands in json format&#34;&#34;&#34;
    return jsonify(command_registry().as_dict())</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.debug_json"><code class="name flex">
<span>def <span class="ident">debug_json</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Debug query - returns metadata from a state after a query is evaluated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/debug-json/&lt;path:query&gt;&#34;)
def debug_json(query):
    &#34;&#34;&#34;Debug query - returns metadata from a state after a query is evaluated&#34;&#34;&#34;
    state = evaluate(query)
    state_json = state.as_dict()
    return jsonify(state_json)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.detached_serve"><code class="name flex">
<span>def <span class="ident">detached_serve</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Main service for evaluating queries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/submit/&lt;path:query&gt;&#34;)
def detached_serve(query):
    &#34;&#34;&#34;Main service for evaluating queries&#34;&#34;&#34;
    from liquer.pool import evaluate_in_background

    evaluate_in_background(query)
    return jsonify(dict(status=&#34;OK&#34;, message=&#34;Submitted&#34;, query=query))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.get_stored_metadata"><code class="name flex">
<span>def <span class="ident">get_stored_metadata</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Get metadata stored in a store or cache</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/stored_metadata/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def get_stored_metadata(query):
    &#34;&#34;&#34;Get metadata stored in a store or cache&#34;&#34;&#34;
    import liquer.tools

    metadata = liquer.tools.get_stored_metadata(query)
    return jsonify(metadata)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Link to a LiQuer main service page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
@app.route(&#34;/index.html&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def index():
    &#34;&#34;&#34;Link to a LiQuer main service page&#34;&#34;&#34;
    return redirect(&#34;/liquer/static/index.html&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Info page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/info.html&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def info():
    &#34;&#34;&#34;Info page&#34;&#34;&#34;
    return &#34;&#34;&#34;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;LiQuer&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;LiQuer server&lt;/h1&gt;
        For more info, see the &lt;a href=&#34;https://github.com/orest-d/liquer&#34;&gt;repository&lt;/a&gt;.
    &lt;/body&gt;    
&lt;/html&gt;
&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.register_command"><code class="name flex">
<span>def <span class="ident">register_command</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Remote command registration service.
This has to be enabled by liquer.commands.enable_remote_registration()</p>
<p>WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
(e.g. on localhost or intranet where only trusted users have access).
This is on by default on Jupyter server extension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/register_command/&lt;data&gt;&#34;, methods=[&#34;GET&#34;])
def register_command(data):
    &#34;&#34;&#34;Remote command registration service.
    This has to be enabled by liquer.commands.enable_remote_registration()

    WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
    therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
    (e.g. on localhost or intranet where only trusted users have access).
    This is on by default on Jupyter server extension.
    &#34;&#34;&#34;
    return jsonify(command_registry().register_remote_serialized(data.encode(&#34;ascii&#34;)))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.register_command1"><code class="name flex">
<span>def <span class="ident">register_command1</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remote command registration service.
This has to be enabled by liquer.commands.enable_remote_registration()</p>
<p>WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
(e.g. on localhost or intranet where only trusted users have access).
This is on by default on Jupyter server extension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/register_command/&#34;, methods=[&#34;POST&#34;])
def register_command1():
    &#34;&#34;&#34;Remote command registration service.
    This has to be enabled by liquer.commands.enable_remote_registration()

    WARNING: Remote command registration allows to deploy arbitrary python code on LiQuer server,
    therefore it is a HUGE SECURITY RISK and it only should be used if other security measures are taken
    (e.g. on localhost or intranet where only trusted users have access).
    This is on by default on Jupyter server extension.
    &#34;&#34;&#34;
    data = request.get_data()
    return jsonify(command_registry().register_remote_serialized(data))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.response"><code class="name flex">
<span>def <span class="ident">response</span></span>(<span>state)</span>
</code></dt>
<dd>
<div class="desc"><p>Create flask response from a State</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response(state):
    &#34;&#34;&#34;Create flask response from a State&#34;&#34;&#34;
    b, mimetype, type_identifier = encode_state_data(
        state.get(), extension=state.extension
    )
    filename = state.metadata.get(&#34;filename&#34;)
    if filename is None:
        filename = state_types_registry().get(type_identifier).default_filename()
    r = make_response(b)

    r.headers.set(&#34;Content-Type&#34;, mimetype)
    if mimetype not in [
        &#34;application/json&#34;,
        &#34;text/plain&#34;,
        &#34;text/html&#34;,
        &#34;text/csv&#34;,
        &#34;image/png&#34;,
        &#34;image/svg+xml&#34;,
    ]:
        r.headers.set(&#34;Content-Disposition&#34;, &#34;attachment&#34;, filename=filename)
    return r</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Main service for evaluating queries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/q/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def serve(query):
    &#34;&#34;&#34;Main service for evaluating queries&#34;&#34;&#34;
    try:
        kwargs = request.get_json(force=True)
    except:
        kwargs = {}
    assert type(kwargs) == dict
    for k, v in request.args.items():
        kwargs[k] = v

    try:
        return response(evaluate(query, extra_parameters=kwargs))
    except:
        traceback.print_exc()
        abort(500)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_contains"><code class="name flex">
<span>def <span class="ident">store_contains</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/contains/&lt;path:query&gt;&#34;)
def store_contains(query):
    store = get_store()
    try:
        contains = store.contains(query)
        return jsonify(
            dict(
                query=query, message=f&#34;Contains {query}&#34;, contains=contains, status=&#34;OK&#34;
            )
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_get"><code class="name flex">
<span>def <span class="ident">store_get</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data from store. Equivalent to Store.get_bytes.
Content type (MIME) is obtained from the metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/data/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def store_get(query):
    &#34;&#34;&#34;Get data from store. Equivalent to Store.get_bytes.
    Content type (MIME) is obtained from the metadata.
    &#34;&#34;&#34;
    store = get_store()
    try:
        metadata = store.get_metadata(query)
        mimetype = metadata.get(&#34;mimetype&#34;, &#34;application/octet-stream&#34;)
        r = make_response(store.get_bytes(query))
        r.headers.set(&#34;Content-Type&#34;, mimetype)
        return r
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_get_metadata"><code class="name flex">
<span>def <span class="ident">store_get_metadata</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/metadata/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def store_get_metadata(query):
    store = get_store()
    metadata = store.get_metadata(query)
    return jsonify(metadata)</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_is_dir"><code class="name flex">
<span>def <span class="ident">store_is_dir</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/is_dir/&lt;path:query&gt;&#34;)
def store_is_dir(query):
    store = get_store()
    try:
        is_dir = store.is_dir(query)
        return jsonify(
            dict(
                query=query, message=f&#34;Is directory {query}&#34;, is_dir=is_dir, status=&#34;OK&#34;
            )
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_keys"><code class="name flex">
<span>def <span class="ident">store_keys</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/keys&#34;)
def store_keys():
    store = get_store()
    try:
        keys = store.keys()
        return jsonify(
            dict(query=None, message=f&#34;Keys obtained&#34;, keys=keys, status=&#34;OK&#34;)
        )
    except:
        return jsonify(dict(query=None, message=traceback.format_exc(), status=&#34;ERROR&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_listdir"><code class="name flex">
<span>def <span class="ident">store_listdir</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/listdir/&lt;path:query&gt;&#34;)
def store_listdir(query):
    store = get_store()
    try:
        listdir = store.listdir(query)
        return jsonify(
            dict(query=query, message=f&#34;Keys obtained&#34;, listdir=listdir, status=&#34;OK&#34;)
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_makedir"><code class="name flex">
<span>def <span class="ident">store_makedir</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/makedir/&lt;path:query&gt;&#34;)
def store_makedir(query):
    store = get_store()
    try:
        store.makedir(query)
        return jsonify(dict(query=query, message=f&#34;Makedir succeeded&#34;, status=&#34;OK&#34;))
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_remove"><code class="name flex">
<span>def <span class="ident">store_remove</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/remove/&lt;path:query&gt;&#34;)
def store_remove(query):
    store = get_store()
    try:
        store.remove(query)
        return jsonify(dict(query=query, message=f&#34;Removed {query}&#34;, status=&#34;OK&#34;))
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_removedir"><code class="name flex">
<span>def <span class="ident">store_removedir</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/removedir/&lt;path:query&gt;&#34;)
def store_removedir(query):
    store = get_store()
    try:
        store.removedir(query)
        return jsonify(
            dict(query=query, message=f&#34;Removed directory {query}&#34;, status=&#34;OK&#34;)
        )
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_set"><code class="name flex">
<span>def <span class="ident">store_set</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Set data in store. Equivalent to Store.store.
Unlike store method, which stores both data and metadata in one call,
the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
either before or after the api/store/data POST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/data/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def store_set(query):
    &#34;&#34;&#34;Set data in store. Equivalent to Store.store.
    Unlike store method, which stores both data and metadata in one call,
    the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
    either before or after the api/store/data POST.
    &#34;&#34;&#34;
    store = get_store()
    try:
        metadata = store.get_metadata(query)
    except KeyNotFoundStoreException:
        metadata = {}
        traceback.print_exc()
    try:
        data = request.get_data()
        store.store(query, data, metadata)
        return jsonify(dict(query=query, message=&#34;Data stored&#34;, status=&#34;OK&#34;))
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_set_metadata"><code class="name flex">
<span>def <span class="ident">store_set_metadata</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/metadata/&lt;path:query&gt;&#34;, methods=[&#34;POST&#34;])
def store_set_metadata(query):
    store = get_store()
    try:
        metadata = request.get_json(force=True)
        store.store_metadata(query, metadata)

        return jsonify(dict(query=query, message=&#34;Metadata stored&#34;, status=&#34;OK&#34;))
    except:
        response = jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )
        response.status = &#34;404&#34;
        return response</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.store_upload"><code class="name flex">
<span>def <span class="ident">store_upload</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload data to store - similar to /api/store/data, but using upload. Equivalent to Store.store.
Unlike store method, which stores both data and metadata in one call,
the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
either before or after the api/store/data POST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/api/store/upload/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;])
def store_upload(query):
    &#34;&#34;&#34;Upload data to store - similar to /api/store/data, but using upload. Equivalent to Store.store.
    Unlike store method, which stores both data and metadata in one call,
    the api/store/data POST only stores the data. The metadata needs to be set in a separate POST of api/store/metadata
    either before or after the api/store/data POST.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        if &#34;file&#34; not in request.files:
            response = jsonify(
                dict(
                    query=query,
                    message=&#34;Request does not contain &#39;file&#39;&#34;,
                    status=&#34;ERROR&#34;,
                )
            )
            response.status = &#34;404&#34;
            return response
        file = request.files[&#34;file&#34;]
        if file.filename == &#34;&#34;:
            response = jsonify(
                dict(
                    query=query,
                    message=&#34;Request contains &#39;file&#39; with an empty filename&#34;,
                    status=&#34;ERROR&#34;,
                )
            )
            response.status = &#34;404&#34;
            return response

        try:
            data = file.read()
        except:
            response = jsonify(
                dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
            )
            response.status = &#34;404&#34;
            return response
        store = get_store()
        try:
            metadata = store.get_metadata(query)
        except KeyNotFoundStoreException:
            metadata = {}
            traceback.print_exc()
        try:
            store.store(query, data, metadata)
            return jsonify(
                dict(query=query, message=&#34;Data stored&#34;, size=len(data), status=&#34;OK&#34;)
            )
        except:
            response = jsonify(
                dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
            )
            response.status = &#34;404&#34;
            return response

    r = make_response(
        f&#34;&#34;&#34;
    &lt;!doctype html&gt;
    &lt;title&gt;Upload File&lt;/title&gt;
    &lt;h1&gt;Upload to {query}&lt;/h1&gt;
    &lt;form method=&#34;post&#34; enctype=&#34;multipart/form-data&#34;&gt;
      &lt;input type=&#34;file&#34; name=&#34;file&#34;/&gt;
      &lt;input type=&#34;submit&#34; value=&#34;Upload&#34;/&gt;
    &lt;/form&gt;
    &#34;&#34;&#34;
    )

    r.headers.set(&#34;Content-Type&#34;, &#34;text/html&#34;)
    return r</code></pre>
</details>
</dd>
<dt id="liquer.server.blueprint.web_store_get"><code class="name flex">
<span>def <span class="ident">web_store_get</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to the 'web' directory in the store.
Similar to /store/data/web, except the index.html is automatically added if query is a directory.
The 'web' directory hosts web applications and visualization tools, e.g. liquer-pcv or liquer-gui.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#34;/web/&lt;path:query&gt;&#34;, methods=[&#34;GET&#34;])
def web_store_get(query):
    &#34;&#34;&#34;Shortcut to the &#39;web&#39; directory in the store.
    Similar to /store/data/web, except the index.html is automatically added if query is a directory.
    The &#39;web&#39; directory hosts web applications and visualization tools, e.g. liquer-pcv or liquer-gui.
    &#34;&#34;&#34;
    store = get_store()
    try:
        query = &#34;web/&#34; + query
        if query.endswith(&#34;/&#34;):
            query += &#34;index.html&#34;
        if store.is_dir(query):
            query += &#34;/index.html&#34;
        metadata = store.get_metadata(query)
        mimetype = metadata.get(&#34;mimetype&#34;, &#34;application/octet-stream&#34;)
        r = make_response(store.get_bytes(query))
        r.headers.set(&#34;Content-Type&#34;, mimetype)
        return r
    except:
        return jsonify(
            dict(query=query, message=traceback.format_exc(), status=&#34;ERROR&#34;)
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="liquer.server" href="index.html">liquer.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="liquer.server.blueprint.build" href="#liquer.server.blueprint.build">build</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_clean" href="#liquer.server.blueprint.cache_clean">cache_clean</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_contains" href="#liquer.server.blueprint.cache_contains">cache_contains</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_get" href="#liquer.server.blueprint.cache_get">cache_get</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_get_metadata" href="#liquer.server.blueprint.cache_get_metadata">cache_get_metadata</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_keys" href="#liquer.server.blueprint.cache_keys">cache_keys</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_remove" href="#liquer.server.blueprint.cache_remove">cache_remove</a></code></li>
<li><code><a title="liquer.server.blueprint.cache_store_metadata" href="#liquer.server.blueprint.cache_store_metadata">cache_store_metadata</a></code></li>
<li><code><a title="liquer.server.blueprint.commands" href="#liquer.server.blueprint.commands">commands</a></code></li>
<li><code><a title="liquer.server.blueprint.debug_json" href="#liquer.server.blueprint.debug_json">debug_json</a></code></li>
<li><code><a title="liquer.server.blueprint.detached_serve" href="#liquer.server.blueprint.detached_serve">detached_serve</a></code></li>
<li><code><a title="liquer.server.blueprint.get_stored_metadata" href="#liquer.server.blueprint.get_stored_metadata">get_stored_metadata</a></code></li>
<li><code><a title="liquer.server.blueprint.index" href="#liquer.server.blueprint.index">index</a></code></li>
<li><code><a title="liquer.server.blueprint.info" href="#liquer.server.blueprint.info">info</a></code></li>
<li><code><a title="liquer.server.blueprint.register_command" href="#liquer.server.blueprint.register_command">register_command</a></code></li>
<li><code><a title="liquer.server.blueprint.register_command1" href="#liquer.server.blueprint.register_command1">register_command1</a></code></li>
<li><code><a title="liquer.server.blueprint.response" href="#liquer.server.blueprint.response">response</a></code></li>
<li><code><a title="liquer.server.blueprint.serve" href="#liquer.server.blueprint.serve">serve</a></code></li>
<li><code><a title="liquer.server.blueprint.store_contains" href="#liquer.server.blueprint.store_contains">store_contains</a></code></li>
<li><code><a title="liquer.server.blueprint.store_get" href="#liquer.server.blueprint.store_get">store_get</a></code></li>
<li><code><a title="liquer.server.blueprint.store_get_metadata" href="#liquer.server.blueprint.store_get_metadata">store_get_metadata</a></code></li>
<li><code><a title="liquer.server.blueprint.store_is_dir" href="#liquer.server.blueprint.store_is_dir">store_is_dir</a></code></li>
<li><code><a title="liquer.server.blueprint.store_keys" href="#liquer.server.blueprint.store_keys">store_keys</a></code></li>
<li><code><a title="liquer.server.blueprint.store_listdir" href="#liquer.server.blueprint.store_listdir">store_listdir</a></code></li>
<li><code><a title="liquer.server.blueprint.store_makedir" href="#liquer.server.blueprint.store_makedir">store_makedir</a></code></li>
<li><code><a title="liquer.server.blueprint.store_remove" href="#liquer.server.blueprint.store_remove">store_remove</a></code></li>
<li><code><a title="liquer.server.blueprint.store_removedir" href="#liquer.server.blueprint.store_removedir">store_removedir</a></code></li>
<li><code><a title="liquer.server.blueprint.store_set" href="#liquer.server.blueprint.store_set">store_set</a></code></li>
<li><code><a title="liquer.server.blueprint.store_set_metadata" href="#liquer.server.blueprint.store_set_metadata">store_set_metadata</a></code></li>
<li><code><a title="liquer.server.blueprint.store_upload" href="#liquer.server.blueprint.store_upload">store_upload</a></code></li>
<li><code><a title="liquer.server.blueprint.web_store_get" href="#liquer.server.blueprint.web_store_get">web_store_get</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>