<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>liquer.parser API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>liquer.parser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from urllib.parse import quote, unquote
import re
from pyparsing import (
    Literal,
    Word,
    alphas,
    alphanums,
    nums,
    delimitedList,
    Regex,
    OneOrMore,
    Group,
    Combine,
    ZeroOrMore,
    Optional,
    Forward,
    lineno,
    col,
    FollowedBy,
)

&#34;&#34;&#34;
This module provides functions to decode and encode query.
A query is a sequence of commands, each command being a list of strings starting with the command name as a first element.
Commands are separated by a COMMAND_SEPARATOR, parts of the command (tokens) by PARAMETER_SEPARATOR.
Having special charachers (like COMMAND_SEPARATOR or PARAMETER_SEPARATOR) inside the commands is possible
by escaping with ESCAPE character and using escape sequences.
Query is URL-safe and URL escaping is applied to other special characters.
Empty commands are ignored (e.g. two consecutive COMMAND_SEPARATORs are equivalent to a single COMMAND_SEPARATOR).

Query can be decoded from string to a list of lists of strings by decode (or encoded by encode).
Encode and decode use encode_token and decode_token that are acting on a token level.
&#34;&#34;&#34;

COMMAND_SEPARATOR = &#34;/&#34;
PARAMETER_SEPARATOR = &#34;-&#34;
ESCAPE = &#34;~&#34;
ESCAPE_SEQUENCES = [
    (ESCAPE, ESCAPE + ESCAPE),
    (&#34;https://&#34;, ESCAPE + &#34;H&#34;),
    (&#34;http://&#34;, ESCAPE + &#34;h&#34;),
    (&#34;file://&#34;, ESCAPE + &#34;f&#34;),
    (&#34;://&#34;, ESCAPE + &#34;P&#34;),
    (COMMAND_SEPARATOR, ESCAPE + &#34;I&#34;),
    (PARAMETER_SEPARATOR, ESCAPE + &#34;_&#34;),
    (&#34; &#34;, ESCAPE + &#34;.&#34;),
]


def decode(query: str):
    &#34;&#34;&#34;Decode query string into a list of lists of strings.&#34;&#34;&#34;
    ql = [
        [decode_token(etoken) for etoken in eqv.split(PARAMETER_SEPARATOR)]
        for eqv in query.split(COMMAND_SEPARATOR)
    ]
    return [qcommand for qcommand in ql if len(qcommand) and len(qcommand[0])]


def encode_token(token: str):
    &#34;Encode single token by escaping special characters and character sequences&#34;
    for sequence, encoding in ESCAPE_SEQUENCES:
        token = token.replace(sequence, encoding)
    return quote(token).replace(&#34;%7E&#34;, &#34;~&#34;).replace(&#34;%7e&#34;, &#34;~&#34;)


def decode_token(token: str):
    &#34;Decode single token by un-escaping special characters and character sequences&#34;
    encoding = {e: s for s, e in ESCAPE_SEQUENCES}
    if token == &#34;&#34;:
        return &#34;&#34;
    try:
        index = token.index(ESCAPE)
        head = token[:index]
        mid = token[index : index + 2]
        tail = token[index + 2 :]
        return unquote(head + encoding.get(mid, mid)) + decode_token(tail)
    except ValueError:
        return unquote(token)


def encode(ql: list):
    &#34;&#34;&#34;Decode query list (list of lists of strings) into an properly escaped query string.&#34;&#34;&#34;
    return COMMAND_SEPARATOR.join(
        PARAMETER_SEPARATOR.join(encode_token(token) for token in qv) for qv in ql
    )


def all_splits(query):
    &#34;&#34;&#34;Make all splits of the query into two parts (biginning and remainder)
    by progressively increasing the remainder.
    query == beginning + COMMAND_SEPARATOR + remainder
    &#34;&#34;&#34;
    ql = decode(query)
    for i in range(len(ql), -1, -1):
        yield encode(ql[:i]), encode(ql[i:])


def indent(text, prefix=&#34;  &#34;):
    return &#34;\n&#34;.join(prefix + x for x in text.split(&#34;\n&#34;))


def list_indent(lst, prefix=&#34;  &#34;):
    if len(lst):
        return &#34;[\n&#34; + &#34;,\n&#34;.join(indent(repr(x), prefix) for x in lst) + &#34;\n]&#34;
    else:
        return &#34;[]&#34;


class Position:
    def __init__(self, offset=0, line=0, column=0):
        self.offset = offset
        self.line = line
        self.column = column

    @classmethod
    def from_loc(cls, loc, string):
        return cls(loc, line=lineno(loc, string), column=col(loc, string))

    @classmethod
    def from_dict(cls, d):
        if d is None:
            return cls()
        else:
            return cls(offset=d[&#34;offset&#34;], line=d[&#34;line&#34;], column=d[&#34;column&#34;])

    def to_dict(self):
        return dict(offset=self.offset, line=self.line, column=self.column)

    def __str__(self):
        if self.line == 0:
            return &#34;(unknown position)&#34;
        elif self.line &gt; 1:
            return f&#34;line {self.line}, position {self.column}&#34;
        else:
            return f&#34;position {self.column}&#34;

    def __repr__(self):
        if self.line == 0:
            return &#34;Position()&#34;
        return f&#34;Position(offset={self.offset}, line={self.line}, column={self.column})&#34;


class QueryException(Exception):
    def __init__(self, message, position=None, query=None):
        self.original_message = message
        if position is not None:
            message += f&#34; at {position}&#34;
            if query is not None:
                message += f&#34;:\n  query: {query[:position.offset]}\n     {&#39; &#39;*position.offset}--&gt; {query[position.offset:]}&#34;
        else:
            if query is not None:
                message += f&#34;:\n  query: {query}&#34;

        super().__init__(message)
        self.position = position
        self.query = query


class ActionParameter(object):
    def __init__(self, position=None):
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        return self

    def __repr__(self):
        return f&#34;{self.__class__.__name__}({repr(self.position)})&#34;

    def __str__(self):
        return f&#34;{self.__class__.__name__} at {self.position}&#34;


class LinkActionParameter(ActionParameter):
    def __init__(self, link, position=None):
        super().__init__(position)
        self.link = link

    def encode(self):
        return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;

    def __repr__(self):
        return f&#34;&#34;&#34;LinkActionParameter(
{indent(repr(self.link))},
  {repr(self.position)})&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


class ExpandedActionParameter(ActionParameter):
    def __init__(self, value, link, position=None):
        super().__init__(position)
        self.value = value
        self.link = link

    def encode(self):
        return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;

    def __repr__(self):
        return f&#34;&#34;&#34;ExpandedActionParameter(
{indent(repr(self.value))}
{indent(repr(self.link))},
  {repr(self.position)})&#34;&#34;&#34;

    def __str__(self):
        return str(self.value)


class StringActionParameter(ActionParameter):
    def __init__(self, string: str, position=None):
        super().__init__(position)
        self.string = string

    def encode(self):
        #        encoded = self.string.replace(&#34;~&#34;,&#34;~~&#34;).replace(&#34;/&#34;,&#34;~/&#34;).replace(&#34;://&#34;,&#34;~P&#34;)
        encoded = encode_token(self.string)
        return encoded

    def __repr__(self):
        return f&#34;StringActionParameter({repr(self.string)}, {repr(self.position)})&#34;

    def __str__(self):
        return self.string


class ResourceName(ActionParameter):
    def __init__(self, name: str, position=None):
        self.position = position or Position()
        self.name = name

    def encode(self):
        return self.name

    def __repr__(self):
        return f&#34;ResourceName({repr(self.name)}, {repr(self.position)})&#34;

    def __str__(self):
        return self.encode()


class ActionRequest(object):
    def __init__(self, name: str, parameters=None, position=None):
        self.name = name
        self.parameters = [] if parameters is None else parameters
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        for p in self.parameters:
            p.clean_position()
        return self

    @classmethod
    def from_arguments(cls, name: str, *parameters):
        assert type(name) == str
        typedparam = []
        for p in parameters:
            if isinstance(p, ActionParameter):
                typedparam.append(p)
            else:
                assert type(p) in (str, int, float, bool)
                typedparam.append(StringActionParameter(str(p)))

        return cls(name, typedparam)

    def to_list(self):
        lst = [self.name]
        for x in self.parameters:
            if isinstance(x, StringActionParameter):
                lst.append(x.string)
            elif isinstance(x, LinkActionParameter):
                lst.append(x.encode())
            else:
                raise Exception(
                    f&#34;Unsupported action parameter type: {type(x)} ({repr(x)})&#34;
                )
        return lst

    @classmethod
    def from_list(cls, lst):
        return cls.from_arguments(lst[0], *lst[1:])

    def encode(self):
        if len(self.parameters):
            p = &#34;-&#34;.join(x.encode() for x in self.parameters)
            return f&#34;{self.name}-{p}&#34;
        else:
            return self.name

    def __repr__(self):
        return f&#34;&#34;&#34;ActionRequest(
  {repr(self.name)},
{indent(list_indent(self.parameters))},
  {repr(self.position)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


class SegmentHeader(object):
    &#34;&#34;&#34;Header of a query segment - both resource and transformation query.
    Header may contain name (string), level (integer) and parameters (list of strings).
    The header parameters may influence how the query is interpreted.
    The interpretation of the header parameters depends on the context object.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str = &#34;&#34;,
        level: int = 1,
        parameters: list = None,
        resource: bool = False,
        position=None,
    ):
        self.name = name
        self.level = level
        self.parameters = parameters or []
        self.resource = resource
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        for p in self.parameters:
            p.clean_position()
        return self

    def is_trivial(self):
        &#34;&#34;&#34;Terurns true if the header does not contain any data,
        I.e. trivial header has no name, level is 1 and no parameters.
        Trivial header can be both for resource and query, it does not depend on the resource flas.
        &#34;&#34;&#34;
        return self.name in (&#34;&#34;, None) and self.level == 1 and len(self.parameters) == 0

    def encode(self):
        assert self.level &gt;= 1
        encoded = &#34;-&#34; * self.level
        if self.resource:
            encoded += &#34;R&#34;
        encoded += self.name
        if len(self.parameters):
            assert len(self.name) &gt; 0 or self.resource
            for parameter in self.parameters:
                encoded += &#34;-&#34;
                encoded += parameter.encode()
        return encoded

    def __repr__(self):
        return f&#34;&#34;&#34;SegmentHeader(
  name       ={repr(self.name)},
  level      ={self.level},
  parameters ={indent(list_indent(self.parameters))},
  resource   ={self.resource},
  position   ={repr(self.position)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


class TransformQuerySegment(object):
    &#34;&#34;&#34;Query segment representing a transformation, i.e. a sequence of actions applied to a state.&#34;&#34;&#34;

    def __init__(self, header=None, query=None, filename=None):
        &#34;header can be SegmentHeader, query is a list of ActionRequest objects&#34;
        self.header = header
        self.query = query or []
        self.filename = filename

    def clean_position(self):
        if self.header is not None:
            self.header.clean_position()
        for a in self.query:
            a.clean_position()
        try:
            self.filename.clean_position()
        except:
            pass

        return self

    def predecessor(self):
        if self.filename is None:
            if len(self.query):
                p = TransformQuerySegment(
                    header=self.header, query=self.query[:-1], filename=None
                )
                r = TransformQuerySegment(
                    header=self.header, query=[self.query[-1]], filename=None
                )
                return p, r
            else:
                return None, None
        else:
            p = TransformQuerySegment(
                header=self.header, query=self.query, filename=None
            )
            r = TransformQuerySegment(
                header=self.header, query=[], filename=self.filename
            )
            return p, r

    def is_empty(self):
        return len(self.query) == 0 and self.filename is None

    def is_filename(self):
        return len(self.query) == 0 and self.filename is not None

    def is_action_request(self):
        return len(self.query) == 1 and self.filename is None

    def action(self):
        if self.is_action_request():
            return self.query[0]
        else:
            return None

    def encode(self):
        query = &#34;/&#34;.join(x.encode() for x in self.query)
        if self.filename is not None:
            query = f&#34;{query}/{self.filename}&#34; if len(query) else self.filename

        if self.header is None:
            return query
        else:
            if len(query):
                return f&#34;{self.header.encode()}/{query}&#34;
            else:
                return self.header.encode()

    def append(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            self.query.extend(q.query)
            self.filename = q.filename
            return self
        if isinstance(q, Query):
            if q.is_transform_query():
                return self.append(q.segments[0])
            else:
                raise Exception(
                    f&#34;Appending general query {q} to transform query {self.encode()} not supported&#34;
                )
        if isinstance(q, ActionRequest):
            self.query.append(q)
            return self
        if isinstance(q, str):
            return self.append(parse(q))

        raise Exception(
            f&#34;Transform query {self.encode()} can&#39;t append object {repr(q)}&#34;
        )

    def __add__(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            return TransformQuerySegment(
                header=self.header, query=self.query + q.query, filename=q.filename
            )

        raise Exception(f&#34;Unsupported operation (add): {self.encode()} + {repr(q)}&#34;)

    def __radd__(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            return q + self
        raise Exception(f&#34;Unsupported operation (radd): {repr(q)} + {self.encode()}&#34;)

    def __repr__(self):
        return f&#34;&#34;&#34;TransformQuerySegment(
  header   = {indent(repr(self.header))},
  query    = {indent(list_indent(self.query))},
  filename = {repr(self.filename)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


class ResourceQuerySegment(object):
    &#34;&#34;&#34;Query segment representing a resource, i.e. path to a file in a store.&#34;&#34;&#34;

    def __init__(self, header=None, query=None):
        &#34;header can be SegmentHeader, query is a list of ActionRequest objects&#34;
        self.header = header
        self.query = query or []

    def segment_name(self):
        if self.header is None:
            return &#34;&#34;
        else:
            return self.header.name

    def clean_position(self):
        if self.header is not None:
            self.header.clean_position()
        for a in self.query:
            a.clean_position()
        return self

    @property
    def position(self):
        if self.header is not None:
            return self.header.position
        else:
            if len(self.query):
                return self.query[0].position

    def path(self):
        &#34;&#34;&#34;Path to the resource as a string.
        This is typically interpreted as a resource key in a Store object.&#34;&#34;&#34;
        return &#34;/&#34;.join(x.encode() for x in self.query)

    def encode(self):
        query = self.path()
        if self.header is None:
            rqs = &#34;&#34;
        else:
            rqs = self.header.encode()
        if len(rqs):
            rqs += &#34;/&#34;
        if len(query):
            return f&#34;{rqs}{query}&#34;
        else:
            return rqs

    def _query_to_absolute(self, path, processed, rest):
        if len(rest) == 0:
            return processed
        if rest[0].encode() == &#34;.&#34;:
            if len(processed) == 0:
                return self._query_to_absolute(path, path[:], rest[1:])
            else:
                return self._query_to_absolute(path, processed, rest[1:])

        if rest[0].encode() == &#34;..&#34;:
            if len(processed) == 0:
                if len(path) == 0:
                    raise Exception(&#34;Can&#39;t go up from root&#34;)
                return self._query_to_absolute(path, path[:-1], rest[1:])
            else:
                return self._query_to_absolute(path, processed[:-1], rest[1:])
        return self._query_to_absolute(path, processed + [rest[0]], rest[1:])

    def to_absolute(self, path):
        &#34;&#34;&#34;Convert relative path to absolute path.
        Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
        Resource segment header stays unchanged.
        Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
        Path may be a string or a ResourceQuerySegment.
        &#34;&#34;&#34;
        if isinstance(path, str):
            if len(path) == 0:
                path = []
            else:
                path = list(resource_path.parseString(path, True))
                for s in path:
                    s.clean_position()
        canonical_path = []

        if self.query is None or len(self.query) == 0:
            return self
        return ResourceQuerySegment(
            header=self.header, query=self._query_to_absolute(path, [], self.query)
        )

    def __repr__(self):
        return f&#34;&#34;&#34;ResourceQuerySegment(
  header = {indent(repr(self.header))},
  query  = {indent(list_indent(self.query))}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


class Query(object):
    &#34;&#34;&#34;Query is a sequence of query segment.
    Typically this will be a resource and and/or a transformation applied to a resource.&#34;&#34;&#34;

    def __init__(self, segments: list = None, absolute=False):
        self.segments = segments or []
        self.absolute = absolute

    def clean_position(self):
        for s in self.segments:
            s.clean_position()
        return self

    def filename(self):
        &#34;Return filename if present, None otherwise.&#34;
        if len(self.segments):
            segment = self.segments[-1]
            if (
                isinstance(segment, TransformQuerySegment)
                and segment.filename is not None
            ):
                return str(segment.filename)
            if (
                isinstance(segment, ResourceQuerySegment)
                and segment.query is not None
                and len(segment.query)
            ):
                return str(segment.query[-1])
        return None

    def without_filename(self):
        &#34;&#34;&#34;Query without the filename.&#34;&#34;&#34;
        if self.filename() is None:
            return self
        else:
            p, _ = self.predecessor()
            return p

    def extension(self):
        &#34;Return file extension if present, None otherwise.&#34;
        filename = self.filename()
        if filename is not None:
            v = filename.split(&#34;.&#34;)
            if len(v) &gt; 1:
                return v[-1]
        return None

    def is_empty(self):
        &#34;Returns true if the query is empty, i.e. has no segments and thus is equivalent to an empty string.&#34;
        return len(self.segments) == 0

    def is_transform_query(self):
        &#34;Returns true if the query is a pure transformation query - i.e. a sequence of actions.&#34;
        return len(self.segments) == 1 and isinstance(
            self.segments[0], TransformQuerySegment
        )

    def transform_query(self):
        &#34;Returns TransformQuerySegment if the query is a pure transformation query, None otherwise.&#34;
        if self.is_transform_query():
            return self.segments[0]
        else:
            return None

    def is_resource_query(self):
        &#34;Returns true if the query is a pure resource query - i.e. a store key with an optional header (-R).&#34;
        return len(self.segments) == 1 and isinstance(
            self.segments[0], ResourceQuerySegment
        )

    def resource_query(self):
        &#34;Returns ResourceQuerySegment if the query is a pure resource query, None otherwise.&#34;
        if self.is_resource_query():
            return self.segments[0]
        else:
            return None

    def is_action_request(self):
        &#34;Returns true if the query is a single action request.&#34;
        return self.is_transform_query() and self.segments[0].is_action_request()

    def action(self):
        &#34;Returns ActionRequest if the query is a single action request, None otherwise.&#34;
        if self.is_action_request():
            return self.segments[0].action()
        else:
            return None

    def predecessor(self):
        &#34;&#34;&#34;Return tuple of (predecessor, remainder).
        Remainder is a last element (action or filename) or None if not available.
        Predecessor is a query without the remainder (or None).
        &#34;&#34;&#34;
        if len(self.segments):
            if isinstance(self.segments[-1], TransformQuerySegment):
                p, r = self.segments[-1].predecessor()
                if p is None or p.is_empty():
                    qp = Query(self.segments[:-1], absolute=self.absolute)
                    qr = r
                    return qp, qr
                else:
                    qp = Query(self.segments[:-1] + [p], absolute=self.absolute)
                    qr = r
                    return qp, qr
            else:
                return None, None
        else:
            return None, None

    def short(self, n=30):
        &#34;&#34;&#34;Make a shortened version of the at most n characters (30) of a query for printout purposes.&#34;&#34;&#34;
        _, r = self.predecessor()
        if r is None:
            q = str(self)
            if len(self) &gt; n:
                q = &#34;...&#34; + q[-n:]
            return q
        else:
            return str(r)

    def all_predecessors(self):
        &#34;&#34;&#34;Iterate over all predecessors.
        Iterator yields (predecessor, remainder) tuples from the full query (query, None)
        removing remainders in each step until there is no predecessor left.
        &#34;&#34;&#34;
        qp, qr = self, None
        while qp is not None:
            yield qp, qr
            qp, r = qp.predecessor()
            qr = r + qr

    def create_segment(self, name: str = &#34;&#34;, level=1):
        qs = TransformQuerySegment(SegmentHeader(name, level=level))
        self.segments.append(qs)
        return qs

    def last_transform_query_segment(self):
        if not self.is_empty():
            if isinstance(self.segments[-1], TransformQuerySegment):
                return self.segments[-1]
        return self.create_segment()

    def with_action(self, name: str, *parameters):
        self.last_transform_query_segment().append(
            ActionRequest.from_arguments(name, *parameters)
        )
        return self

    def __add__(self, tq):
        assert isinstance(tq, TransformQuerySegment)
        return Query(self.segments + [tq], absolute=self.absolute)

    def encode(self):
        q = &#34;/&#34;.join(x.encode() for x in self.segments)
        if self.is_resource_query():
            if not q.startswith(&#34;-&#34;):
                q = &#34;-R/&#34; + q
        if self.absolute:
            q = &#34;/&#34; + q
        return q

    def to_absolute(self, path, resource_segment_name=&#34;&#34;):
        &#34;&#34;&#34;Convert relative path to absolute path in the selected resource.
        Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
        Everything else besides selected resources stays unchanged.
        Resources are selected by resource_segment_name (default is the unnamed default resource).
        None resource_segment_name means all resources.
        Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
        Path may be a string or a ResourceQuerySegment.
        &#34;&#34;&#34;
        segments = []
        for s in self.segments:
            if isinstance(s, TransformQuerySegment):
                segments.append(s)
            elif isinstance(s, ResourceQuerySegment):
                if (
                    resource_segment_name is None
                    or resource_segment_name == s.segment_name()
                ):
                    segments.append(s.to_absolute(path))
                else:
                    segments.append(s)
            else:
                raise ValueError(f&#34;Unknown segment type {type(s)}&#34;)
        return Query(segments, absolute=self.absolute)

    def __repr__(self):
        return f&#34;&#34;&#34;Query(
{indent(list_indent(self.segments))},
  absolute = {self.absolute}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()


identifier = Regex(&#34;[a-z_][a-zA-Z0-9_]*&#34;).setName(&#34;identifier&#34;)
filename = Regex(r&#34;[a-zA-Z0-9_]*\.[a-zA-Z0-9._-]*&#34;).setName(&#34;filename&#34;)


def _resource_name_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    name = unquote(&#34;&#34;.join(toks))
    return ResourceName(name, position=position)


resource_name = (
    Regex(r&#34;[a-zA-Z0-9._][a-zA-Z0-9._-]*&#34;)
    .setParseAction(_resource_name_parse_action)
    .setName(&#34;resource_name&#34;)
)
parameter_text = Regex(&#34;[a-zA-Z0-9_+.]+&#34;).setName(&#34;parameter_text&#34;)
percent_encoding = Regex(&#34;%[0-9a-fA-F][0-9a-fA-F]&#34;).setName(&#34;percent_encoding&#34;)
parse_query = Forward()

tilde_entity = (
    Literal(&#34;~~&#34;).setParseAction(lambda s, loc, toks: [&#34;~&#34;]).setName(&#34;tilde_entity&#34;)
)
minus_entity = (
    Literal(&#34;~_&#34;).setParseAction(lambda s, loc, toks: [&#34;-&#34;]).setName(&#34;minus_entity&#34;)
)
islash_entity = (
    Literal(&#34;~I&#34;).setParseAction(lambda s, loc, toks: [&#34;/&#34;]).setName(&#34;islash_entity&#34;)
)
slash_entity = (
    Literal(&#34;~/&#34;).setParseAction(lambda s, loc, toks: [&#34;/&#34;]).setName(&#34;slash_entity&#34;)
)

https_entity = (
    Literal(&#34;~H&#34;)
    .setParseAction(lambda s, loc, toks: [&#34;https://&#34;])
    .setName(&#34;https_entity&#34;)
)
http_entity = (
    Literal(&#34;~h&#34;)
    .setParseAction(lambda s, loc, toks: [&#34;http://&#34;])
    .setName(&#34;http_entity&#34;)
)
file_entity = (
    Literal(&#34;~f&#34;)
    .setParseAction(lambda s, loc, toks: [&#34;file://&#34;])
    .setName(&#34;file_entity&#34;)
)
protocol_entity = (
    Literal(&#34;~P&#34;)
    .setParseAction(lambda s, loc, toks: [&#34;://&#34;])
    .setName(&#34;protocol_entity&#34;)
)

negative_number_entity = (
    Regex(&#34;~[0-9]&#34;)
    .setParseAction(lambda s, loc, toks: [&#34;-&#34; + toks[0][1:]])
    .setName(&#34;negative_number_entity&#34;)
)
space_entity = (
    Literal(&#34;~.&#34;).setParseAction(lambda s, loc, toks: [&#34; &#34;]).setName(&#34;space_entity&#34;)
)
end_entity = Literal(&#34;~E&#34;)


def _expand_entity_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    return LinkActionParameter(toks[0], position=position)


expand_entity = (
    (Literal(&#34;~X~&#34;).suppress() + parse_query + end_entity.suppress())
    .setParseAction(_expand_entity_parse_action)
    .setName(&#34;expand_entity&#34;)
)

entities = (
    tilde_entity
    | minus_entity
    | negative_number_entity
    | space_entity
    | islash_entity
    | slash_entity
    | http_entity
    | https_entity
    | file_entity
    | protocol_entity
)


def _parameter_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    par = unquote(&#34;&#34;.join(toks))
    return StringActionParameter(par, position=position)


parameter = expand_entity | (
    ZeroOrMore(parameter_text | entities | percent_encoding)
    .setParseAction(_parameter_parse_action)
    .setName(&#34;parameter&#34;)
)


def _action_request_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    name = toks[0]
    parameters = list(toks[1:])
    return ActionRequest(name=name, parameters=parameters, position=position)


action_request = (
    (identifier + ZeroOrMore(Literal(&#34;-&#34;).suppress() + parameter))
    .setParseAction(_action_request_parse_action)
    .setName(&#34;action_request&#34;)
)


def _action_path_parse_action(s, loc, toks):
    ap = list(toks)
    if type(ap[-1]) is str:
        return (ap[:-1], ap[-1])
    else:
        return (ap, None)


# segment_indicator = (
#    OneOrMore(Literal(&#34;-&#34;))
#    .setParseAction(lambda s, loc, toks: len(toks))
#    .setName(&#34;segment_indicator&#34;)
# )


def _segment_identifier_action(s, loc, toks):
    m = re.match(&#34;(-+)([a-zA-Z0-9_]*)&#34;, toks[0])
    assert m is not None
    return len(m.group(1)), m.group(2)


segment_identifier = (
    (Regex(&#34;-+[a-z][a-zA-Z0-9_]*&#34;) | (Regex(&#34;-+&#34;) + FollowedBy(&#34;/&#34;)))
    .setParseAction(_segment_identifier_action)
    .setName(&#34;segment_identifier&#34;)
)


def _resource_identifier_action(s, loc, toks):
    m = re.match(&#34;(-+)R([a-zA-Z0-9_]*)&#34;, toks[0])
    assert m is not None
    return len(m.group(1)), m.group(2)


resource_identifier = (
    (Regex(&#34;-+R[a-zA-Z0-9_]*&#34;))
    .setParseAction(_resource_identifier_action)
    .setName(&#34;resource_identifier&#34;)
)

action_path_nonempty = (
    (
        (
            ZeroOrMore(
                action_request
                + (
                    Literal(&#34;/&#34;) + ~(resource_identifier | segment_identifier)
                ).suppress()
            )
            + (filename | action_request)
        )
    )
    .setParseAction(_action_path_parse_action)
    .setName(&#34;action_path_nonempty&#34;)
)


def _resource_path_parse_action(s, loc, toks):
    return list(toks)


resource_path = (
    delimitedList(resource_name, delim=&#34;/&#34;)
    .setParseAction(_resource_path_parse_action)
    .setName(&#34;resource_path&#34;)
)


def _segment_header_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    level, name = toks[0]
    if len(toks) &gt; 1:
        parameters = list(toks[1:])
        return SegmentHeader(
            name=name, level=level, parameters=parameters, position=position
        )
    else:
        return SegmentHeader(level=level, name=name)


segment_header = (
    (segment_identifier + ZeroOrMore(Literal(&#34;-&#34;).suppress() + parameter))
    .setParseAction(_segment_header_parse_action)
    .setName(&#34;segment_header&#34;)
)


def _resource_segment_with_header_parse_action(s, loc, toks):
    position = Position.from_loc(loc, s)
    level, name = toks[0]
    header = SegmentHeader(
        name=name,
        level=level,
        parameters=list(toks[1]),
        resource=True,
        position=position,
    )
    if len(toks) == 3:
        return ResourceQuerySegment(header=header, query=list(toks[2]))
    else:
        return ResourceQuerySegment(header=header, query=[])


resource_segment_with_header = (
    (
        resource_identifier
        + Group(ZeroOrMore(Word(&#34;-&#34;).suppress() + parameter))
        + Optional(Literal(&#34;/&#34;).suppress() + Group(resource_path))
    )
    .setParseAction(_resource_segment_with_header_parse_action)
    .setName(&#34;resource_segment_with_header&#34;)
)


def _segment_with_header_parse_action(s, loc, toks):
    if len(toks) == 1:
        return TransformQuerySegment(header=toks[0])
    else:
        assert len(toks) == 3
        return TransformQuerySegment(
            header=toks[0], query=toks[2][0][0], filename=toks[2][0][1]
        )


segment_with_header = (
    (segment_header + Optional(Literal(&#34;/&#34;) + Group(action_path_nonempty)))
    .setParseAction(_segment_with_header_parse_action)
    .setName(&#34;segment_with_header&#34;)
)


def _segment_without_header_parse_action(s, loc, toks):
    return TransformQuerySegment(query=list(toks[0][0][0]), filename=toks[0][0][1])


segment_without_header = (
    Group(action_path_nonempty)
    .setParseAction(_segment_without_header_parse_action)
    .setName(&#34;segment_without_header&#34;)
)

query_segment = (
    segment_with_header | segment_without_header | resource_segment_with_header
).setName(&#34;query_segment&#34;)


def _parse_query_parse_action(s, loc, toks):
    if toks[0] == &#34;/&#34;:
        return Query(segments=list(toks[1:]), absolute=True)
    else:
        return Query(segments=list(toks), absolute=False)


parse_query &lt;&lt; (
    (Optional(Literal(&#34;/&#34;)) + delimitedList(query_segment, &#34;/&#34;))
    .setParseAction(_parse_query_parse_action)
    .setName(&#34;parse_query&#34;)
)


def _resource_transform_query_action(s, loc, toks):
    if toks[0] == &#34;/&#34;:
        assert len(toks) == 3
        resource = ResourceQuerySegment(query=list(toks[1]))
        transform = toks[2]
        return Query(segments=[resource, transform], absolute=True)
    else:
        assert len(toks) == 2
        resource = ResourceQuerySegment(query=list(toks[0]))
        transform = toks[1]
        return Query(segments=[resource, transform], absolute=False)


resource_transform_query = (
    (
        Optional(Literal(&#34;/&#34;))
        + Group(resource_path)
        + Literal(&#34;/&#34;).suppress()
        + segment_with_header
    )
    .setParseAction(_resource_transform_query_action)
    .setName(&#34;resource_transform_query&#34;)
)


def parse(query):
    try:
        return resource_transform_query.parseString(query, True)[0]
    except:
        return parse_query.parseString(query, True)[0]


if __name__ == &#34;__main__&#34;:
    #    print(action_path_nonempty.parseString(&#34;abc/def/file.txt&#34;, True))
    #    print(query_segment.parseString(&#34;abc/def/file.txt&#34;, True))
    # print(resource_path.parseString(&#34;abc/def/file.txt&#34;, True))
    #    print(query_segment.parseString(&#34;-qs/abc/def/file.txt&#34;, True))
    #    print(parse_query.parseString(&#34;abc/def/file.txt&#34;, True))
    #    print(parse_query.parseString(&#34;-/abc/def/file.txt&#34;, True))
    #    print(parse_query.parseString(&#34;-qs/abc/def/file.txt&#34;, True))
    #    print(parse_query.parseString(&#34;-/xxx&#34;, True))
    #    print(parse_query.parseString(&#34;abc/def/-/xxx&#34;, True))
    #    print(parse_query.parseString(&#34;abc/def/-/xxx/file.txt&#34;, True))
    #    print(repr(parse(&#34;abc/def/-/xxx/file.txt&#34;)))
    #    print(repr(parse(&#34;abc/def&#34;)))

    #    print(parse(&#34;abc-def/-/x-y/--xxx-y/aaa&#34;))
    #    print(repr(parse(&#34;/abc-def/-/x-y/--xxx-y/aaa&#34;)))
    #    print(resource_segment_with_header.parseString(&#34;-R/abc/def&#34;))
    # print(resource_segment_with_header.parseString(&#34;-R-1-2/&#34;))
    print(repr(parse(&#34;-R/abc/def/-/ghi&#34;)))
    print((parse(&#34;-R/abc/def/-/ghi&#34;)))
    print()
    for p, r in parse(&#34;-R/abc/def/-/ghi/jkl/file.txt&#34;).all_predecessors():
        print(p.encode(), &#34;   -   &#34;, &#34;NONE&#34; if r is None else r.encode())
    #    print(parse(&#34;abc/xxx/-/def&#34;))
    #    print(repr(parse(&#34;-/def&#34;)))
    #    print(repr(parse(&#34;def&#34;)))
    #    print(repr(action_path_nonempty.parseString(&#34;abc&#34;, True)))
    #    print(repr(expand_entity.parseString(&#34;~X~abc~E&#34;, True)))
    #    print(repr(parse(&#34;-/def-~X~abc~E&#34;)))
    print(parse(&#34;abc/def/-/xxx/-q/qqq&#34;))
    print(parse(&#34;abc/def/-/xxx/-q/qqq-abc-~X~xxx/yyy~E-def&#34;))
    print(repr(parse(&#34;abc/def/-/xxx/-q/qqq-abc-~X~xxx/yyy~E-def&#34;)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="liquer.parser.all_splits"><code class="name flex">
<span>def <span class="ident">all_splits</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Make all splits of the query into two parts (biginning and remainder)
by progressively increasing the remainder.
query == beginning + COMMAND_SEPARATOR + remainder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_splits(query):
    &#34;&#34;&#34;Make all splits of the query into two parts (biginning and remainder)
    by progressively increasing the remainder.
    query == beginning + COMMAND_SEPARATOR + remainder
    &#34;&#34;&#34;
    ql = decode(query)
    for i in range(len(ql), -1, -1):
        yield encode(ql[:i]), encode(ql[i:])</code></pre>
</details>
</dd>
<dt id="liquer.parser.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>query: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode query string into a list of lists of strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(query: str):
    &#34;&#34;&#34;Decode query string into a list of lists of strings.&#34;&#34;&#34;
    ql = [
        [decode_token(etoken) for etoken in eqv.split(PARAMETER_SEPARATOR)]
        for eqv in query.split(COMMAND_SEPARATOR)
    ]
    return [qcommand for qcommand in ql if len(qcommand) and len(qcommand[0])]</code></pre>
</details>
</dd>
<dt id="liquer.parser.decode_token"><code class="name flex">
<span>def <span class="ident">decode_token</span></span>(<span>token: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode single token by un-escaping special characters and character sequences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_token(token: str):
    &#34;Decode single token by un-escaping special characters and character sequences&#34;
    encoding = {e: s for s, e in ESCAPE_SEQUENCES}
    if token == &#34;&#34;:
        return &#34;&#34;
    try:
        index = token.index(ESCAPE)
        head = token[:index]
        mid = token[index : index + 2]
        tail = token[index + 2 :]
        return unquote(head + encoding.get(mid, mid)) + decode_token(tail)
    except ValueError:
        return unquote(token)</code></pre>
</details>
</dd>
<dt id="liquer.parser.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>ql: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode query list (list of lists of strings) into an properly escaped query string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(ql: list):
    &#34;&#34;&#34;Decode query list (list of lists of strings) into an properly escaped query string.&#34;&#34;&#34;
    return COMMAND_SEPARATOR.join(
        PARAMETER_SEPARATOR.join(encode_token(token) for token in qv) for qv in ql
    )</code></pre>
</details>
</dd>
<dt id="liquer.parser.encode_token"><code class="name flex">
<span>def <span class="ident">encode_token</span></span>(<span>token: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode single token by escaping special characters and character sequences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_token(token: str):
    &#34;Encode single token by escaping special characters and character sequences&#34;
    for sequence, encoding in ESCAPE_SEQUENCES:
        token = token.replace(sequence, encoding)
    return quote(token).replace(&#34;%7E&#34;, &#34;~&#34;).replace(&#34;%7e&#34;, &#34;~&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.parser.indent"><code class="name flex">
<span>def <span class="ident">indent</span></span>(<span>text, prefix='
')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indent(text, prefix=&#34;  &#34;):
    return &#34;\n&#34;.join(prefix + x for x in text.split(&#34;\n&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.parser.list_indent"><code class="name flex">
<span>def <span class="ident">list_indent</span></span>(<span>lst, prefix='
')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_indent(lst, prefix=&#34;  &#34;):
    if len(lst):
        return &#34;[\n&#34; + &#34;,\n&#34;.join(indent(repr(x), prefix) for x in lst) + &#34;\n]&#34;
    else:
        return &#34;[]&#34;</code></pre>
</details>
</dd>
<dt id="liquer.parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(query):
    try:
        return resource_transform_query.parseString(query, True)[0]
    except:
        return parse_query.parseString(query, True)[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="liquer.parser.ActionParameter"><code class="flex name class">
<span>class <span class="ident">ActionParameter</span></span>
<span>(</span><span>position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionParameter(object):
    def __init__(self, position=None):
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        return self

    def __repr__(self):
        return f&#34;{self.__class__.__name__}({repr(self.position)})&#34;

    def __str__(self):
        return f&#34;{self.__class__.__name__} at {self.position}&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.parser.ExpandedActionParameter" href="#liquer.parser.ExpandedActionParameter">ExpandedActionParameter</a></li>
<li><a title="liquer.parser.LinkActionParameter" href="#liquer.parser.LinkActionParameter">LinkActionParameter</a></li>
<li><a title="liquer.parser.ResourceName" href="#liquer.parser.ResourceName">ResourceName</a></li>
<li><a title="liquer.parser.StringActionParameter" href="#liquer.parser.StringActionParameter">StringActionParameter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.ActionParameter.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    self.position = Position()
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.ActionRequest"><code class="flex name class">
<span>class <span class="ident">ActionRequest</span></span>
<span>(</span><span>name: str, parameters=None, position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionRequest(object):
    def __init__(self, name: str, parameters=None, position=None):
        self.name = name
        self.parameters = [] if parameters is None else parameters
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        for p in self.parameters:
            p.clean_position()
        return self

    @classmethod
    def from_arguments(cls, name: str, *parameters):
        assert type(name) == str
        typedparam = []
        for p in parameters:
            if isinstance(p, ActionParameter):
                typedparam.append(p)
            else:
                assert type(p) in (str, int, float, bool)
                typedparam.append(StringActionParameter(str(p)))

        return cls(name, typedparam)

    def to_list(self):
        lst = [self.name]
        for x in self.parameters:
            if isinstance(x, StringActionParameter):
                lst.append(x.string)
            elif isinstance(x, LinkActionParameter):
                lst.append(x.encode())
            else:
                raise Exception(
                    f&#34;Unsupported action parameter type: {type(x)} ({repr(x)})&#34;
                )
        return lst

    @classmethod
    def from_list(cls, lst):
        return cls.from_arguments(lst[0], *lst[1:])

    def encode(self):
        if len(self.parameters):
            p = &#34;-&#34;.join(x.encode() for x in self.parameters)
            return f&#34;{self.name}-{p}&#34;
        else:
            return self.name

    def __repr__(self):
        return f&#34;&#34;&#34;ActionRequest(
  {repr(self.name)},
{indent(list_indent(self.parameters))},
  {repr(self.position)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="liquer.parser.ActionRequest.from_arguments"><code class="name flex">
<span>def <span class="ident">from_arguments</span></span>(<span>name: str, *parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_arguments(cls, name: str, *parameters):
    assert type(name) == str
    typedparam = []
    for p in parameters:
        if isinstance(p, ActionParameter):
            typedparam.append(p)
        else:
            assert type(p) in (str, int, float, bool)
            typedparam.append(StringActionParameter(str(p)))

    return cls(name, typedparam)</code></pre>
</details>
</dd>
<dt id="liquer.parser.ActionRequest.from_list"><code class="name flex">
<span>def <span class="ident">from_list</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_list(cls, lst):
    return cls.from_arguments(lst[0], *lst[1:])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.ActionRequest.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    self.position = Position()
    for p in self.parameters:
        p.clean_position()
    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.ActionRequest.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    if len(self.parameters):
        p = &#34;-&#34;.join(x.encode() for x in self.parameters)
        return f&#34;{self.name}-{p}&#34;
    else:
        return self.name</code></pre>
</details>
</dd>
<dt id="liquer.parser.ActionRequest.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self):
    lst = [self.name]
    for x in self.parameters:
        if isinstance(x, StringActionParameter):
            lst.append(x.string)
        elif isinstance(x, LinkActionParameter):
            lst.append(x.encode())
        else:
            raise Exception(
                f&#34;Unsupported action parameter type: {type(x)} ({repr(x)})&#34;
            )
    return lst</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.ExpandedActionParameter"><code class="flex name class">
<span>class <span class="ident">ExpandedActionParameter</span></span>
<span>(</span><span>value, link, position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpandedActionParameter(ActionParameter):
    def __init__(self, value, link, position=None):
        super().__init__(position)
        self.value = value
        self.link = link

    def encode(self):
        return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;

    def __repr__(self):
        return f&#34;&#34;&#34;ExpandedActionParameter(
{indent(repr(self.value))}
{indent(repr(self.link))},
  {repr(self.position)})&#34;&#34;&#34;

    def __str__(self):
        return str(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.parser.ActionParameter" href="#liquer.parser.ActionParameter">ActionParameter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.ExpandedActionParameter.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.LinkActionParameter"><code class="flex name class">
<span>class <span class="ident">LinkActionParameter</span></span>
<span>(</span><span>link, position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkActionParameter(ActionParameter):
    def __init__(self, link, position=None):
        super().__init__(position)
        self.link = link

    def encode(self):
        return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;

    def __repr__(self):
        return f&#34;&#34;&#34;LinkActionParameter(
{indent(repr(self.link))},
  {repr(self.position)})&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.parser.ActionParameter" href="#liquer.parser.ActionParameter">ActionParameter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.LinkActionParameter.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    return &#34;~X~&#34; + self.link.encode() + &#34;~E&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.Position"><code class="flex name class">
<span>class <span class="ident">Position</span></span>
<span>(</span><span>offset=0, line=0, column=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position:
    def __init__(self, offset=0, line=0, column=0):
        self.offset = offset
        self.line = line
        self.column = column

    @classmethod
    def from_loc(cls, loc, string):
        return cls(loc, line=lineno(loc, string), column=col(loc, string))

    @classmethod
    def from_dict(cls, d):
        if d is None:
            return cls()
        else:
            return cls(offset=d[&#34;offset&#34;], line=d[&#34;line&#34;], column=d[&#34;column&#34;])

    def to_dict(self):
        return dict(offset=self.offset, line=self.line, column=self.column)

    def __str__(self):
        if self.line == 0:
            return &#34;(unknown position)&#34;
        elif self.line &gt; 1:
            return f&#34;line {self.line}, position {self.column}&#34;
        else:
            return f&#34;position {self.column}&#34;

    def __repr__(self):
        if self.line == 0:
            return &#34;Position()&#34;
        return f&#34;Position(offset={self.offset}, line={self.line}, column={self.column})&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="liquer.parser.Position.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, d):
    if d is None:
        return cls()
    else:
        return cls(offset=d[&#34;offset&#34;], line=d[&#34;line&#34;], column=d[&#34;column&#34;])</code></pre>
</details>
</dd>
<dt id="liquer.parser.Position.from_loc"><code class="name flex">
<span>def <span class="ident">from_loc</span></span>(<span>loc, string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_loc(cls, loc, string):
    return cls(loc, line=lineno(loc, string), column=col(loc, string))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.Position.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    return dict(offset=self.offset, line=self.line, column=self.column)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.Query"><code class="flex name class">
<span>class <span class="ident">Query</span></span>
<span>(</span><span>segments: list = None, absolute=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Query is a sequence of query segment.
Typically this will be a resource and and/or a transformation applied to a resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Query(object):
    &#34;&#34;&#34;Query is a sequence of query segment.
    Typically this will be a resource and and/or a transformation applied to a resource.&#34;&#34;&#34;

    def __init__(self, segments: list = None, absolute=False):
        self.segments = segments or []
        self.absolute = absolute

    def clean_position(self):
        for s in self.segments:
            s.clean_position()
        return self

    def filename(self):
        &#34;Return filename if present, None otherwise.&#34;
        if len(self.segments):
            segment = self.segments[-1]
            if (
                isinstance(segment, TransformQuerySegment)
                and segment.filename is not None
            ):
                return str(segment.filename)
            if (
                isinstance(segment, ResourceQuerySegment)
                and segment.query is not None
                and len(segment.query)
            ):
                return str(segment.query[-1])
        return None

    def without_filename(self):
        &#34;&#34;&#34;Query without the filename.&#34;&#34;&#34;
        if self.filename() is None:
            return self
        else:
            p, _ = self.predecessor()
            return p

    def extension(self):
        &#34;Return file extension if present, None otherwise.&#34;
        filename = self.filename()
        if filename is not None:
            v = filename.split(&#34;.&#34;)
            if len(v) &gt; 1:
                return v[-1]
        return None

    def is_empty(self):
        &#34;Returns true if the query is empty, i.e. has no segments and thus is equivalent to an empty string.&#34;
        return len(self.segments) == 0

    def is_transform_query(self):
        &#34;Returns true if the query is a pure transformation query - i.e. a sequence of actions.&#34;
        return len(self.segments) == 1 and isinstance(
            self.segments[0], TransformQuerySegment
        )

    def transform_query(self):
        &#34;Returns TransformQuerySegment if the query is a pure transformation query, None otherwise.&#34;
        if self.is_transform_query():
            return self.segments[0]
        else:
            return None

    def is_resource_query(self):
        &#34;Returns true if the query is a pure resource query - i.e. a store key with an optional header (-R).&#34;
        return len(self.segments) == 1 and isinstance(
            self.segments[0], ResourceQuerySegment
        )

    def resource_query(self):
        &#34;Returns ResourceQuerySegment if the query is a pure resource query, None otherwise.&#34;
        if self.is_resource_query():
            return self.segments[0]
        else:
            return None

    def is_action_request(self):
        &#34;Returns true if the query is a single action request.&#34;
        return self.is_transform_query() and self.segments[0].is_action_request()

    def action(self):
        &#34;Returns ActionRequest if the query is a single action request, None otherwise.&#34;
        if self.is_action_request():
            return self.segments[0].action()
        else:
            return None

    def predecessor(self):
        &#34;&#34;&#34;Return tuple of (predecessor, remainder).
        Remainder is a last element (action or filename) or None if not available.
        Predecessor is a query without the remainder (or None).
        &#34;&#34;&#34;
        if len(self.segments):
            if isinstance(self.segments[-1], TransformQuerySegment):
                p, r = self.segments[-1].predecessor()
                if p is None or p.is_empty():
                    qp = Query(self.segments[:-1], absolute=self.absolute)
                    qr = r
                    return qp, qr
                else:
                    qp = Query(self.segments[:-1] + [p], absolute=self.absolute)
                    qr = r
                    return qp, qr
            else:
                return None, None
        else:
            return None, None

    def short(self, n=30):
        &#34;&#34;&#34;Make a shortened version of the at most n characters (30) of a query for printout purposes.&#34;&#34;&#34;
        _, r = self.predecessor()
        if r is None:
            q = str(self)
            if len(self) &gt; n:
                q = &#34;...&#34; + q[-n:]
            return q
        else:
            return str(r)

    def all_predecessors(self):
        &#34;&#34;&#34;Iterate over all predecessors.
        Iterator yields (predecessor, remainder) tuples from the full query (query, None)
        removing remainders in each step until there is no predecessor left.
        &#34;&#34;&#34;
        qp, qr = self, None
        while qp is not None:
            yield qp, qr
            qp, r = qp.predecessor()
            qr = r + qr

    def create_segment(self, name: str = &#34;&#34;, level=1):
        qs = TransformQuerySegment(SegmentHeader(name, level=level))
        self.segments.append(qs)
        return qs

    def last_transform_query_segment(self):
        if not self.is_empty():
            if isinstance(self.segments[-1], TransformQuerySegment):
                return self.segments[-1]
        return self.create_segment()

    def with_action(self, name: str, *parameters):
        self.last_transform_query_segment().append(
            ActionRequest.from_arguments(name, *parameters)
        )
        return self

    def __add__(self, tq):
        assert isinstance(tq, TransformQuerySegment)
        return Query(self.segments + [tq], absolute=self.absolute)

    def encode(self):
        q = &#34;/&#34;.join(x.encode() for x in self.segments)
        if self.is_resource_query():
            if not q.startswith(&#34;-&#34;):
                q = &#34;-R/&#34; + q
        if self.absolute:
            q = &#34;/&#34; + q
        return q

    def to_absolute(self, path, resource_segment_name=&#34;&#34;):
        &#34;&#34;&#34;Convert relative path to absolute path in the selected resource.
        Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
        Everything else besides selected resources stays unchanged.
        Resources are selected by resource_segment_name (default is the unnamed default resource).
        None resource_segment_name means all resources.
        Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
        Path may be a string or a ResourceQuerySegment.
        &#34;&#34;&#34;
        segments = []
        for s in self.segments:
            if isinstance(s, TransformQuerySegment):
                segments.append(s)
            elif isinstance(s, ResourceQuerySegment):
                if (
                    resource_segment_name is None
                    or resource_segment_name == s.segment_name()
                ):
                    segments.append(s.to_absolute(path))
                else:
                    segments.append(s)
            else:
                raise ValueError(f&#34;Unknown segment type {type(s)}&#34;)
        return Query(segments, absolute=self.absolute)

    def __repr__(self):
        return f&#34;&#34;&#34;Query(
{indent(list_indent(self.segments))},
  absolute = {self.absolute}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.Query.action"><code class="name flex">
<span>def <span class="ident">action</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns ActionRequest if the query is a single action request, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action(self):
    &#34;Returns ActionRequest if the query is a single action request, None otherwise.&#34;
    if self.is_action_request():
        return self.segments[0].action()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.all_predecessors"><code class="name flex">
<span>def <span class="ident">all_predecessors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over all predecessors.
Iterator yields (predecessor, remainder) tuples from the full query (query, None)
removing remainders in each step until there is no predecessor left.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_predecessors(self):
    &#34;&#34;&#34;Iterate over all predecessors.
    Iterator yields (predecessor, remainder) tuples from the full query (query, None)
    removing remainders in each step until there is no predecessor left.
    &#34;&#34;&#34;
    qp, qr = self, None
    while qp is not None:
        yield qp, qr
        qp, r = qp.predecessor()
        qr = r + qr</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    for s in self.segments:
        s.clean_position()
    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.create_segment"><code class="name flex">
<span>def <span class="ident">create_segment</span></span>(<span>self, name: str = '', level=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_segment(self, name: str = &#34;&#34;, level=1):
    qs = TransformQuerySegment(SegmentHeader(name, level=level))
    self.segments.append(qs)
    return qs</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    q = &#34;/&#34;.join(x.encode() for x in self.segments)
    if self.is_resource_query():
        if not q.startswith(&#34;-&#34;):
            q = &#34;-R/&#34; + q
    if self.absolute:
        q = &#34;/&#34; + q
    return q</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.extension"><code class="name flex">
<span>def <span class="ident">extension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return file extension if present, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extension(self):
    &#34;Return file extension if present, None otherwise.&#34;
    filename = self.filename()
    if filename is not None:
        v = filename.split(&#34;.&#34;)
        if len(v) &gt; 1:
            return v[-1]
    return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.filename"><code class="name flex">
<span>def <span class="ident">filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return filename if present, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filename(self):
    &#34;Return filename if present, None otherwise.&#34;
    if len(self.segments):
        segment = self.segments[-1]
        if (
            isinstance(segment, TransformQuerySegment)
            and segment.filename is not None
        ):
            return str(segment.filename)
        if (
            isinstance(segment, ResourceQuerySegment)
            and segment.query is not None
            and len(segment.query)
        ):
            return str(segment.query[-1])
    return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.is_action_request"><code class="name flex">
<span>def <span class="ident">is_action_request</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the query is a single action request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_action_request(self):
    &#34;Returns true if the query is a single action request.&#34;
    return self.is_transform_query() and self.segments[0].is_action_request()</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the query is empty, i.e. has no segments and thus is equivalent to an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;Returns true if the query is empty, i.e. has no segments and thus is equivalent to an empty string.&#34;
    return len(self.segments) == 0</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.is_resource_query"><code class="name flex">
<span>def <span class="ident">is_resource_query</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the query is a pure resource query - i.e. a store key with an optional header (-R).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_resource_query(self):
    &#34;Returns true if the query is a pure resource query - i.e. a store key with an optional header (-R).&#34;
    return len(self.segments) == 1 and isinstance(
        self.segments[0], ResourceQuerySegment
    )</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.is_transform_query"><code class="name flex">
<span>def <span class="ident">is_transform_query</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the query is a pure transformation query - i.e. a sequence of actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_transform_query(self):
    &#34;Returns true if the query is a pure transformation query - i.e. a sequence of actions.&#34;
    return len(self.segments) == 1 and isinstance(
        self.segments[0], TransformQuerySegment
    )</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.last_transform_query_segment"><code class="name flex">
<span>def <span class="ident">last_transform_query_segment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_transform_query_segment(self):
    if not self.is_empty():
        if isinstance(self.segments[-1], TransformQuerySegment):
            return self.segments[-1]
    return self.create_segment()</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.predecessor"><code class="name flex">
<span>def <span class="ident">predecessor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return tuple of (predecessor, remainder).
Remainder is a last element (action or filename) or None if not available.
Predecessor is a query without the remainder (or None).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predecessor(self):
    &#34;&#34;&#34;Return tuple of (predecessor, remainder).
    Remainder is a last element (action or filename) or None if not available.
    Predecessor is a query without the remainder (or None).
    &#34;&#34;&#34;
    if len(self.segments):
        if isinstance(self.segments[-1], TransformQuerySegment):
            p, r = self.segments[-1].predecessor()
            if p is None or p.is_empty():
                qp = Query(self.segments[:-1], absolute=self.absolute)
                qr = r
                return qp, qr
            else:
                qp = Query(self.segments[:-1] + [p], absolute=self.absolute)
                qr = r
                return qp, qr
        else:
            return None, None
    else:
        return None, None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.resource_query"><code class="name flex">
<span>def <span class="ident">resource_query</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns ResourceQuerySegment if the query is a pure resource query, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resource_query(self):
    &#34;Returns ResourceQuerySegment if the query is a pure resource query, None otherwise.&#34;
    if self.is_resource_query():
        return self.segments[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.short"><code class="name flex">
<span>def <span class="ident">short</span></span>(<span>self, n=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a shortened version of the at most n characters (30) of a query for printout purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def short(self, n=30):
    &#34;&#34;&#34;Make a shortened version of the at most n characters (30) of a query for printout purposes.&#34;&#34;&#34;
    _, r = self.predecessor()
    if r is None:
        q = str(self)
        if len(self) &gt; n:
            q = &#34;...&#34; + q[-n:]
        return q
    else:
        return str(r)</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.to_absolute"><code class="name flex">
<span>def <span class="ident">to_absolute</span></span>(<span>self, path, resource_segment_name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert relative path to absolute path in the selected resource.
Replace first "." with <em>path</em>, and interpret ".." returning the canonical absolute path.
Everything else besides selected resources stays unchanged.
Resources are selected by resource_segment_name (default is the unnamed default resource).
None resource_segment_name means all resources.
Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
Path may be a string or a ResourceQuerySegment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_absolute(self, path, resource_segment_name=&#34;&#34;):
    &#34;&#34;&#34;Convert relative path to absolute path in the selected resource.
    Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
    Everything else besides selected resources stays unchanged.
    Resources are selected by resource_segment_name (default is the unnamed default resource).
    None resource_segment_name means all resources.
    Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
    Path may be a string or a ResourceQuerySegment.
    &#34;&#34;&#34;
    segments = []
    for s in self.segments:
        if isinstance(s, TransformQuerySegment):
            segments.append(s)
        elif isinstance(s, ResourceQuerySegment):
            if (
                resource_segment_name is None
                or resource_segment_name == s.segment_name()
            ):
                segments.append(s.to_absolute(path))
            else:
                segments.append(s)
        else:
            raise ValueError(f&#34;Unknown segment type {type(s)}&#34;)
    return Query(segments, absolute=self.absolute)</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.transform_query"><code class="name flex">
<span>def <span class="ident">transform_query</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns TransformQuerySegment if the query is a pure transformation query, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_query(self):
    &#34;Returns TransformQuerySegment if the query is a pure transformation query, None otherwise.&#34;
    if self.is_transform_query():
        return self.segments[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.with_action"><code class="name flex">
<span>def <span class="ident">with_action</span></span>(<span>self, name: str, *parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_action(self, name: str, *parameters):
    self.last_transform_query_segment().append(
        ActionRequest.from_arguments(name, *parameters)
    )
    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.Query.without_filename"><code class="name flex">
<span>def <span class="ident">without_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Query without the filename.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without_filename(self):
    &#34;&#34;&#34;Query without the filename.&#34;&#34;&#34;
    if self.filename() is None:
        return self
    else:
        p, _ = self.predecessor()
        return p</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.QueryException"><code class="flex name class">
<span>class <span class="ident">QueryException</span></span>
<span>(</span><span>message, position=None, query=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryException(Exception):
    def __init__(self, message, position=None, query=None):
        self.original_message = message
        if position is not None:
            message += f&#34; at {position}&#34;
            if query is not None:
                message += f&#34;:\n  query: {query[:position.offset]}\n     {&#39; &#39;*position.offset}--&gt; {query[position.offset:]}&#34;
        else:
            if query is not None:
                message += f&#34;:\n  query: {query}&#34;

        super().__init__(message)
        self.position = position
        self.query = query</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.commands.ArgumentParserException" href="commands.html#liquer.commands.ArgumentParserException">ArgumentParserException</a></li>
<li><a title="liquer.state.EvaluationException" href="state.html#liquer.state.EvaluationException">EvaluationException</a></li>
</ul>
</dd>
<dt id="liquer.parser.ResourceName"><code class="flex name class">
<span>class <span class="ident">ResourceName</span></span>
<span>(</span><span>name: str, position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResourceName(ActionParameter):
    def __init__(self, name: str, position=None):
        self.position = position or Position()
        self.name = name

    def encode(self):
        return self.name

    def __repr__(self):
        return f&#34;ResourceName({repr(self.name)}, {repr(self.position)})&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.parser.ActionParameter" href="#liquer.parser.ActionParameter">ActionParameter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.ResourceName.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    return self.name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.ResourceQuerySegment"><code class="flex name class">
<span>class <span class="ident">ResourceQuerySegment</span></span>
<span>(</span><span>header=None, query=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Query segment representing a resource, i.e. path to a file in a store.</p>
<p>header can be SegmentHeader, query is a list of ActionRequest objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResourceQuerySegment(object):
    &#34;&#34;&#34;Query segment representing a resource, i.e. path to a file in a store.&#34;&#34;&#34;

    def __init__(self, header=None, query=None):
        &#34;header can be SegmentHeader, query is a list of ActionRequest objects&#34;
        self.header = header
        self.query = query or []

    def segment_name(self):
        if self.header is None:
            return &#34;&#34;
        else:
            return self.header.name

    def clean_position(self):
        if self.header is not None:
            self.header.clean_position()
        for a in self.query:
            a.clean_position()
        return self

    @property
    def position(self):
        if self.header is not None:
            return self.header.position
        else:
            if len(self.query):
                return self.query[0].position

    def path(self):
        &#34;&#34;&#34;Path to the resource as a string.
        This is typically interpreted as a resource key in a Store object.&#34;&#34;&#34;
        return &#34;/&#34;.join(x.encode() for x in self.query)

    def encode(self):
        query = self.path()
        if self.header is None:
            rqs = &#34;&#34;
        else:
            rqs = self.header.encode()
        if len(rqs):
            rqs += &#34;/&#34;
        if len(query):
            return f&#34;{rqs}{query}&#34;
        else:
            return rqs

    def _query_to_absolute(self, path, processed, rest):
        if len(rest) == 0:
            return processed
        if rest[0].encode() == &#34;.&#34;:
            if len(processed) == 0:
                return self._query_to_absolute(path, path[:], rest[1:])
            else:
                return self._query_to_absolute(path, processed, rest[1:])

        if rest[0].encode() == &#34;..&#34;:
            if len(processed) == 0:
                if len(path) == 0:
                    raise Exception(&#34;Can&#39;t go up from root&#34;)
                return self._query_to_absolute(path, path[:-1], rest[1:])
            else:
                return self._query_to_absolute(path, processed[:-1], rest[1:])
        return self._query_to_absolute(path, processed + [rest[0]], rest[1:])

    def to_absolute(self, path):
        &#34;&#34;&#34;Convert relative path to absolute path.
        Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
        Resource segment header stays unchanged.
        Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
        Path may be a string or a ResourceQuerySegment.
        &#34;&#34;&#34;
        if isinstance(path, str):
            if len(path) == 0:
                path = []
            else:
                path = list(resource_path.parseString(path, True))
                for s in path:
                    s.clean_position()
        canonical_path = []

        if self.query is None or len(self.query) == 0:
            return self
        return ResourceQuerySegment(
            header=self.header, query=self._query_to_absolute(path, [], self.query)
        )

    def __repr__(self):
        return f&#34;&#34;&#34;ResourceQuerySegment(
  header = {indent(repr(self.header))},
  query  = {indent(list_indent(self.query))}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="liquer.parser.ResourceQuerySegment.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    if self.header is not None:
        return self.header.position
    else:
        if len(self.query):
            return self.query[0].position</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.ResourceQuerySegment.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    if self.header is not None:
        self.header.clean_position()
    for a in self.query:
        a.clean_position()
    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.ResourceQuerySegment.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    query = self.path()
    if self.header is None:
        rqs = &#34;&#34;
    else:
        rqs = self.header.encode()
    if len(rqs):
        rqs += &#34;/&#34;
    if len(query):
        return f&#34;{rqs}{query}&#34;
    else:
        return rqs</code></pre>
</details>
</dd>
<dt id="liquer.parser.ResourceQuerySegment.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Path to the resource as a string.
This is typically interpreted as a resource key in a Store object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self):
    &#34;&#34;&#34;Path to the resource as a string.
    This is typically interpreted as a resource key in a Store object.&#34;&#34;&#34;
    return &#34;/&#34;.join(x.encode() for x in self.query)</code></pre>
</details>
</dd>
<dt id="liquer.parser.ResourceQuerySegment.segment_name"><code class="name flex">
<span>def <span class="ident">segment_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_name(self):
    if self.header is None:
        return &#34;&#34;
    else:
        return self.header.name</code></pre>
</details>
</dd>
<dt id="liquer.parser.ResourceQuerySegment.to_absolute"><code class="name flex">
<span>def <span class="ident">to_absolute</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert relative path to absolute path.
Replace first "." with <em>path</em>, and interpret ".." returning the canonical absolute path.
Resource segment header stays unchanged.
Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
Path may be a string or a ResourceQuerySegment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_absolute(self, path):
    &#34;&#34;&#34;Convert relative path to absolute path.
    Replace first &#34;.&#34; with *path*, and interpret &#34;..&#34; returning the canonical absolute path.
    Resource segment header stays unchanged.
    Path argument should point to a directory key in a store - i.e. it should be an absolute path without a header.
    Path may be a string or a ResourceQuerySegment.
    &#34;&#34;&#34;
    if isinstance(path, str):
        if len(path) == 0:
            path = []
        else:
            path = list(resource_path.parseString(path, True))
            for s in path:
                s.clean_position()
    canonical_path = []

    if self.query is None or len(self.query) == 0:
        return self
    return ResourceQuerySegment(
        header=self.header, query=self._query_to_absolute(path, [], self.query)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.SegmentHeader"><code class="flex name class">
<span>class <span class="ident">SegmentHeader</span></span>
<span>(</span><span>name: str = '', level: int = 1, parameters: list = None, resource: bool = False, position=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Header of a query segment - both resource and transformation query.
Header may contain name (string), level (integer) and parameters (list of strings).
The header parameters may influence how the query is interpreted.
The interpretation of the header parameters depends on the context object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SegmentHeader(object):
    &#34;&#34;&#34;Header of a query segment - both resource and transformation query.
    Header may contain name (string), level (integer) and parameters (list of strings).
    The header parameters may influence how the query is interpreted.
    The interpretation of the header parameters depends on the context object.
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str = &#34;&#34;,
        level: int = 1,
        parameters: list = None,
        resource: bool = False,
        position=None,
    ):
        self.name = name
        self.level = level
        self.parameters = parameters or []
        self.resource = resource
        self.position = position or Position()

    def clean_position(self):
        self.position = Position()
        for p in self.parameters:
            p.clean_position()
        return self

    def is_trivial(self):
        &#34;&#34;&#34;Terurns true if the header does not contain any data,
        I.e. trivial header has no name, level is 1 and no parameters.
        Trivial header can be both for resource and query, it does not depend on the resource flas.
        &#34;&#34;&#34;
        return self.name in (&#34;&#34;, None) and self.level == 1 and len(self.parameters) == 0

    def encode(self):
        assert self.level &gt;= 1
        encoded = &#34;-&#34; * self.level
        if self.resource:
            encoded += &#34;R&#34;
        encoded += self.name
        if len(self.parameters):
            assert len(self.name) &gt; 0 or self.resource
            for parameter in self.parameters:
                encoded += &#34;-&#34;
                encoded += parameter.encode()
        return encoded

    def __repr__(self):
        return f&#34;&#34;&#34;SegmentHeader(
  name       ={repr(self.name)},
  level      ={self.level},
  parameters ={indent(list_indent(self.parameters))},
  resource   ={self.resource},
  position   ={repr(self.position)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.SegmentHeader.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    self.position = Position()
    for p in self.parameters:
        p.clean_position()
    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.SegmentHeader.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    assert self.level &gt;= 1
    encoded = &#34;-&#34; * self.level
    if self.resource:
        encoded += &#34;R&#34;
    encoded += self.name
    if len(self.parameters):
        assert len(self.name) &gt; 0 or self.resource
        for parameter in self.parameters:
            encoded += &#34;-&#34;
            encoded += parameter.encode()
    return encoded</code></pre>
</details>
</dd>
<dt id="liquer.parser.SegmentHeader.is_trivial"><code class="name flex">
<span>def <span class="ident">is_trivial</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terurns true if the header does not contain any data,
I.e. trivial header has no name, level is 1 and no parameters.
Trivial header can be both for resource and query, it does not depend on the resource flas.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_trivial(self):
    &#34;&#34;&#34;Terurns true if the header does not contain any data,
    I.e. trivial header has no name, level is 1 and no parameters.
    Trivial header can be both for resource and query, it does not depend on the resource flas.
    &#34;&#34;&#34;
    return self.name in (&#34;&#34;, None) and self.level == 1 and len(self.parameters) == 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.StringActionParameter"><code class="flex name class">
<span>class <span class="ident">StringActionParameter</span></span>
<span>(</span><span>string: str, position=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringActionParameter(ActionParameter):
    def __init__(self, string: str, position=None):
        super().__init__(position)
        self.string = string

    def encode(self):
        #        encoded = self.string.replace(&#34;~&#34;,&#34;~~&#34;).replace(&#34;/&#34;,&#34;~/&#34;).replace(&#34;://&#34;,&#34;~P&#34;)
        encoded = encode_token(self.string)
        return encoded

    def __repr__(self):
        return f&#34;StringActionParameter({repr(self.string)}, {repr(self.position)})&#34;

    def __str__(self):
        return self.string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.parser.ActionParameter" href="#liquer.parser.ActionParameter">ActionParameter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.StringActionParameter.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    #        encoded = self.string.replace(&#34;~&#34;,&#34;~~&#34;).replace(&#34;/&#34;,&#34;~/&#34;).replace(&#34;://&#34;,&#34;~P&#34;)
    encoded = encode_token(self.string)
    return encoded</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.parser.TransformQuerySegment"><code class="flex name class">
<span>class <span class="ident">TransformQuerySegment</span></span>
<span>(</span><span>header=None, query=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Query segment representing a transformation, i.e. a sequence of actions applied to a state.</p>
<p>header can be SegmentHeader, query is a list of ActionRequest objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformQuerySegment(object):
    &#34;&#34;&#34;Query segment representing a transformation, i.e. a sequence of actions applied to a state.&#34;&#34;&#34;

    def __init__(self, header=None, query=None, filename=None):
        &#34;header can be SegmentHeader, query is a list of ActionRequest objects&#34;
        self.header = header
        self.query = query or []
        self.filename = filename

    def clean_position(self):
        if self.header is not None:
            self.header.clean_position()
        for a in self.query:
            a.clean_position()
        try:
            self.filename.clean_position()
        except:
            pass

        return self

    def predecessor(self):
        if self.filename is None:
            if len(self.query):
                p = TransformQuerySegment(
                    header=self.header, query=self.query[:-1], filename=None
                )
                r = TransformQuerySegment(
                    header=self.header, query=[self.query[-1]], filename=None
                )
                return p, r
            else:
                return None, None
        else:
            p = TransformQuerySegment(
                header=self.header, query=self.query, filename=None
            )
            r = TransformQuerySegment(
                header=self.header, query=[], filename=self.filename
            )
            return p, r

    def is_empty(self):
        return len(self.query) == 0 and self.filename is None

    def is_filename(self):
        return len(self.query) == 0 and self.filename is not None

    def is_action_request(self):
        return len(self.query) == 1 and self.filename is None

    def action(self):
        if self.is_action_request():
            return self.query[0]
        else:
            return None

    def encode(self):
        query = &#34;/&#34;.join(x.encode() for x in self.query)
        if self.filename is not None:
            query = f&#34;{query}/{self.filename}&#34; if len(query) else self.filename

        if self.header is None:
            return query
        else:
            if len(query):
                return f&#34;{self.header.encode()}/{query}&#34;
            else:
                return self.header.encode()

    def append(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            self.query.extend(q.query)
            self.filename = q.filename
            return self
        if isinstance(q, Query):
            if q.is_transform_query():
                return self.append(q.segments[0])
            else:
                raise Exception(
                    f&#34;Appending general query {q} to transform query {self.encode()} not supported&#34;
                )
        if isinstance(q, ActionRequest):
            self.query.append(q)
            return self
        if isinstance(q, str):
            return self.append(parse(q))

        raise Exception(
            f&#34;Transform query {self.encode()} can&#39;t append object {repr(q)}&#34;
        )

    def __add__(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            return TransformQuerySegment(
                header=self.header, query=self.query + q.query, filename=q.filename
            )

        raise Exception(f&#34;Unsupported operation (add): {self.encode()} + {repr(q)}&#34;)

    def __radd__(self, q):
        if q is None:
            return self
        if isinstance(q, TransformQuerySegment):
            return q + self
        raise Exception(f&#34;Unsupported operation (radd): {repr(q)} + {self.encode()}&#34;)

    def __repr__(self):
        return f&#34;&#34;&#34;TransformQuerySegment(
  header   = {indent(repr(self.header))},
  query    = {indent(list_indent(self.query))},
  filename = {repr(self.filename)}
)&#34;&#34;&#34;

    def __str__(self):
        return self.encode()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="liquer.parser.TransformQuerySegment.action"><code class="name flex">
<span>def <span class="ident">action</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def action(self):
    if self.is_action_request():
        return self.query[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, q)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, q):
    if q is None:
        return self
    if isinstance(q, TransformQuerySegment):
        self.query.extend(q.query)
        self.filename = q.filename
        return self
    if isinstance(q, Query):
        if q.is_transform_query():
            return self.append(q.segments[0])
        else:
            raise Exception(
                f&#34;Appending general query {q} to transform query {self.encode()} not supported&#34;
            )
    if isinstance(q, ActionRequest):
        self.query.append(q)
        return self
    if isinstance(q, str):
        return self.append(parse(q))

    raise Exception(
        f&#34;Transform query {self.encode()} can&#39;t append object {repr(q)}&#34;
    )</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.clean_position"><code class="name flex">
<span>def <span class="ident">clean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_position(self):
    if self.header is not None:
        self.header.clean_position()
    for a in self.query:
        a.clean_position()
    try:
        self.filename.clean_position()
    except:
        pass

    return self</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    query = &#34;/&#34;.join(x.encode() for x in self.query)
    if self.filename is not None:
        query = f&#34;{query}/{self.filename}&#34; if len(query) else self.filename

    if self.header is None:
        return query
    else:
        if len(query):
            return f&#34;{self.header.encode()}/{query}&#34;
        else:
            return self.header.encode()</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.is_action_request"><code class="name flex">
<span>def <span class="ident">is_action_request</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_action_request(self):
    return len(self.query) == 1 and self.filename is None</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    return len(self.query) == 0 and self.filename is None</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.is_filename"><code class="name flex">
<span>def <span class="ident">is_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_filename(self):
    return len(self.query) == 0 and self.filename is not None</code></pre>
</details>
</dd>
<dt id="liquer.parser.TransformQuerySegment.predecessor"><code class="name flex">
<span>def <span class="ident">predecessor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predecessor(self):
    if self.filename is None:
        if len(self.query):
            p = TransformQuerySegment(
                header=self.header, query=self.query[:-1], filename=None
            )
            r = TransformQuerySegment(
                header=self.header, query=[self.query[-1]], filename=None
            )
            return p, r
        else:
            return None, None
    else:
        p = TransformQuerySegment(
            header=self.header, query=self.query, filename=None
        )
        r = TransformQuerySegment(
            header=self.header, query=[], filename=self.filename
        )
        return p, r</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="liquer" href="index.html">liquer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="liquer.parser.all_splits" href="#liquer.parser.all_splits">all_splits</a></code></li>
<li><code><a title="liquer.parser.decode" href="#liquer.parser.decode">decode</a></code></li>
<li><code><a title="liquer.parser.decode_token" href="#liquer.parser.decode_token">decode_token</a></code></li>
<li><code><a title="liquer.parser.encode" href="#liquer.parser.encode">encode</a></code></li>
<li><code><a title="liquer.parser.encode_token" href="#liquer.parser.encode_token">encode_token</a></code></li>
<li><code><a title="liquer.parser.indent" href="#liquer.parser.indent">indent</a></code></li>
<li><code><a title="liquer.parser.list_indent" href="#liquer.parser.list_indent">list_indent</a></code></li>
<li><code><a title="liquer.parser.parse" href="#liquer.parser.parse">parse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="liquer.parser.ActionParameter" href="#liquer.parser.ActionParameter">ActionParameter</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.ActionParameter.clean_position" href="#liquer.parser.ActionParameter.clean_position">clean_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.ActionRequest" href="#liquer.parser.ActionRequest">ActionRequest</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.ActionRequest.clean_position" href="#liquer.parser.ActionRequest.clean_position">clean_position</a></code></li>
<li><code><a title="liquer.parser.ActionRequest.encode" href="#liquer.parser.ActionRequest.encode">encode</a></code></li>
<li><code><a title="liquer.parser.ActionRequest.from_arguments" href="#liquer.parser.ActionRequest.from_arguments">from_arguments</a></code></li>
<li><code><a title="liquer.parser.ActionRequest.from_list" href="#liquer.parser.ActionRequest.from_list">from_list</a></code></li>
<li><code><a title="liquer.parser.ActionRequest.to_list" href="#liquer.parser.ActionRequest.to_list">to_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.ExpandedActionParameter" href="#liquer.parser.ExpandedActionParameter">ExpandedActionParameter</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.ExpandedActionParameter.encode" href="#liquer.parser.ExpandedActionParameter.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.LinkActionParameter" href="#liquer.parser.LinkActionParameter">LinkActionParameter</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.LinkActionParameter.encode" href="#liquer.parser.LinkActionParameter.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.Position" href="#liquer.parser.Position">Position</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.Position.from_dict" href="#liquer.parser.Position.from_dict">from_dict</a></code></li>
<li><code><a title="liquer.parser.Position.from_loc" href="#liquer.parser.Position.from_loc">from_loc</a></code></li>
<li><code><a title="liquer.parser.Position.to_dict" href="#liquer.parser.Position.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.Query" href="#liquer.parser.Query">Query</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.Query.action" href="#liquer.parser.Query.action">action</a></code></li>
<li><code><a title="liquer.parser.Query.all_predecessors" href="#liquer.parser.Query.all_predecessors">all_predecessors</a></code></li>
<li><code><a title="liquer.parser.Query.clean_position" href="#liquer.parser.Query.clean_position">clean_position</a></code></li>
<li><code><a title="liquer.parser.Query.create_segment" href="#liquer.parser.Query.create_segment">create_segment</a></code></li>
<li><code><a title="liquer.parser.Query.encode" href="#liquer.parser.Query.encode">encode</a></code></li>
<li><code><a title="liquer.parser.Query.extension" href="#liquer.parser.Query.extension">extension</a></code></li>
<li><code><a title="liquer.parser.Query.filename" href="#liquer.parser.Query.filename">filename</a></code></li>
<li><code><a title="liquer.parser.Query.is_action_request" href="#liquer.parser.Query.is_action_request">is_action_request</a></code></li>
<li><code><a title="liquer.parser.Query.is_empty" href="#liquer.parser.Query.is_empty">is_empty</a></code></li>
<li><code><a title="liquer.parser.Query.is_resource_query" href="#liquer.parser.Query.is_resource_query">is_resource_query</a></code></li>
<li><code><a title="liquer.parser.Query.is_transform_query" href="#liquer.parser.Query.is_transform_query">is_transform_query</a></code></li>
<li><code><a title="liquer.parser.Query.last_transform_query_segment" href="#liquer.parser.Query.last_transform_query_segment">last_transform_query_segment</a></code></li>
<li><code><a title="liquer.parser.Query.predecessor" href="#liquer.parser.Query.predecessor">predecessor</a></code></li>
<li><code><a title="liquer.parser.Query.resource_query" href="#liquer.parser.Query.resource_query">resource_query</a></code></li>
<li><code><a title="liquer.parser.Query.short" href="#liquer.parser.Query.short">short</a></code></li>
<li><code><a title="liquer.parser.Query.to_absolute" href="#liquer.parser.Query.to_absolute">to_absolute</a></code></li>
<li><code><a title="liquer.parser.Query.transform_query" href="#liquer.parser.Query.transform_query">transform_query</a></code></li>
<li><code><a title="liquer.parser.Query.with_action" href="#liquer.parser.Query.with_action">with_action</a></code></li>
<li><code><a title="liquer.parser.Query.without_filename" href="#liquer.parser.Query.without_filename">without_filename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.QueryException" href="#liquer.parser.QueryException">QueryException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.parser.ResourceName" href="#liquer.parser.ResourceName">ResourceName</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.ResourceName.encode" href="#liquer.parser.ResourceName.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.ResourceQuerySegment" href="#liquer.parser.ResourceQuerySegment">ResourceQuerySegment</a></code></h4>
<ul class="two-column">
<li><code><a title="liquer.parser.ResourceQuerySegment.clean_position" href="#liquer.parser.ResourceQuerySegment.clean_position">clean_position</a></code></li>
<li><code><a title="liquer.parser.ResourceQuerySegment.encode" href="#liquer.parser.ResourceQuerySegment.encode">encode</a></code></li>
<li><code><a title="liquer.parser.ResourceQuerySegment.path" href="#liquer.parser.ResourceQuerySegment.path">path</a></code></li>
<li><code><a title="liquer.parser.ResourceQuerySegment.position" href="#liquer.parser.ResourceQuerySegment.position">position</a></code></li>
<li><code><a title="liquer.parser.ResourceQuerySegment.segment_name" href="#liquer.parser.ResourceQuerySegment.segment_name">segment_name</a></code></li>
<li><code><a title="liquer.parser.ResourceQuerySegment.to_absolute" href="#liquer.parser.ResourceQuerySegment.to_absolute">to_absolute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.SegmentHeader" href="#liquer.parser.SegmentHeader">SegmentHeader</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.SegmentHeader.clean_position" href="#liquer.parser.SegmentHeader.clean_position">clean_position</a></code></li>
<li><code><a title="liquer.parser.SegmentHeader.encode" href="#liquer.parser.SegmentHeader.encode">encode</a></code></li>
<li><code><a title="liquer.parser.SegmentHeader.is_trivial" href="#liquer.parser.SegmentHeader.is_trivial">is_trivial</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.StringActionParameter" href="#liquer.parser.StringActionParameter">StringActionParameter</a></code></h4>
<ul class="">
<li><code><a title="liquer.parser.StringActionParameter.encode" href="#liquer.parser.StringActionParameter.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.parser.TransformQuerySegment" href="#liquer.parser.TransformQuerySegment">TransformQuerySegment</a></code></h4>
<ul class="two-column">
<li><code><a title="liquer.parser.TransformQuerySegment.action" href="#liquer.parser.TransformQuerySegment.action">action</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.append" href="#liquer.parser.TransformQuerySegment.append">append</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.clean_position" href="#liquer.parser.TransformQuerySegment.clean_position">clean_position</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.encode" href="#liquer.parser.TransformQuerySegment.encode">encode</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.is_action_request" href="#liquer.parser.TransformQuerySegment.is_action_request">is_action_request</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.is_empty" href="#liquer.parser.TransformQuerySegment.is_empty">is_empty</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.is_filename" href="#liquer.parser.TransformQuerySegment.is_filename">is_filename</a></code></li>
<li><code><a title="liquer.parser.TransformQuerySegment.predecessor" href="#liquer.parser.TransformQuerySegment.predecessor">predecessor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>