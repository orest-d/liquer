<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>liquer.recipes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>liquer.recipes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from liquer.store import (
    get_store,
    Store,
    KeyNotFoundStoreException,
    StoreException,
    join_key,
    parent_key,
)
from liquer.context import get_context
from liquer.parser import parse
from liquer.constants import Status
from liquer.metadata import Metadata, StoreSyncMetadata
import json
import hashlib

from copy import deepcopy
import traceback
from yaml import load, dump

try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper


class RecipeException(Exception):
    def __init__(self, message, key=None):
        self.original_message = message
        if key is not None:
            message += f&#34;:\n  key: &#39;{key}&#39;&#34;

        super().__init__(message)
        self.key = key


class RecipeRegistry(object):
    &#34;&#34;&#34;Registry of recipes&#34;&#34;&#34;

    def __init__(self):
        self.recipe_dictionary = {}

    def register(self, recipe):
        &#34;&#34;&#34;Register a Recipe class in the registry&#34;&#34;&#34;
        if recipe.recipe_type() in self.recipe_dictionary:
            print(f&#34;WARNING: Recipe type &#39;{recipe.recipe_type()}&#39; already registered&#34;)
        self.recipe_dictionary[recipe.recipe_type()] = recipe

    def from_dict(self, d):
        &#34;&#34;&#34;Construct a Recipe instance from a recipe description
        Recipe description is typically a dictionary. The &#39;type&#39; item of the dictionary is matched with recipe_type()
        class-method result for known recipes to find a suitable recipe constructor.
        &#34;&#34;&#34;
        if type(d) != dict:
            raise Exception(
                &#34;Dictionary expected as recipe definition for registered recipes&#34;
            )
        if &#34;type&#34; not in d:
            raise Exception(&#34;Recipe definition is lacking a type&#34;)
        if d[&#34;type&#34;] not in self.recipe_dictionary:
            t = d[&#34;type&#34;]
            raise Exception(f&#34;Recipe type &#39;{t}&#39; not registered&#34;)
        return self.recipe_dictionary[d[&#34;type&#34;]].from_dict(d)


_recipe_registry = None


def recipe_registry():
    &#34;&#34;&#34;Returns the global recipe registry (singleton)&#34;&#34;&#34;
    global _recipe_registry
    if _recipe_registry is None:
        _recipe_registry = RecipeRegistry()
    return _recipe_registry


def register_recipe(recipe):
    &#34;&#34;&#34;Function to register new recipe type.&#34;&#34;&#34;
    recipe_registry().register(recipe)


class Recipe:
    def __init__(self, d):
        if type(d) != dict:
            raise Exception(&#34;Dictionary expected as recipe definition&#34;)
        if &#34;type&#34; in d:
            if d[&#34;type&#34;] != self.recipe_type():
                t = d[&#34;type&#34;]
                raise Exception(
                    f&#34;Recipe {self.recipe_type()} received definition with type=&#39;{t}&#39;&#34;
                )
        self.data = d

    @classmethod
    def recipe_type(self):
        return &#34;empty&#34;

    @classmethod
    def from_dict(cls, d):
        return cls(d)

    def version(self):
        h = hashlib.md5()
        txt = json.dumps(self.data, sort_keys=True, indent=2)
        h.update(txt.encode(&#34;utf-8&#34;))
        return &#34;md5:&#34; + h.hexdigest()

    def recipe_name(self):
        return self.data.get(&#34;recipe_name&#34;, &#34;&#34;)

    def provides(self):
        return self.data.get(&#34;provides&#34;, [])

    def can_create(self, name):
        return name in self.provides()

    def metadata(self, key):
        metadata = Metadata(dict())
        if &#34;title&#34; in self.data:
            metadata.metadata[&#34;title&#34;] = self.data[&#34;title&#34;]
        if &#34;description&#34; in self.data:
            metadata.metadata[&#34;description&#34;] = self.data[&#34;description&#34;]
        metadata.key = key
        metadata.metadata[&#34;recipes_key&#34;] = self.data.get(&#34;recipes_key&#34;)
        metadata.metadata[&#34;recipes_directory&#34;] = self.data.get(&#34;recipes_directory&#34;)
        metadata.metadata[&#34;recipe_name&#34;] = self.data.get(&#34;recipe_name&#34;)
        return metadata.as_dict()

    def make(self, key, context=None):
        raise RecipeException(&#34;Recipe undefined (make)&#34;, key=key)

    def is_volatile(self):
        return self.data.get(&#34;volatile&#34;, False)


def resolve_recipe_definition(r, directory, metadata):
    if type(r) == str:
        try:
            query = parse(r).to_absolute(directory)
            filename = query.filename()
            return dict(
                type=&#34;query&#34;,
                query=query.encode(),
                original_query=r,
                CWD=directory,
                filename=filename,
                provides=[filename],
            )
        except:
            metadata.warning(
                f&#34;Can&#39;t resolve recipe &#39;{r}&#39;&#34;, traceback=traceback.format_exc()
            )
            print(f&#34;Can&#39;t resolve recipe &#39;{r}&#39;&#34;)
            traceback.print_exc()
            return None

    elif isinstance(r, dict):
        if r.get(&#34;type&#34;) in (None, &#34;query&#34;) and &#34;query&#34; in r:
            try:
                query = parse(r[&#34;query&#34;]).to_absolute(directory)
                filename = r.get(&#34;filename&#34;, query.filename())
                title = r.get(&#34;title&#34;, filename)
                description = r.get(
                    &#34;description&#34;, f&#39;Generated from query: {r[&#34;query&#34;]}&#39;
                )
                rkey = join_key(directory, filename)
                return dict(
                    type=&#34;query&#34;,
                    query=query.encode(),
                    original_query=r[&#34;query&#34;],
                    title=title,
                    description=description,
                    CWD=directory,
                    filename=filename,
                    provides=[filename],
                )
            except:
                metadata.warning(
                    f&#34;Can&#39;t resolve query recipe&#34;, traceback=traceback.format_exc()
                )
                traceback.print_exc()
    else:
        print(f&#34;Unsupported recipe type: {type(r)}&#34;)
    if &#34;filename&#34; in r and &#34;provides&#34; not in r:
        r[&#34;provides&#34;] = [r[&#34;filename&#34;]]
    return r


class QueryRecipe(Recipe):
    @classmethod
    def recipe_type(self):
        return &#34;query&#34;

    @classmethod
    def from_dict(cls, d):
        return cls(d)

    def metadata(self, key):
        metadata = Metadata(super().metadata(key))
        metadata.query = self.data[&#34;query&#34;]
        return metadata.as_dict()

    def make(self, key, store=None, context=None):
        context = get_context(context)
        if store is None:
            store = context.store()
        context.evaluate(
            self.data[&#34;query&#34;],
            store_key=key,
            store_to=store,
        )


register_recipe(QueryRecipe)


class RecipeStore(Store):
    def __init__(self, store, recipes=None, context=None):
        self.substore = store
        self.substore.parent_store = self
        self._recipes = {} if recipes is None else recipes
        self.context = context

    def sync(self):
        self.substore.sync()

    def get_context(self):
        if self.context is None:
            return get_context()
        else:
            return self.context.new_empty()

    def with_context(self, context):
        return RecipeStore(self.substore, recipes=self.recipes, context=context)

    def mount_recipe(self, key, recipe):
        self._recipes[key] = recipe
        return self

    def ignore(self, key):
        return False

    def make(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)
        query = self.recipes().get(key)
        if query is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        target_resource_directory = self.parent_key(key)
        target_file = self.key_name(key)
        self.get_context().evaluate(
            query,
            store_key=key,
            store_to=self,
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def recipes(self):
        return self._recipes

    def recipe_metadata(self, key):
        return {}

    def is_supported(self, key):
        if self.ignore(key):
            return False
        return self.substore.is_supported(key)

    def get_bytes(self, key):
        if self.ignore(key):
            return None
        if self.substore.contains(key):
            return self.substore.get_bytes(key)
        self.make(key)
        return self.substore.get_bytes(key)

    def get_metadata(self, key):
        if self.ignore(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        try:
            metadata = self.substore.get_metadata(key)
            if metadata is not None:
                return metadata
        except KeyNotFoundStoreException:
            pass

        if self.is_dir(key):
            return self.finalize_metadata(
                self.default_metadata(key=key, is_dir=True), key=key, is_dir=True
            )
        if key in self.recipes():
            metadata = self.recipe_metadata(key)
            try:
                sub_metadata = self.substore.get_metadata(key)
                if sub_metadata is not None:
                    metadata.update(sub_metadata)
            except:
                pass
            return self.finalize_metadata(metadata, key=key, is_dir=False)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store into it&#34;)
        self.substore.store(
            key, data, self.finalize_metadata(metadata, key=key, is_dir=True, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store metadata into it&#34;)
        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(key)
        self.on_removed(key)

    def contains(self, key):
        if self.ignore(key):
            return False
        if self.substore.contains(key):
            return True
        for k in self.recipes():
            if k == key or k.startswith(key + &#34;/&#34;):
                return True
        return False

    def is_dir(self, key):
        if self.ignore(key):
            return False
        if self.substore.is_dir(key):
            return True
        for k in self.recipes():
            if k == key:
                return False
            if k.startswith(key + &#34;/&#34;):
                return True
        return False

    def keys(self):
        return [
            key
            for key in sorted(set(self.substore.keys()).union(self.recipes().keys()))
            if not self.ignore(key)
        ]

    def listdir(self, key):
        if self.ignore(key):
            return []
        d = set(self.substore.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for k in self.recipes().keys():
            if k.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = k.split(&#34;/&#34;)
                d.add(v[key_depth])
        return [key for key in sorted(d) if not self.ignore(key)]

    def makedir(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t makedir&#34;)
        self.substore.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t openbin&#34;)
        return self.substore.openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Recipe store on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;RecipeStore({repr(self.substore)}, recipes={repr(self.recipes())})&#34;


class OldRecipeSpecStore(RecipeStore):
    RECIPES_FILE = &#34;recipes.yaml&#34;
    LOCAL_RECIPES = &#34;RECIPES&#34;
    STATUS_FILE = &#34;recipes_status.txt&#34;

    def __init__(self, store, context=None):
        RecipeStore.__init__(self, store, recipes=None, context=context)
        self.recipes_info = {}
        self.update_recipes()
        self.update_all_status_files()

    def sync(self):
        self.update_recipes()
        self.update_all_status_files()
        self.substore.sync()

    def update_all_status_files(self):
        if self.STATUS_FILE is not None:
            for dir_key in set(self.parent_key(key) for key in self.recipes().keys()):
                self.create_status(dir_key)

    def ignore(self, key):
        if key is None:
            return True
        return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))

    def recipe_metadata(self, key):
        metadata = deepcopy(self.recipes_info.get(key, {}))
        metadata[&#34;status&#34;] = Status.RECIPE.value
        if metadata.get(&#34;query&#34;) is not None:
            metadata[&#34;has_recipe&#34;] = True
            if self.recipes_info[key].get(&#34;recipes_directory&#34;) == self.LOCAL_RECIPES:
                metadata[&#34;recipes_directory&#34;] = &#34;&#34;
            else:
                metadata[&#34;recipes_directory&#34;] = self.recipes_info[key].get(
                    &#34;recipes_directory&#34;
                )
        return metadata

    def make(self, key):
        super().make(key)
        metadata = self.substore.get_metadata(key)
        status = metadata.get(&#34;status&#34;, Status.RECIPE.value)
        fileinfo = metadata[&#34;fileinfo&#34;]
        metadata.update(self.recipe_metadata(key))
        metadata[&#34;status&#34;] = status
        metadata[&#34;fileinfo&#34;] = fileinfo
        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def update_recipes(self):
        import yaml

        recipes = {}
        for key in self.substore.keys():
            spec = None
            if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
                key
            ):
                spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
            recipes_key = key
            if spec is not None:
                parent = self.parent_key(key)
                for directory, items in spec.items():
                    for r in items:
                        if type(r) == str:
                            try:
                                query = parse(r)
                                filename = query.filename()
                                parent = self.parent_key(key)
                                if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                    parent += &#34;/&#34;
                                rkey = (
                                    f&#34;{parent}{filename}&#34;
                                    if directory == self.LOCAL_RECIPES
                                    else f&#34;{parent}{directory}/{filename}&#34;
                                )
                                recipes[rkey] = r
                                self.recipes_info[rkey] = dict(
                                    query=r,
                                    title=filename,
                                    description=&#34;&#34;,
                                    recipes_key=recipes_key,
                                    recipes_directory=directory,
                                )
                            except:
                                traceback.print_exc()
                        elif isinstance(r, dict):
                            try:
                                query = parse(r[&#34;query&#34;])
                                filename = r.get(&#34;filename&#34;, query.filename())
                                title = r.get(&#34;title&#34;, filename)
                                description = r.get(&#34;description&#34;, r[&#34;query&#34;])
                                parent = self.parent_key(key)
                                if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                    parent += &#34;/&#34;
                                rkey = (
                                    f&#34;{parent}{filename}&#34;
                                    if directory == self.LOCAL_RECIPES
                                    else f&#34;{parent}{directory}/{filename}&#34;
                                )
                                recipes[rkey] = r[&#34;query&#34;]
                                self.recipes_info[rkey] = dict(
                                    query=r[&#34;query&#34;],
                                    title=title,
                                    description=description,
                                    recipes_key=recipes_key,
                                    recipes_directory=directory,
                                )
                            except:
                                traceback.print_exc()
                        else:
                            print(f&#34;Unsupported recipe type: {type(r)}&#34;)
        self._recipes = recipes
        return recipes

    def create_status_text(self, dir_key):
        txt = &#34;&#34;
        if self.substore.is_dir(dir_key):
            for d in self.listdir(dir_key):
                key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
                if d == self.STATUS_FILE:
                    continue
                if not self.is_dir(key):
                    metadata = self.get_metadata(key)
                    if metadata is None:
                        txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                    else:
                        try:
                            t = metadata.get(&#34;created&#34;)
                            if t in (&#34;&#34;, None):
                                t = metadata[&#34;updated&#34;]
                            time = util.format_datetime(util.to_datetime(t))
                        except:
                            time = &#34;&#34;
                        status = metadata.get(&#34;status&#34;, Status.NONE.value)
                        message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                        if status == Status.READY.value:
                            try:
                                message = metadata[&#34;data_characteristics&#34;][
                                    &#34;description&#34;
                                ]
                            except:
                                pass
                        if &#34;\n&#34; in message:
                            txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                            txt += &#34;\n=============================================================\n&#34;
                            txt += message
                            txt += &#34;\n=============================================================\n\n&#34;
                        else:
                            txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                                time,
                                status,
                                d,
                                message,
                            )
                        trace = &#34;&#34;
                        for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                            &#34;child_log&#34;, []
                        ):
                            tb = entry.get(&#34;traceback&#34;)
                            if tb is not None:
                                if len(tb):
                                    if &#34;timestamp&#34; in entry:
                                        trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                    if &#34;origin&#34; in entry:
                                        trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                    if &#34;message&#34; in entry:
                                        trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                    trace += &#34;\n&#34;
                                    trace += tb
                                    tb += &#34;\n------------------------\n&#34;
                        if len(trace):
                            txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                            txt += trace
                            txt += &#34;\n#############################################################\n\n&#34;
        return txt

    def create_status(self, key):
        if self.key_name(key) != self.STATUS_FILE:
            if not self.is_dir(key):
                key = self.parent_key(key)
            status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
            data = self.create_status_text(key).encode(&#34;utf-8&#34;)
            self.substore.store(
                status_key,
                data,
                dict(
                    type_identifier=&#34;text&#34;,
                    status=Status.SIDE_EFFECT.value,
                    title=f&#34;Status of &#39;{key}&#39;&#34;,
                    description=&#34;This file is generated automatically by the recipe store&#34;,
                ),
            )

    def on_metadata_changed(self, key):
        super().on_metadata_changed(key)
        if self.STATUS_FILE is not None:
            if self.key_name(key) == self.RECIPES_FILE:
                self.update_all_status_files()
            elif self.key_name(key) != self.STATUS_FILE:
                self.create_status(key)

    def on_data_changed(self, key):
        super().on_data_changed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)

    def on_removed(self, key):
        super().on_removed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)


class NewRecipeSpecStore(Store):
    RECIPES_FILE = &#34;recipes.yaml&#34;
    LOCAL_RECIPES = &#34;RECIPES&#34;
    STATUS_FILE = &#34;recipes_status.txt&#34;

    def __init__(self, store):
        self.substore = store
        self.substore.parent_store = self
        self._recipes = {}
        self.update_recipes()
        self.update_all_status_files()

    def sync(self):
        self.update_recipes()
        self.update_all_status_files()
        self.substore.sync()

    def recipes(self):
        return self._recipes

    def make(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

        recipe = self.recipes().get(key)
        if recipe is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        try:
            #recipe.make(key, store=self.substore)
            recipe.make(self.to_root_key(key))
            is_error = False
        except:
            is_error = True
            trace = traceback.format_exc()
            traceback.print_exc()

        metadata = self.substore.get_metadata(key)
        recipe_metadata = self.recipe_metadata(key)

        for k in [
            &#34;status&#34;,
            &#34;fileinfo&#34;,
            &#34;message&#34;,
            &#34;is_error&#34;,
            &#34;log&#34;,
            &#34;child_log&#34;,
            &#34;dependencies&#34;,
        ]:
            if k in recipe_metadata:
                del recipe_metadata[k]

        metadata.update(recipe_metadata)
        m = Metadata(metadata)
        if is_error:
            m.exception(f&#34;Error evaluating recipe&#34;, traceback=trace)
        else:
            if m.status == Status.NONE.value:
                m.status = Status.READY.value
        m.add_recipe_dependency(recipe)
        metadata = m.as_dict()
        self.substore.store_metadata(key, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def recipe_metadata(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

        recipe = self.recipes().get(key)
        if recipe is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        metadata = recipe.metadata(key)
        metadata[&#34;status&#34;] = Status.RECIPE.value
        metadata[&#34;has_recipe&#34;] = True

        return metadata

    def is_supported(self, key):
        if self.ignore(key):
            return False
        return self.substore.is_supported(key)

    def get_bytes(self, key):
        if self.ignore(key):
            return None
        if self.substore.contains(key):
            return self.substore.get_bytes(key)
        self.make(key)
        return self.substore.get_bytes(key)

    def get_metadata(self, key):
        if self.ignore(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        try:
            metadata = self.substore.get_metadata(key)
            if metadata is not None:
                return metadata
        except KeyNotFoundStoreException:
            pass
        if self.is_dir(key):
            return self.finalize_metadata(
                self.default_metadata(key=key, is_dir=True), key=key, is_dir=True
            )
        if key in self.recipes():
            metadata = self.recipe_metadata(key)
            try:
                sub_metadata = self.substore.get_metadata(key)
                if sub_metadata is not None:
                    metadata.update(sub_metadata)
            except:
                pass
            return self.finalize_metadata(metadata, key=key, is_dir=False)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store into it&#34;)
        self.substore.store(
            key, data, self.finalize_metadata(metadata, key=key, is_dir=True, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store metadata into it&#34;)
        if key in self.recipes():
            rm = self.recipe_metadata(key)
            metadata[&#34;title&#34;] = rm.get(&#34;title&#34;, metadata.get(&#34;title&#34;))
            metadata[&#34;description&#34;] = rm.get(&#34;description&#34;, metadata.get(&#34;description&#34;))

        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(key)
        self.on_removed(key)

    def contains(self, key):
        if self.ignore(key):
            return False
        if self.substore.contains(key):
            return True
        for k in self.recipes():
            if k == key or k.startswith(key + &#34;/&#34;):
                return True
        return False

    def is_dir(self, key):
        if self.ignore(key):
            return False
        if self.substore.is_dir(key):
            return True
        for k in self.recipes():
            if k == key:
                return False
            if k.startswith(key + &#34;/&#34;):
                return True
        return False

    def keys(self):
        return [
            key
            for key in sorted(set(self.substore.keys()).union(self.recipes().keys()))
            if not self.ignore(key)
        ]

    def listdir(self, key):
        if self.ignore(key):
            return []
        d = set(self.substore.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for k in self.recipes().keys():
            if k.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = k.split(&#34;/&#34;)
                d.add(v[key_depth])
        return [key for key in sorted(d) if not self.ignore(key)]

    def makedir(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t makedir&#34;)
        self.substore.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t openbin&#34;)
        return self.substore.openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Recipe spec store n ({self.substore})&#34;

    def __repr__(self):
        return f&#34;RecipeSpecStore({repr(self.substore)})&#34;

    def update_all_status_files(self):
        if self.STATUS_FILE is not None:
            for dir_key in set(parent_key(key) for key in self.recipes().keys()):
                self.create_status(dir_key)

    def ignore(self, key):
        if key is None:
            return True
        return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))

    def update_recipes(self):
        import yaml

        recipes = {}

        for key in self.substore.keys():
            spec = None
            if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
                key
            ):
                spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
                recipes_key = key
                metadata = StoreSyncMetadata(self.substore, key)
                metadata.clear_log()
                metadata.info(f&#34;Update recipes for key &#39;{key}&#39;&#34;)
                if spec is not None:
                    parent = parent_key(key)
                    for directory, items in spec.items():
                        for i, r in enumerate(items):
                            cwd = (
                                parent
                                if directory == self.LOCAL_RECIPES
                                else join_key(parent, directory)
                            )
                            d = resolve_recipe_definition(r, self.to_root_key(cwd), metadata)
                            if d is None:
                                metadata.warning(
                                    f&#34;Failed parsing the definition of recipe {i+1} in {directory}&#34;
                                )
                            d[&#34;recipe_name&#34;] = (
                                self.to_root_key(recipes_key)
                                + f&#34;/-Ryaml/{directory}/{i}#&#34;
                                + d.get(&#34;filename&#34;, &#34;&#34;)
                            )
                            d[&#34;recipes_key&#34;] = self.to_root_key(recipes_key)

                            
                            d[&#34;recipes_directory&#34;] = (
                                &#34;&#34; if directory == self.LOCAL_RECIPES else directory
                            )

                            try:
                                recipe = recipe_registry().from_dict(d)
                            except:
                                metadata.warning(
                                    f&#34;Failed parsing recipe {i+1} in {directory}&#34;,
                                    traceback=traceback.format_exc(),
                                )
                            for name in recipe.provides():
                                key = join_key(cwd, name)
                                recipes[key] = recipe
        self._recipes = recipes
        return recipes

    def create_status_text(self, dir_key):
        txt = &#34;&#34;
        if self.substore.is_dir(dir_key):
            for d in self.listdir(dir_key):
                key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
                if d == self.STATUS_FILE:
                    continue
                if not self.is_dir(key):
                    metadata = self.get_metadata(key)
                    if metadata is None:
                        txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                    else:
                        try:
                            t = metadata.get(&#34;created&#34;)
                            if t in (&#34;&#34;, None):
                                t = metadata[&#34;updated&#34;]
                            time = util.format_datetime(util.to_datetime(t))
                        except:
                            time = &#34;&#34;
                        status = metadata.get(&#34;status&#34;, Status.NONE.value)
                        message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                        if status == Status.READY.value:
                            try:
                                message = metadata[&#34;data_characteristics&#34;][
                                    &#34;description&#34;
                                ]
                            except:
                                pass
                        if &#34;\n&#34; in message:
                            txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                            txt += &#34;\n=============================================================\n&#34;
                            txt += message
                            txt += &#34;\n=============================================================\n\n&#34;
                        else:
                            txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                                time,
                                status,
                                d,
                                message,
                            )
                        trace = &#34;&#34;
                        for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                            &#34;child_log&#34;, []
                        ):
                            tb = entry.get(&#34;traceback&#34;)
                            if tb is not None:
                                if len(tb):
                                    if &#34;timestamp&#34; in entry:
                                        trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                    if &#34;origin&#34; in entry:
                                        trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                    if &#34;message&#34; in entry:
                                        trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                    trace += &#34;\n&#34;
                                    trace += tb
                                    tb += &#34;\n------------------------\n&#34;
                        if len(trace):
                            txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                            txt += trace
                            txt += &#34;\n#############################################################\n\n&#34;
        return txt

    def create_status(self, key):
        if self.key_name(key) != self.STATUS_FILE:
            if not self.is_dir(key):
                key = self.parent_key(key)
            status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
            data = self.create_status_text(key).encode(&#34;utf-8&#34;)
            self.substore.store(
                status_key,
                data,
                dict(
                    type_identifier=&#34;text&#34;,
                    status=Status.SIDE_EFFECT.value,
                    title=f&#34;Status of &#39;{key}&#39;&#34;,
                    description=&#34;This file is generated automatically by the recipe store&#34;,
                ),
            )

    def on_metadata_changed(self, key):
        super().on_metadata_changed(key)
        if self.STATUS_FILE is not None:
            if self.key_name(key) == self.RECIPES_FILE:
                self.update_all_status_files()
            elif self.key_name(key) != self.STATUS_FILE:
                self.create_status(key)

    def on_data_changed(self, key):
        super().on_data_changed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)

    def on_removed(self, key):
        super().on_removed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)


class RecipeSpecStore(NewRecipeSpecStore):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="liquer.recipes.recipe_registry"><code class="name flex">
<span>def <span class="ident">recipe_registry</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global recipe registry (singleton)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe_registry():
    &#34;&#34;&#34;Returns the global recipe registry (singleton)&#34;&#34;&#34;
    global _recipe_registry
    if _recipe_registry is None:
        _recipe_registry = RecipeRegistry()
    return _recipe_registry</code></pre>
</details>
</dd>
<dt id="liquer.recipes.register_recipe"><code class="name flex">
<span>def <span class="ident">register_recipe</span></span>(<span>recipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to register new recipe type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_recipe(recipe):
    &#34;&#34;&#34;Function to register new recipe type.&#34;&#34;&#34;
    recipe_registry().register(recipe)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.resolve_recipe_definition"><code class="name flex">
<span>def <span class="ident">resolve_recipe_definition</span></span>(<span>r, directory, metadata)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_recipe_definition(r, directory, metadata):
    if type(r) == str:
        try:
            query = parse(r).to_absolute(directory)
            filename = query.filename()
            return dict(
                type=&#34;query&#34;,
                query=query.encode(),
                original_query=r,
                CWD=directory,
                filename=filename,
                provides=[filename],
            )
        except:
            metadata.warning(
                f&#34;Can&#39;t resolve recipe &#39;{r}&#39;&#34;, traceback=traceback.format_exc()
            )
            print(f&#34;Can&#39;t resolve recipe &#39;{r}&#39;&#34;)
            traceback.print_exc()
            return None

    elif isinstance(r, dict):
        if r.get(&#34;type&#34;) in (None, &#34;query&#34;) and &#34;query&#34; in r:
            try:
                query = parse(r[&#34;query&#34;]).to_absolute(directory)
                filename = r.get(&#34;filename&#34;, query.filename())
                title = r.get(&#34;title&#34;, filename)
                description = r.get(
                    &#34;description&#34;, f&#39;Generated from query: {r[&#34;query&#34;]}&#39;
                )
                rkey = join_key(directory, filename)
                return dict(
                    type=&#34;query&#34;,
                    query=query.encode(),
                    original_query=r[&#34;query&#34;],
                    title=title,
                    description=description,
                    CWD=directory,
                    filename=filename,
                    provides=[filename],
                )
            except:
                metadata.warning(
                    f&#34;Can&#39;t resolve query recipe&#34;, traceback=traceback.format_exc()
                )
                traceback.print_exc()
    else:
        print(f&#34;Unsupported recipe type: {type(r)}&#34;)
    if &#34;filename&#34; in r and &#34;provides&#34; not in r:
        r[&#34;provides&#34;] = [r[&#34;filename&#34;]]
    return r</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="liquer.recipes.NewRecipeSpecStore"><code class="flex name class">
<span>class <span class="ident">NewRecipeSpecStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NewRecipeSpecStore(Store):
    RECIPES_FILE = &#34;recipes.yaml&#34;
    LOCAL_RECIPES = &#34;RECIPES&#34;
    STATUS_FILE = &#34;recipes_status.txt&#34;

    def __init__(self, store):
        self.substore = store
        self.substore.parent_store = self
        self._recipes = {}
        self.update_recipes()
        self.update_all_status_files()

    def sync(self):
        self.update_recipes()
        self.update_all_status_files()
        self.substore.sync()

    def recipes(self):
        return self._recipes

    def make(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

        recipe = self.recipes().get(key)
        if recipe is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        try:
            #recipe.make(key, store=self.substore)
            recipe.make(self.to_root_key(key))
            is_error = False
        except:
            is_error = True
            trace = traceback.format_exc()
            traceback.print_exc()

        metadata = self.substore.get_metadata(key)
        recipe_metadata = self.recipe_metadata(key)

        for k in [
            &#34;status&#34;,
            &#34;fileinfo&#34;,
            &#34;message&#34;,
            &#34;is_error&#34;,
            &#34;log&#34;,
            &#34;child_log&#34;,
            &#34;dependencies&#34;,
        ]:
            if k in recipe_metadata:
                del recipe_metadata[k]

        metadata.update(recipe_metadata)
        m = Metadata(metadata)
        if is_error:
            m.exception(f&#34;Error evaluating recipe&#34;, traceback=trace)
        else:
            if m.status == Status.NONE.value:
                m.status = Status.READY.value
        m.add_recipe_dependency(recipe)
        metadata = m.as_dict()
        self.substore.store_metadata(key, metadata)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def recipe_metadata(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

        recipe = self.recipes().get(key)
        if recipe is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        metadata = recipe.metadata(key)
        metadata[&#34;status&#34;] = Status.RECIPE.value
        metadata[&#34;has_recipe&#34;] = True

        return metadata

    def is_supported(self, key):
        if self.ignore(key):
            return False
        return self.substore.is_supported(key)

    def get_bytes(self, key):
        if self.ignore(key):
            return None
        if self.substore.contains(key):
            return self.substore.get_bytes(key)
        self.make(key)
        return self.substore.get_bytes(key)

    def get_metadata(self, key):
        if self.ignore(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        try:
            metadata = self.substore.get_metadata(key)
            if metadata is not None:
                return metadata
        except KeyNotFoundStoreException:
            pass
        if self.is_dir(key):
            return self.finalize_metadata(
                self.default_metadata(key=key, is_dir=True), key=key, is_dir=True
            )
        if key in self.recipes():
            metadata = self.recipe_metadata(key)
            try:
                sub_metadata = self.substore.get_metadata(key)
                if sub_metadata is not None:
                    metadata.update(sub_metadata)
            except:
                pass
            return self.finalize_metadata(metadata, key=key, is_dir=False)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store into it&#34;)
        self.substore.store(
            key, data, self.finalize_metadata(metadata, key=key, is_dir=True, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store metadata into it&#34;)
        if key in self.recipes():
            rm = self.recipe_metadata(key)
            metadata[&#34;title&#34;] = rm.get(&#34;title&#34;, metadata.get(&#34;title&#34;))
            metadata[&#34;description&#34;] = rm.get(&#34;description&#34;, metadata.get(&#34;description&#34;))

        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(key)
        self.on_removed(key)

    def contains(self, key):
        if self.ignore(key):
            return False
        if self.substore.contains(key):
            return True
        for k in self.recipes():
            if k == key or k.startswith(key + &#34;/&#34;):
                return True
        return False

    def is_dir(self, key):
        if self.ignore(key):
            return False
        if self.substore.is_dir(key):
            return True
        for k in self.recipes():
            if k == key:
                return False
            if k.startswith(key + &#34;/&#34;):
                return True
        return False

    def keys(self):
        return [
            key
            for key in sorted(set(self.substore.keys()).union(self.recipes().keys()))
            if not self.ignore(key)
        ]

    def listdir(self, key):
        if self.ignore(key):
            return []
        d = set(self.substore.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for k in self.recipes().keys():
            if k.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = k.split(&#34;/&#34;)
                d.add(v[key_depth])
        return [key for key in sorted(d) if not self.ignore(key)]

    def makedir(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t makedir&#34;)
        self.substore.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t openbin&#34;)
        return self.substore.openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Recipe spec store n ({self.substore})&#34;

    def __repr__(self):
        return f&#34;RecipeSpecStore({repr(self.substore)})&#34;

    def update_all_status_files(self):
        if self.STATUS_FILE is not None:
            for dir_key in set(parent_key(key) for key in self.recipes().keys()):
                self.create_status(dir_key)

    def ignore(self, key):
        if key is None:
            return True
        return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))

    def update_recipes(self):
        import yaml

        recipes = {}

        for key in self.substore.keys():
            spec = None
            if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
                key
            ):
                spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
                recipes_key = key
                metadata = StoreSyncMetadata(self.substore, key)
                metadata.clear_log()
                metadata.info(f&#34;Update recipes for key &#39;{key}&#39;&#34;)
                if spec is not None:
                    parent = parent_key(key)
                    for directory, items in spec.items():
                        for i, r in enumerate(items):
                            cwd = (
                                parent
                                if directory == self.LOCAL_RECIPES
                                else join_key(parent, directory)
                            )
                            d = resolve_recipe_definition(r, self.to_root_key(cwd), metadata)
                            if d is None:
                                metadata.warning(
                                    f&#34;Failed parsing the definition of recipe {i+1} in {directory}&#34;
                                )
                            d[&#34;recipe_name&#34;] = (
                                self.to_root_key(recipes_key)
                                + f&#34;/-Ryaml/{directory}/{i}#&#34;
                                + d.get(&#34;filename&#34;, &#34;&#34;)
                            )
                            d[&#34;recipes_key&#34;] = self.to_root_key(recipes_key)

                            
                            d[&#34;recipes_directory&#34;] = (
                                &#34;&#34; if directory == self.LOCAL_RECIPES else directory
                            )

                            try:
                                recipe = recipe_registry().from_dict(d)
                            except:
                                metadata.warning(
                                    f&#34;Failed parsing recipe {i+1} in {directory}&#34;,
                                    traceback=traceback.format_exc(),
                                )
                            for name in recipe.provides():
                                key = join_key(cwd, name)
                                recipes[key] = recipe
        self._recipes = recipes
        return recipes

    def create_status_text(self, dir_key):
        txt = &#34;&#34;
        if self.substore.is_dir(dir_key):
            for d in self.listdir(dir_key):
                key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
                if d == self.STATUS_FILE:
                    continue
                if not self.is_dir(key):
                    metadata = self.get_metadata(key)
                    if metadata is None:
                        txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                    else:
                        try:
                            t = metadata.get(&#34;created&#34;)
                            if t in (&#34;&#34;, None):
                                t = metadata[&#34;updated&#34;]
                            time = util.format_datetime(util.to_datetime(t))
                        except:
                            time = &#34;&#34;
                        status = metadata.get(&#34;status&#34;, Status.NONE.value)
                        message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                        if status == Status.READY.value:
                            try:
                                message = metadata[&#34;data_characteristics&#34;][
                                    &#34;description&#34;
                                ]
                            except:
                                pass
                        if &#34;\n&#34; in message:
                            txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                            txt += &#34;\n=============================================================\n&#34;
                            txt += message
                            txt += &#34;\n=============================================================\n\n&#34;
                        else:
                            txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                                time,
                                status,
                                d,
                                message,
                            )
                        trace = &#34;&#34;
                        for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                            &#34;child_log&#34;, []
                        ):
                            tb = entry.get(&#34;traceback&#34;)
                            if tb is not None:
                                if len(tb):
                                    if &#34;timestamp&#34; in entry:
                                        trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                    if &#34;origin&#34; in entry:
                                        trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                    if &#34;message&#34; in entry:
                                        trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                    trace += &#34;\n&#34;
                                    trace += tb
                                    tb += &#34;\n------------------------\n&#34;
                        if len(trace):
                            txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                            txt += trace
                            txt += &#34;\n#############################################################\n\n&#34;
        return txt

    def create_status(self, key):
        if self.key_name(key) != self.STATUS_FILE:
            if not self.is_dir(key):
                key = self.parent_key(key)
            status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
            data = self.create_status_text(key).encode(&#34;utf-8&#34;)
            self.substore.store(
                status_key,
                data,
                dict(
                    type_identifier=&#34;text&#34;,
                    status=Status.SIDE_EFFECT.value,
                    title=f&#34;Status of &#39;{key}&#39;&#34;,
                    description=&#34;This file is generated automatically by the recipe store&#34;,
                ),
            )

    def on_metadata_changed(self, key):
        super().on_metadata_changed(key)
        if self.STATUS_FILE is not None:
            if self.key_name(key) == self.RECIPES_FILE:
                self.update_all_status_files()
            elif self.key_name(key) != self.STATUS_FILE:
                self.create_status(key)

    def on_data_changed(self, key):
        super().on_data_changed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)

    def on_removed(self, key):
        super().on_removed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="store.html#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.recipes.RecipeSpecStore" href="#liquer.recipes.RecipeSpecStore">RecipeSpecStore</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.recipes.NewRecipeSpecStore.LOCAL_RECIPES"><code class="name">var <span class="ident">LOCAL_RECIPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.RECIPES_FILE"><code class="name">var <span class="ident">RECIPES_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.STATUS_FILE"><code class="name">var <span class="ident">STATUS_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.NewRecipeSpecStore.create_status"><code class="name flex">
<span>def <span class="ident">create_status</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_status(self, key):
    if self.key_name(key) != self.STATUS_FILE:
        if not self.is_dir(key):
            key = self.parent_key(key)
        status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
        data = self.create_status_text(key).encode(&#34;utf-8&#34;)
        self.substore.store(
            status_key,
            data,
            dict(
                type_identifier=&#34;text&#34;,
                status=Status.SIDE_EFFECT.value,
                title=f&#34;Status of &#39;{key}&#39;&#34;,
                description=&#34;This file is generated automatically by the recipe store&#34;,
            ),
        )</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.create_status_text"><code class="name flex">
<span>def <span class="ident">create_status_text</span></span>(<span>self, dir_key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_status_text(self, dir_key):
    txt = &#34;&#34;
    if self.substore.is_dir(dir_key):
        for d in self.listdir(dir_key):
            key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
            if d == self.STATUS_FILE:
                continue
            if not self.is_dir(key):
                metadata = self.get_metadata(key)
                if metadata is None:
                    txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                else:
                    try:
                        t = metadata.get(&#34;created&#34;)
                        if t in (&#34;&#34;, None):
                            t = metadata[&#34;updated&#34;]
                        time = util.format_datetime(util.to_datetime(t))
                    except:
                        time = &#34;&#34;
                    status = metadata.get(&#34;status&#34;, Status.NONE.value)
                    message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                    if status == Status.READY.value:
                        try:
                            message = metadata[&#34;data_characteristics&#34;][
                                &#34;description&#34;
                            ]
                        except:
                            pass
                    if &#34;\n&#34; in message:
                        txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                        txt += &#34;\n=============================================================\n&#34;
                        txt += message
                        txt += &#34;\n=============================================================\n\n&#34;
                    else:
                        txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                            time,
                            status,
                            d,
                            message,
                        )
                    trace = &#34;&#34;
                    for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                        &#34;child_log&#34;, []
                    ):
                        tb = entry.get(&#34;traceback&#34;)
                        if tb is not None:
                            if len(tb):
                                if &#34;timestamp&#34; in entry:
                                    trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                if &#34;origin&#34; in entry:
                                    trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                if &#34;message&#34; in entry:
                                    trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                trace += &#34;\n&#34;
                                trace += tb
                                tb += &#34;\n------------------------\n&#34;
                    if len(trace):
                        txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                        txt += trace
                        txt += &#34;\n#############################################################\n\n&#34;
    return txt</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore(self, key):
    if key is None:
        return True
    return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make(self, key):
    if self.ignore(key):
        raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

    recipe = self.recipes().get(key)
    if recipe is None:
        raise KeyNotFoundStoreException(
            f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
        )
    try:
        #recipe.make(key, store=self.substore)
        recipe.make(self.to_root_key(key))
        is_error = False
    except:
        is_error = True
        trace = traceback.format_exc()
        traceback.print_exc()

    metadata = self.substore.get_metadata(key)
    recipe_metadata = self.recipe_metadata(key)

    for k in [
        &#34;status&#34;,
        &#34;fileinfo&#34;,
        &#34;message&#34;,
        &#34;is_error&#34;,
        &#34;log&#34;,
        &#34;child_log&#34;,
        &#34;dependencies&#34;,
    ]:
        if k in recipe_metadata:
            del recipe_metadata[k]

    metadata.update(recipe_metadata)
    m = Metadata(metadata)
    if is_error:
        m.exception(f&#34;Error evaluating recipe&#34;, traceback=trace)
    else:
        if m.status == Status.NONE.value:
            m.status = Status.READY.value
    m.add_recipe_dependency(recipe)
    metadata = m.as_dict()
    self.substore.store_metadata(key, metadata)
    self.on_data_changed(key)
    self.on_metadata_changed(key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.recipe_metadata"><code class="name flex">
<span>def <span class="ident">recipe_metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe_metadata(self, key):
    if self.ignore(key):
        raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)

    recipe = self.recipes().get(key)
    if recipe is None:
        raise KeyNotFoundStoreException(
            f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
        )
    metadata = recipe.metadata(key)
    metadata[&#34;status&#34;] = Status.RECIPE.value
    metadata[&#34;has_recipe&#34;] = True

    return metadata</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.recipes"><code class="name flex">
<span>def <span class="ident">recipes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipes(self):
    return self._recipes</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self.update_recipes()
    self.update_all_status_files()
    self.substore.sync()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.update_all_status_files"><code class="name flex">
<span>def <span class="ident">update_all_status_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_all_status_files(self):
    if self.STATUS_FILE is not None:
        for dir_key in set(parent_key(key) for key in self.recipes().keys()):
            self.create_status(dir_key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.NewRecipeSpecStore.update_recipes"><code class="name flex">
<span>def <span class="ident">update_recipes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_recipes(self):
    import yaml

    recipes = {}

    for key in self.substore.keys():
        spec = None
        if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
            key
        ):
            spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
            recipes_key = key
            metadata = StoreSyncMetadata(self.substore, key)
            metadata.clear_log()
            metadata.info(f&#34;Update recipes for key &#39;{key}&#39;&#34;)
            if spec is not None:
                parent = parent_key(key)
                for directory, items in spec.items():
                    for i, r in enumerate(items):
                        cwd = (
                            parent
                            if directory == self.LOCAL_RECIPES
                            else join_key(parent, directory)
                        )
                        d = resolve_recipe_definition(r, self.to_root_key(cwd), metadata)
                        if d is None:
                            metadata.warning(
                                f&#34;Failed parsing the definition of recipe {i+1} in {directory}&#34;
                            )
                        d[&#34;recipe_name&#34;] = (
                            self.to_root_key(recipes_key)
                            + f&#34;/-Ryaml/{directory}/{i}#&#34;
                            + d.get(&#34;filename&#34;, &#34;&#34;)
                        )
                        d[&#34;recipes_key&#34;] = self.to_root_key(recipes_key)

                        
                        d[&#34;recipes_directory&#34;] = (
                            &#34;&#34; if directory == self.LOCAL_RECIPES else directory
                        )

                        try:
                            recipe = recipe_registry().from_dict(d)
                        except:
                            metadata.warning(
                                f&#34;Failed parsing recipe {i+1} in {directory}&#34;,
                                traceback=traceback.format_exc(),
                            )
                        for name in recipe.provides():
                            key = join_key(cwd, name)
                            recipes[key] = recipe
    self._recipes = recipes
    return recipes</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="store.html#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="store.html#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="store.html#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="store.html#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="store.html#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="store.html#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="store.html#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="store.html#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="store.html#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="store.html#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="store.html#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="store.html#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="store.html#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="store.html#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="store.html#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="store.html#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="store.html#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="store.html#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="store.html#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="store.html#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="store.html#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="store.html#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="store.html#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="store.html#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="store.html#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="store.html#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="store.html#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore"><code class="flex name class">
<span>class <span class="ident">OldRecipeSpecStore</span></span>
<span>(</span><span>store, context=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OldRecipeSpecStore(RecipeStore):
    RECIPES_FILE = &#34;recipes.yaml&#34;
    LOCAL_RECIPES = &#34;RECIPES&#34;
    STATUS_FILE = &#34;recipes_status.txt&#34;

    def __init__(self, store, context=None):
        RecipeStore.__init__(self, store, recipes=None, context=context)
        self.recipes_info = {}
        self.update_recipes()
        self.update_all_status_files()

    def sync(self):
        self.update_recipes()
        self.update_all_status_files()
        self.substore.sync()

    def update_all_status_files(self):
        if self.STATUS_FILE is not None:
            for dir_key in set(self.parent_key(key) for key in self.recipes().keys()):
                self.create_status(dir_key)

    def ignore(self, key):
        if key is None:
            return True
        return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))

    def recipe_metadata(self, key):
        metadata = deepcopy(self.recipes_info.get(key, {}))
        metadata[&#34;status&#34;] = Status.RECIPE.value
        if metadata.get(&#34;query&#34;) is not None:
            metadata[&#34;has_recipe&#34;] = True
            if self.recipes_info[key].get(&#34;recipes_directory&#34;) == self.LOCAL_RECIPES:
                metadata[&#34;recipes_directory&#34;] = &#34;&#34;
            else:
                metadata[&#34;recipes_directory&#34;] = self.recipes_info[key].get(
                    &#34;recipes_directory&#34;
                )
        return metadata

    def make(self, key):
        super().make(key)
        metadata = self.substore.get_metadata(key)
        status = metadata.get(&#34;status&#34;, Status.RECIPE.value)
        fileinfo = metadata[&#34;fileinfo&#34;]
        metadata.update(self.recipe_metadata(key))
        metadata[&#34;status&#34;] = status
        metadata[&#34;fileinfo&#34;] = fileinfo
        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def update_recipes(self):
        import yaml

        recipes = {}
        for key in self.substore.keys():
            spec = None
            if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
                key
            ):
                spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
            recipes_key = key
            if spec is not None:
                parent = self.parent_key(key)
                for directory, items in spec.items():
                    for r in items:
                        if type(r) == str:
                            try:
                                query = parse(r)
                                filename = query.filename()
                                parent = self.parent_key(key)
                                if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                    parent += &#34;/&#34;
                                rkey = (
                                    f&#34;{parent}{filename}&#34;
                                    if directory == self.LOCAL_RECIPES
                                    else f&#34;{parent}{directory}/{filename}&#34;
                                )
                                recipes[rkey] = r
                                self.recipes_info[rkey] = dict(
                                    query=r,
                                    title=filename,
                                    description=&#34;&#34;,
                                    recipes_key=recipes_key,
                                    recipes_directory=directory,
                                )
                            except:
                                traceback.print_exc()
                        elif isinstance(r, dict):
                            try:
                                query = parse(r[&#34;query&#34;])
                                filename = r.get(&#34;filename&#34;, query.filename())
                                title = r.get(&#34;title&#34;, filename)
                                description = r.get(&#34;description&#34;, r[&#34;query&#34;])
                                parent = self.parent_key(key)
                                if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                    parent += &#34;/&#34;
                                rkey = (
                                    f&#34;{parent}{filename}&#34;
                                    if directory == self.LOCAL_RECIPES
                                    else f&#34;{parent}{directory}/{filename}&#34;
                                )
                                recipes[rkey] = r[&#34;query&#34;]
                                self.recipes_info[rkey] = dict(
                                    query=r[&#34;query&#34;],
                                    title=title,
                                    description=description,
                                    recipes_key=recipes_key,
                                    recipes_directory=directory,
                                )
                            except:
                                traceback.print_exc()
                        else:
                            print(f&#34;Unsupported recipe type: {type(r)}&#34;)
        self._recipes = recipes
        return recipes

    def create_status_text(self, dir_key):
        txt = &#34;&#34;
        if self.substore.is_dir(dir_key):
            for d in self.listdir(dir_key):
                key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
                if d == self.STATUS_FILE:
                    continue
                if not self.is_dir(key):
                    metadata = self.get_metadata(key)
                    if metadata is None:
                        txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                    else:
                        try:
                            t = metadata.get(&#34;created&#34;)
                            if t in (&#34;&#34;, None):
                                t = metadata[&#34;updated&#34;]
                            time = util.format_datetime(util.to_datetime(t))
                        except:
                            time = &#34;&#34;
                        status = metadata.get(&#34;status&#34;, Status.NONE.value)
                        message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                        if status == Status.READY.value:
                            try:
                                message = metadata[&#34;data_characteristics&#34;][
                                    &#34;description&#34;
                                ]
                            except:
                                pass
                        if &#34;\n&#34; in message:
                            txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                            txt += &#34;\n=============================================================\n&#34;
                            txt += message
                            txt += &#34;\n=============================================================\n\n&#34;
                        else:
                            txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                                time,
                                status,
                                d,
                                message,
                            )
                        trace = &#34;&#34;
                        for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                            &#34;child_log&#34;, []
                        ):
                            tb = entry.get(&#34;traceback&#34;)
                            if tb is not None:
                                if len(tb):
                                    if &#34;timestamp&#34; in entry:
                                        trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                    if &#34;origin&#34; in entry:
                                        trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                    if &#34;message&#34; in entry:
                                        trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                    trace += &#34;\n&#34;
                                    trace += tb
                                    tb += &#34;\n------------------------\n&#34;
                        if len(trace):
                            txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                            txt += trace
                            txt += &#34;\n#############################################################\n\n&#34;
        return txt

    def create_status(self, key):
        if self.key_name(key) != self.STATUS_FILE:
            if not self.is_dir(key):
                key = self.parent_key(key)
            status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
            data = self.create_status_text(key).encode(&#34;utf-8&#34;)
            self.substore.store(
                status_key,
                data,
                dict(
                    type_identifier=&#34;text&#34;,
                    status=Status.SIDE_EFFECT.value,
                    title=f&#34;Status of &#39;{key}&#39;&#34;,
                    description=&#34;This file is generated automatically by the recipe store&#34;,
                ),
            )

    def on_metadata_changed(self, key):
        super().on_metadata_changed(key)
        if self.STATUS_FILE is not None:
            if self.key_name(key) == self.RECIPES_FILE:
                self.update_all_status_files()
            elif self.key_name(key) != self.STATUS_FILE:
                self.create_status(key)

    def on_data_changed(self, key):
        super().on_data_changed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)

    def on_removed(self, key):
        super().on_removed(key)
        if self.key_name(key) == self.RECIPES_FILE:
            self.update_recipes()
            self.update_all_status_files()
        else:
            self.create_status(key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.recipes.RecipeStore" href="#liquer.recipes.RecipeStore">RecipeStore</a></li>
<li><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="store.html#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="liquer.recipes.OldRecipeSpecStore.LOCAL_RECIPES"><code class="name">var <span class="ident">LOCAL_RECIPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.RECIPES_FILE"><code class="name">var <span class="ident">RECIPES_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.STATUS_FILE"><code class="name">var <span class="ident">STATUS_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.OldRecipeSpecStore.create_status"><code class="name flex">
<span>def <span class="ident">create_status</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_status(self, key):
    if self.key_name(key) != self.STATUS_FILE:
        if not self.is_dir(key):
            key = self.parent_key(key)
        status_key = f&#34;{key}/{self.STATUS_FILE}&#34; if len(key) else self.STATUS_FILE
        data = self.create_status_text(key).encode(&#34;utf-8&#34;)
        self.substore.store(
            status_key,
            data,
            dict(
                type_identifier=&#34;text&#34;,
                status=Status.SIDE_EFFECT.value,
                title=f&#34;Status of &#39;{key}&#39;&#34;,
                description=&#34;This file is generated automatically by the recipe store&#34;,
            ),
        )</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.create_status_text"><code class="name flex">
<span>def <span class="ident">create_status_text</span></span>(<span>self, dir_key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_status_text(self, dir_key):
    txt = &#34;&#34;
    if self.substore.is_dir(dir_key):
        for d in self.listdir(dir_key):
            key = f&#34;{dir_key}/{d}&#34; if len(dir_key) else d
            if d == self.STATUS_FILE:
                continue
            if not self.is_dir(key):
                metadata = self.get_metadata(key)
                if metadata is None:
                    txt += &#34;%-14s %-30s %s\n&#34; % (&#34;MISSING&#34;, d, &#34;Missing metadata&#34;)
                else:
                    try:
                        t = metadata.get(&#34;created&#34;)
                        if t in (&#34;&#34;, None):
                            t = metadata[&#34;updated&#34;]
                        time = util.format_datetime(util.to_datetime(t))
                    except:
                        time = &#34;&#34;
                    status = metadata.get(&#34;status&#34;, Status.NONE.value)
                    message = metadata.get(&#34;message&#34;, &#34;&#34;).strip()
                    if status == Status.READY.value:
                        try:
                            message = metadata[&#34;data_characteristics&#34;][
                                &#34;description&#34;
                            ]
                        except:
                            pass
                    if &#34;\n&#34; in message:
                        txt += &#34;%-20s %-14s %-32s|&#34; % (time, status, d)
                        txt += &#34;\n=============================================================\n&#34;
                        txt += message
                        txt += &#34;\n=============================================================\n\n&#34;
                    else:
                        txt += &#34;%-20s %-14s %-32s| %s\n&#34; % (
                            time,
                            status,
                            d,
                            message,
                        )
                    trace = &#34;&#34;
                    for entry in metadata.get(&#34;log&#34;, []) + metadata.get(
                        &#34;child_log&#34;, []
                    ):
                        tb = entry.get(&#34;traceback&#34;)
                        if tb is not None:
                            if len(tb):
                                if &#34;timestamp&#34; in entry:
                                    trace += f&#34;Time:    {entry[&#39;timestamp&#39;]}&#34;
                                if &#34;origin&#34; in entry:
                                    trace += f&#34;Origin:  {entry[&#39;origin&#39;]}&#34;
                                if &#34;message&#34; in entry:
                                    trace += f&#34;Message: {entry[&#39;message&#39;]}&#34;
                                trace += &#34;\n&#34;
                                trace += tb
                                tb += &#34;\n------------------------\n&#34;
                    if len(trace):
                        txt += &#34;\n### TRACEBACK ###############################################\n&#34;
                        txt += trace
                        txt += &#34;\n#############################################################\n\n&#34;
    return txt</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore(self, key):
    if key is None:
        return True
    return any(x.startswith(&#34;.&#34;) for x in key.split(&#34;/&#34;))</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make(self, key):
    super().make(key)
    metadata = self.substore.get_metadata(key)
    status = metadata.get(&#34;status&#34;, Status.RECIPE.value)
    fileinfo = metadata[&#34;fileinfo&#34;]
    metadata.update(self.recipe_metadata(key))
    metadata[&#34;status&#34;] = status
    metadata[&#34;fileinfo&#34;] = fileinfo
    self.substore.store_metadata(key, metadata)
    self.on_metadata_changed(key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.recipe_metadata"><code class="name flex">
<span>def <span class="ident">recipe_metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe_metadata(self, key):
    metadata = deepcopy(self.recipes_info.get(key, {}))
    metadata[&#34;status&#34;] = Status.RECIPE.value
    if metadata.get(&#34;query&#34;) is not None:
        metadata[&#34;has_recipe&#34;] = True
        if self.recipes_info[key].get(&#34;recipes_directory&#34;) == self.LOCAL_RECIPES:
            metadata[&#34;recipes_directory&#34;] = &#34;&#34;
        else:
            metadata[&#34;recipes_directory&#34;] = self.recipes_info[key].get(
                &#34;recipes_directory&#34;
            )
    return metadata</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self.update_recipes()
    self.update_all_status_files()
    self.substore.sync()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.update_all_status_files"><code class="name flex">
<span>def <span class="ident">update_all_status_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_all_status_files(self):
    if self.STATUS_FILE is not None:
        for dir_key in set(self.parent_key(key) for key in self.recipes().keys()):
            self.create_status(dir_key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.OldRecipeSpecStore.update_recipes"><code class="name flex">
<span>def <span class="ident">update_recipes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_recipes(self):
    import yaml

    recipes = {}
    for key in self.substore.keys():
        spec = None
        if self.key_name(key) == self.RECIPES_FILE and not self.substore.is_dir(
            key
        ):
            spec = yaml.load(self.substore.get_bytes(key), Loader=Loader)
        recipes_key = key
        if spec is not None:
            parent = self.parent_key(key)
            for directory, items in spec.items():
                for r in items:
                    if type(r) == str:
                        try:
                            query = parse(r)
                            filename = query.filename()
                            parent = self.parent_key(key)
                            if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                parent += &#34;/&#34;
                            rkey = (
                                f&#34;{parent}{filename}&#34;
                                if directory == self.LOCAL_RECIPES
                                else f&#34;{parent}{directory}/{filename}&#34;
                            )
                            recipes[rkey] = r
                            self.recipes_info[rkey] = dict(
                                query=r,
                                title=filename,
                                description=&#34;&#34;,
                                recipes_key=recipes_key,
                                recipes_directory=directory,
                            )
                        except:
                            traceback.print_exc()
                    elif isinstance(r, dict):
                        try:
                            query = parse(r[&#34;query&#34;])
                            filename = r.get(&#34;filename&#34;, query.filename())
                            title = r.get(&#34;title&#34;, filename)
                            description = r.get(&#34;description&#34;, r[&#34;query&#34;])
                            parent = self.parent_key(key)
                            if len(parent) &gt; 0 and not parent.endswith(&#34;/&#34;):
                                parent += &#34;/&#34;
                            rkey = (
                                f&#34;{parent}{filename}&#34;
                                if directory == self.LOCAL_RECIPES
                                else f&#34;{parent}{directory}/{filename}&#34;
                            )
                            recipes[rkey] = r[&#34;query&#34;]
                            self.recipes_info[rkey] = dict(
                                query=r[&#34;query&#34;],
                                title=title,
                                description=description,
                                recipes_key=recipes_key,
                                recipes_directory=directory,
                            )
                        except:
                            traceback.print_exc()
                    else:
                        print(f&#34;Unsupported recipe type: {type(r)}&#34;)
    self._recipes = recipes
    return recipes</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.recipes.RecipeStore" href="#liquer.recipes.RecipeStore">RecipeStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.recipes.RecipeStore.contains" href="store.html#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.get_bytes" href="store.html#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.get_metadata" href="store.html#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.is_dir" href="store.html#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.is_supported" href="store.html#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.join_key" href="store.html#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.key_name" href="store.html#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.keys" href="store.html#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.listdir" href="store.html#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.listdir_keys" href="store.html#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.makedir" href="store.html#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.mount" href="store.html#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.on_data_changed" href="store.html#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.on_metadata_changed" href="store.html#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.on_removed" href="store.html#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.openbin" href="store.html#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.parent_key" href="store.html#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.read_only" href="store.html#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.remove" href="store.html#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.removedir" href="store.html#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.root_store" href="store.html#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.store" href="store.html#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.store_metadata" href="store.html#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.to_root_key" href="store.html#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.with_fallback" href="store.html#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.with_indexer" href="store.html#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.with_overlay" href="store.html#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.recipes.QueryRecipe"><code class="flex name class">
<span>class <span class="ident">QueryRecipe</span></span>
<span>(</span><span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryRecipe(Recipe):
    @classmethod
    def recipe_type(self):
        return &#34;query&#34;

    @classmethod
    def from_dict(cls, d):
        return cls(d)

    def metadata(self, key):
        metadata = Metadata(super().metadata(key))
        metadata.query = self.data[&#34;query&#34;]
        return metadata.as_dict()

    def make(self, key, store=None, context=None):
        context = get_context(context)
        if store is None:
            store = context.store()
        context.evaluate(
            self.data[&#34;query&#34;],
            store_key=key,
            store_to=store,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.recipes.Recipe" href="#liquer.recipes.Recipe">Recipe</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="liquer.recipes.QueryRecipe.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, d):
    return cls(d)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.QueryRecipe.recipe_type"><code class="name flex">
<span>def <span class="ident">recipe_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def recipe_type(self):
    return &#34;query&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.QueryRecipe.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, key, store=None, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make(self, key, store=None, context=None):
    context = get_context(context)
    if store is None:
        store = context.store()
    context.evaluate(
        self.data[&#34;query&#34;],
        store_key=key,
        store_to=store,
    )</code></pre>
</details>
</dd>
<dt id="liquer.recipes.QueryRecipe.metadata"><code class="name flex">
<span>def <span class="ident">metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata(self, key):
    metadata = Metadata(super().metadata(key))
    metadata.query = self.data[&#34;query&#34;]
    return metadata.as_dict()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.recipes.Recipe"><code class="flex name class">
<span>class <span class="ident">Recipe</span></span>
<span>(</span><span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Recipe:
    def __init__(self, d):
        if type(d) != dict:
            raise Exception(&#34;Dictionary expected as recipe definition&#34;)
        if &#34;type&#34; in d:
            if d[&#34;type&#34;] != self.recipe_type():
                t = d[&#34;type&#34;]
                raise Exception(
                    f&#34;Recipe {self.recipe_type()} received definition with type=&#39;{t}&#39;&#34;
                )
        self.data = d

    @classmethod
    def recipe_type(self):
        return &#34;empty&#34;

    @classmethod
    def from_dict(cls, d):
        return cls(d)

    def version(self):
        h = hashlib.md5()
        txt = json.dumps(self.data, sort_keys=True, indent=2)
        h.update(txt.encode(&#34;utf-8&#34;))
        return &#34;md5:&#34; + h.hexdigest()

    def recipe_name(self):
        return self.data.get(&#34;recipe_name&#34;, &#34;&#34;)

    def provides(self):
        return self.data.get(&#34;provides&#34;, [])

    def can_create(self, name):
        return name in self.provides()

    def metadata(self, key):
        metadata = Metadata(dict())
        if &#34;title&#34; in self.data:
            metadata.metadata[&#34;title&#34;] = self.data[&#34;title&#34;]
        if &#34;description&#34; in self.data:
            metadata.metadata[&#34;description&#34;] = self.data[&#34;description&#34;]
        metadata.key = key
        metadata.metadata[&#34;recipes_key&#34;] = self.data.get(&#34;recipes_key&#34;)
        metadata.metadata[&#34;recipes_directory&#34;] = self.data.get(&#34;recipes_directory&#34;)
        metadata.metadata[&#34;recipe_name&#34;] = self.data.get(&#34;recipe_name&#34;)
        return metadata.as_dict()

    def make(self, key, context=None):
        raise RecipeException(&#34;Recipe undefined (make)&#34;, key=key)

    def is_volatile(self):
        return self.data.get(&#34;volatile&#34;, False)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.ext.lq_datafusion.ParquetSQLRecipe" href="ext/lq_datafusion.html#liquer.ext.lq_datafusion.ParquetSQLRecipe">ParquetSQLRecipe</a></li>
<li><a title="liquer.ext.lq_pandas.PandasConcatRecipe" href="ext/lq_pandas.html#liquer.ext.lq_pandas.PandasConcatRecipe">PandasConcatRecipe</a></li>
<li><a title="liquer.recipes.QueryRecipe" href="#liquer.recipes.QueryRecipe">QueryRecipe</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="liquer.recipes.Recipe.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, d):
    return cls(d)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.recipe_type"><code class="name flex">
<span>def <span class="ident">recipe_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def recipe_type(self):
    return &#34;empty&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.Recipe.can_create"><code class="name flex">
<span>def <span class="ident">can_create</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_create(self, name):
    return name in self.provides()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.is_volatile"><code class="name flex">
<span>def <span class="ident">is_volatile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_volatile(self):
    return self.data.get(&#34;volatile&#34;, False)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, key, context=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make(self, key, context=None):
    raise RecipeException(&#34;Recipe undefined (make)&#34;, key=key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.metadata"><code class="name flex">
<span>def <span class="ident">metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata(self, key):
    metadata = Metadata(dict())
    if &#34;title&#34; in self.data:
        metadata.metadata[&#34;title&#34;] = self.data[&#34;title&#34;]
    if &#34;description&#34; in self.data:
        metadata.metadata[&#34;description&#34;] = self.data[&#34;description&#34;]
    metadata.key = key
    metadata.metadata[&#34;recipes_key&#34;] = self.data.get(&#34;recipes_key&#34;)
    metadata.metadata[&#34;recipes_directory&#34;] = self.data.get(&#34;recipes_directory&#34;)
    metadata.metadata[&#34;recipe_name&#34;] = self.data.get(&#34;recipe_name&#34;)
    return metadata.as_dict()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.provides"><code class="name flex">
<span>def <span class="ident">provides</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def provides(self):
    return self.data.get(&#34;provides&#34;, [])</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.recipe_name"><code class="name flex">
<span>def <span class="ident">recipe_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe_name(self):
    return self.data.get(&#34;recipe_name&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.Recipe.version"><code class="name flex">
<span>def <span class="ident">version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def version(self):
    h = hashlib.md5()
    txt = json.dumps(self.data, sort_keys=True, indent=2)
    h.update(txt.encode(&#34;utf-8&#34;))
    return &#34;md5:&#34; + h.hexdigest()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.recipes.RecipeException"><code class="flex name class">
<span>class <span class="ident">RecipeException</span></span>
<span>(</span><span>message, key=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecipeException(Exception):
    def __init__(self, message, key=None):
        self.original_message = message
        if key is not None:
            message += f&#34;:\n  key: &#39;{key}&#39;&#34;

        super().__init__(message)
        self.key = key</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="liquer.recipes.RecipeRegistry"><code class="flex name class">
<span>class <span class="ident">RecipeRegistry</span></span>
</code></dt>
<dd>
<div class="desc"><p>Registry of recipes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecipeRegistry(object):
    &#34;&#34;&#34;Registry of recipes&#34;&#34;&#34;

    def __init__(self):
        self.recipe_dictionary = {}

    def register(self, recipe):
        &#34;&#34;&#34;Register a Recipe class in the registry&#34;&#34;&#34;
        if recipe.recipe_type() in self.recipe_dictionary:
            print(f&#34;WARNING: Recipe type &#39;{recipe.recipe_type()}&#39; already registered&#34;)
        self.recipe_dictionary[recipe.recipe_type()] = recipe

    def from_dict(self, d):
        &#34;&#34;&#34;Construct a Recipe instance from a recipe description
        Recipe description is typically a dictionary. The &#39;type&#39; item of the dictionary is matched with recipe_type()
        class-method result for known recipes to find a suitable recipe constructor.
        &#34;&#34;&#34;
        if type(d) != dict:
            raise Exception(
                &#34;Dictionary expected as recipe definition for registered recipes&#34;
            )
        if &#34;type&#34; not in d:
            raise Exception(&#34;Recipe definition is lacking a type&#34;)
        if d[&#34;type&#34;] not in self.recipe_dictionary:
            t = d[&#34;type&#34;]
            raise Exception(f&#34;Recipe type &#39;{t}&#39; not registered&#34;)
        return self.recipe_dictionary[d[&#34;type&#34;]].from_dict(d)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.RecipeRegistry.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>self, d)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Recipe instance from a recipe description
Recipe description is typically a dictionary. The 'type' item of the dictionary is matched with recipe_type()
class-method result for known recipes to find a suitable recipe constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_dict(self, d):
    &#34;&#34;&#34;Construct a Recipe instance from a recipe description
    Recipe description is typically a dictionary. The &#39;type&#39; item of the dictionary is matched with recipe_type()
    class-method result for known recipes to find a suitable recipe constructor.
    &#34;&#34;&#34;
    if type(d) != dict:
        raise Exception(
            &#34;Dictionary expected as recipe definition for registered recipes&#34;
        )
    if &#34;type&#34; not in d:
        raise Exception(&#34;Recipe definition is lacking a type&#34;)
    if d[&#34;type&#34;] not in self.recipe_dictionary:
        t = d[&#34;type&#34;]
        raise Exception(f&#34;Recipe type &#39;{t}&#39; not registered&#34;)
    return self.recipe_dictionary[d[&#34;type&#34;]].from_dict(d)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeRegistry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, recipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a Recipe class in the registry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, recipe):
    &#34;&#34;&#34;Register a Recipe class in the registry&#34;&#34;&#34;
    if recipe.recipe_type() in self.recipe_dictionary:
        print(f&#34;WARNING: Recipe type &#39;{recipe.recipe_type()}&#39; already registered&#34;)
    self.recipe_dictionary[recipe.recipe_type()] = recipe</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="liquer.recipes.RecipeSpecStore"><code class="flex name class">
<span>class <span class="ident">RecipeSpecStore</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecipeSpecStore(NewRecipeSpecStore):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.recipes.NewRecipeSpecStore" href="#liquer.recipes.NewRecipeSpecStore">NewRecipeSpecStore</a></li>
<li><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="store.html#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.recipes.NewRecipeSpecStore" href="#liquer.recipes.NewRecipeSpecStore">NewRecipeSpecStore</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.recipes.NewRecipeSpecStore.contains" href="store.html#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.get_bytes" href="store.html#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.get_metadata" href="store.html#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.is_dir" href="store.html#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.is_supported" href="store.html#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.join_key" href="store.html#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.key_name" href="store.html#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.keys" href="store.html#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.listdir" href="store.html#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.listdir_keys" href="store.html#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.makedir" href="store.html#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.mount" href="store.html#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.on_data_changed" href="store.html#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.on_metadata_changed" href="store.html#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.on_removed" href="store.html#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.openbin" href="store.html#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.parent_key" href="store.html#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.read_only" href="store.html#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.remove" href="store.html#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.removedir" href="store.html#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.root_store" href="store.html#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.store" href="store.html#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.store_metadata" href="store.html#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.to_root_key" href="store.html#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.with_fallback" href="store.html#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.with_indexer" href="store.html#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.with_overlay" href="store.html#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="liquer.recipes.RecipeStore"><code class="flex name class">
<span>class <span class="ident">RecipeStore</span></span>
<span>(</span><span>store, recipes=None, context=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mixing adding extra functionality to stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecipeStore(Store):
    def __init__(self, store, recipes=None, context=None):
        self.substore = store
        self.substore.parent_store = self
        self._recipes = {} if recipes is None else recipes
        self.context = context

    def sync(self):
        self.substore.sync()

    def get_context(self):
        if self.context is None:
            return get_context()
        else:
            return self.context.new_empty()

    def with_context(self, context):
        return RecipeStore(self.substore, recipes=self.recipes, context=context)

    def mount_recipe(self, key, recipe):
        self._recipes[key] = recipe
        return self

    def ignore(self, key):
        return False

    def make(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)
        query = self.recipes().get(key)
        if query is None:
            raise KeyNotFoundStoreException(
                f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
            )
        target_resource_directory = self.parent_key(key)
        target_file = self.key_name(key)
        self.get_context().evaluate(
            query,
            store_key=key,
            store_to=self,
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def recipes(self):
        return self._recipes

    def recipe_metadata(self, key):
        return {}

    def is_supported(self, key):
        if self.ignore(key):
            return False
        return self.substore.is_supported(key)

    def get_bytes(self, key):
        if self.ignore(key):
            return None
        if self.substore.contains(key):
            return self.substore.get_bytes(key)
        self.make(key)
        return self.substore.get_bytes(key)

    def get_metadata(self, key):
        if self.ignore(key):
            raise KeyNotFoundStoreException(key=key, store=self)
        try:
            metadata = self.substore.get_metadata(key)
            if metadata is not None:
                return metadata
        except KeyNotFoundStoreException:
            pass

        if self.is_dir(key):
            return self.finalize_metadata(
                self.default_metadata(key=key, is_dir=True), key=key, is_dir=True
            )
        if key in self.recipes():
            metadata = self.recipe_metadata(key)
            try:
                sub_metadata = self.substore.get_metadata(key)
                if sub_metadata is not None:
                    metadata.update(sub_metadata)
            except:
                pass
            return self.finalize_metadata(metadata, key=key, is_dir=False)
        raise KeyNotFoundStoreException(key=key, store=self)

    def store(self, key, data, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store into it&#34;)
        self.substore.store(
            key, data, self.finalize_metadata(metadata, key=key, is_dir=True, data=data)
        )
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def store_metadata(self, key, metadata):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t store metadata into it&#34;)
        self.substore.store_metadata(key, metadata)
        self.on_metadata_changed(key)

    def remove(self, key):
        self.substore.remove(key)
        self.on_removed(key)

    def removedir(self, key):
        self.substore.removedir(key)
        self.on_removed(key)

    def contains(self, key):
        if self.ignore(key):
            return False
        if self.substore.contains(key):
            return True
        for k in self.recipes():
            if k == key or k.startswith(key + &#34;/&#34;):
                return True
        return False

    def is_dir(self, key):
        if self.ignore(key):
            return False
        if self.substore.is_dir(key):
            return True
        for k in self.recipes():
            if k == key:
                return False
            if k.startswith(key + &#34;/&#34;):
                return True
        return False

    def keys(self):
        return [
            key
            for key in sorted(set(self.substore.keys()).union(self.recipes().keys()))
            if not self.ignore(key)
        ]

    def listdir(self, key):
        if self.ignore(key):
            return []
        d = set(self.substore.listdir(key) or [])
        key_split = key.split(&#34;/&#34;)
        if len(key_split) == 1 and key_split[0] == &#34;&#34;:
            key_split = []
        key_depth = len(key_split)
        for k in self.recipes().keys():
            if k.startswith(key + &#34;/&#34;) or key in (None, &#34;&#34;):
                v = k.split(&#34;/&#34;)
                d.add(v[key_depth])
        return [key for key in sorted(d) if not self.ignore(key)]

    def makedir(self, key):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t makedir&#34;)
        self.substore.makedir(key)
        self.on_data_changed(key)
        self.on_metadata_changed(key)

    def openbin(self, key, mode=&#34;r&#34;, buffering=-1):
        if self.ignore(key):
            raise Exception(f&#34;Key {key} is ignored, can&#39;t openbin&#34;)
        return self.substore.openbin(key, mode=mode, buffering=buffering)

    def __str__(self):
        return f&#34;Recipe store on ({self.substore})&#34;

    def __repr__(self):
        return f&#34;RecipeStore({repr(self.substore)}, recipes={repr(self.recipes())})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></li>
<li><a title="liquer.store.StoreMixin" href="store.html#liquer.store.StoreMixin">StoreMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="liquer.recipes.OldRecipeSpecStore" href="#liquer.recipes.OldRecipeSpecStore">OldRecipeSpecStore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="liquer.recipes.RecipeStore.get_context"><code class="name flex">
<span>def <span class="ident">get_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context(self):
    if self.context is None:
        return get_context()
    else:
        return self.context.new_empty()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore(self, key):
    return False</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make(self, key):
    if self.ignore(key):
        raise Exception(f&#34;Key {key} is ignored, can&#39;t make it&#34;)
    query = self.recipes().get(key)
    if query is None:
        raise KeyNotFoundStoreException(
            f&#34;Key {key} not found, recipe unknown&#34;, key=key, store=self
        )
    target_resource_directory = self.parent_key(key)
    target_file = self.key_name(key)
    self.get_context().evaluate(
        query,
        store_key=key,
        store_to=self,
    )
    self.on_data_changed(key)
    self.on_metadata_changed(key)</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.mount_recipe"><code class="name flex">
<span>def <span class="ident">mount_recipe</span></span>(<span>self, key, recipe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mount_recipe(self, key, recipe):
    self._recipes[key] = recipe
    return self</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.recipe_metadata"><code class="name flex">
<span>def <span class="ident">recipe_metadata</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe_metadata(self, key):
    return {}</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.recipes"><code class="name flex">
<span>def <span class="ident">recipes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipes(self):
    return self._recipes</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    self.substore.sync()</code></pre>
</details>
</dd>
<dt id="liquer.recipes.RecipeStore.with_context"><code class="name flex">
<span>def <span class="ident">with_context</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_context(self, context):
    return RecipeStore(self.substore, recipes=self.recipes, context=context)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="liquer.store.Store" href="store.html#liquer.store.Store">Store</a></b></code>:
<ul class="hlist">
<li><code><a title="liquer.store.Store.contains" href="store.html#liquer.store.Store.contains">contains</a></code></li>
<li><code><a title="liquer.store.Store.get_bytes" href="store.html#liquer.store.Store.get_bytes">get_bytes</a></code></li>
<li><code><a title="liquer.store.Store.get_metadata" href="store.html#liquer.store.Store.get_metadata">get_metadata</a></code></li>
<li><code><a title="liquer.store.Store.is_dir" href="store.html#liquer.store.Store.is_dir">is_dir</a></code></li>
<li><code><a title="liquer.store.Store.is_supported" href="store.html#liquer.store.Store.is_supported">is_supported</a></code></li>
<li><code><a title="liquer.store.Store.join_key" href="store.html#liquer.store.Store.join_key">join_key</a></code></li>
<li><code><a title="liquer.store.Store.key_name" href="store.html#liquer.store.Store.key_name">key_name</a></code></li>
<li><code><a title="liquer.store.Store.keys" href="store.html#liquer.store.Store.keys">keys</a></code></li>
<li><code><a title="liquer.store.Store.listdir" href="store.html#liquer.store.Store.listdir">listdir</a></code></li>
<li><code><a title="liquer.store.Store.listdir_keys" href="store.html#liquer.store.Store.listdir_keys">listdir_keys</a></code></li>
<li><code><a title="liquer.store.Store.makedir" href="store.html#liquer.store.Store.makedir">makedir</a></code></li>
<li><code><a title="liquer.store.Store.mount" href="store.html#liquer.store.StoreMixin.mount">mount</a></code></li>
<li><code><a title="liquer.store.Store.on_data_changed" href="store.html#liquer.store.Store.on_data_changed">on_data_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_metadata_changed" href="store.html#liquer.store.Store.on_metadata_changed">on_metadata_changed</a></code></li>
<li><code><a title="liquer.store.Store.on_removed" href="store.html#liquer.store.Store.on_removed">on_removed</a></code></li>
<li><code><a title="liquer.store.Store.openbin" href="store.html#liquer.store.Store.openbin">openbin</a></code></li>
<li><code><a title="liquer.store.Store.parent_key" href="store.html#liquer.store.Store.parent_key">parent_key</a></code></li>
<li><code><a title="liquer.store.Store.read_only" href="store.html#liquer.store.StoreMixin.read_only">read_only</a></code></li>
<li><code><a title="liquer.store.Store.remove" href="store.html#liquer.store.Store.remove">remove</a></code></li>
<li><code><a title="liquer.store.Store.removedir" href="store.html#liquer.store.Store.removedir">removedir</a></code></li>
<li><code><a title="liquer.store.Store.root_store" href="store.html#liquer.store.Store.root_store">root_store</a></code></li>
<li><code><a title="liquer.store.Store.store" href="store.html#liquer.store.Store.store">store</a></code></li>
<li><code><a title="liquer.store.Store.store_metadata" href="store.html#liquer.store.Store.store_metadata">store_metadata</a></code></li>
<li><code><a title="liquer.store.Store.to_root_key" href="store.html#liquer.store.Store.to_root_key">to_root_key</a></code></li>
<li><code><a title="liquer.store.Store.with_fallback" href="store.html#liquer.store.StoreMixin.with_fallback">with_fallback</a></code></li>
<li><code><a title="liquer.store.Store.with_indexer" href="store.html#liquer.store.StoreMixin.with_indexer">with_indexer</a></code></li>
<li><code><a title="liquer.store.Store.with_overlay" href="store.html#liquer.store.StoreMixin.with_overlay">with_overlay</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="liquer" href="index.html">liquer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="liquer.recipes.recipe_registry" href="#liquer.recipes.recipe_registry">recipe_registry</a></code></li>
<li><code><a title="liquer.recipes.register_recipe" href="#liquer.recipes.register_recipe">register_recipe</a></code></li>
<li><code><a title="liquer.recipes.resolve_recipe_definition" href="#liquer.recipes.resolve_recipe_definition">resolve_recipe_definition</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="liquer.recipes.NewRecipeSpecStore" href="#liquer.recipes.NewRecipeSpecStore">NewRecipeSpecStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.recipes.NewRecipeSpecStore.LOCAL_RECIPES" href="#liquer.recipes.NewRecipeSpecStore.LOCAL_RECIPES">LOCAL_RECIPES</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.RECIPES_FILE" href="#liquer.recipes.NewRecipeSpecStore.RECIPES_FILE">RECIPES_FILE</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.STATUS_FILE" href="#liquer.recipes.NewRecipeSpecStore.STATUS_FILE">STATUS_FILE</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.create_status" href="#liquer.recipes.NewRecipeSpecStore.create_status">create_status</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.create_status_text" href="#liquer.recipes.NewRecipeSpecStore.create_status_text">create_status_text</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.ignore" href="#liquer.recipes.NewRecipeSpecStore.ignore">ignore</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.make" href="#liquer.recipes.NewRecipeSpecStore.make">make</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.recipe_metadata" href="#liquer.recipes.NewRecipeSpecStore.recipe_metadata">recipe_metadata</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.recipes" href="#liquer.recipes.NewRecipeSpecStore.recipes">recipes</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.sync" href="#liquer.recipes.NewRecipeSpecStore.sync">sync</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.update_all_status_files" href="#liquer.recipes.NewRecipeSpecStore.update_all_status_files">update_all_status_files</a></code></li>
<li><code><a title="liquer.recipes.NewRecipeSpecStore.update_recipes" href="#liquer.recipes.NewRecipeSpecStore.update_recipes">update_recipes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.recipes.OldRecipeSpecStore" href="#liquer.recipes.OldRecipeSpecStore">OldRecipeSpecStore</a></code></h4>
<ul class="">
<li><code><a title="liquer.recipes.OldRecipeSpecStore.LOCAL_RECIPES" href="#liquer.recipes.OldRecipeSpecStore.LOCAL_RECIPES">LOCAL_RECIPES</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.RECIPES_FILE" href="#liquer.recipes.OldRecipeSpecStore.RECIPES_FILE">RECIPES_FILE</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.STATUS_FILE" href="#liquer.recipes.OldRecipeSpecStore.STATUS_FILE">STATUS_FILE</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.create_status" href="#liquer.recipes.OldRecipeSpecStore.create_status">create_status</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.create_status_text" href="#liquer.recipes.OldRecipeSpecStore.create_status_text">create_status_text</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.ignore" href="#liquer.recipes.OldRecipeSpecStore.ignore">ignore</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.make" href="#liquer.recipes.OldRecipeSpecStore.make">make</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.recipe_metadata" href="#liquer.recipes.OldRecipeSpecStore.recipe_metadata">recipe_metadata</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.sync" href="#liquer.recipes.OldRecipeSpecStore.sync">sync</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.update_all_status_files" href="#liquer.recipes.OldRecipeSpecStore.update_all_status_files">update_all_status_files</a></code></li>
<li><code><a title="liquer.recipes.OldRecipeSpecStore.update_recipes" href="#liquer.recipes.OldRecipeSpecStore.update_recipes">update_recipes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.recipes.QueryRecipe" href="#liquer.recipes.QueryRecipe">QueryRecipe</a></code></h4>
<ul class="">
<li><code><a title="liquer.recipes.QueryRecipe.from_dict" href="#liquer.recipes.QueryRecipe.from_dict">from_dict</a></code></li>
<li><code><a title="liquer.recipes.QueryRecipe.make" href="#liquer.recipes.QueryRecipe.make">make</a></code></li>
<li><code><a title="liquer.recipes.QueryRecipe.metadata" href="#liquer.recipes.QueryRecipe.metadata">metadata</a></code></li>
<li><code><a title="liquer.recipes.QueryRecipe.recipe_type" href="#liquer.recipes.QueryRecipe.recipe_type">recipe_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.recipes.Recipe" href="#liquer.recipes.Recipe">Recipe</a></code></h4>
<ul class="two-column">
<li><code><a title="liquer.recipes.Recipe.can_create" href="#liquer.recipes.Recipe.can_create">can_create</a></code></li>
<li><code><a title="liquer.recipes.Recipe.from_dict" href="#liquer.recipes.Recipe.from_dict">from_dict</a></code></li>
<li><code><a title="liquer.recipes.Recipe.is_volatile" href="#liquer.recipes.Recipe.is_volatile">is_volatile</a></code></li>
<li><code><a title="liquer.recipes.Recipe.make" href="#liquer.recipes.Recipe.make">make</a></code></li>
<li><code><a title="liquer.recipes.Recipe.metadata" href="#liquer.recipes.Recipe.metadata">metadata</a></code></li>
<li><code><a title="liquer.recipes.Recipe.provides" href="#liquer.recipes.Recipe.provides">provides</a></code></li>
<li><code><a title="liquer.recipes.Recipe.recipe_name" href="#liquer.recipes.Recipe.recipe_name">recipe_name</a></code></li>
<li><code><a title="liquer.recipes.Recipe.recipe_type" href="#liquer.recipes.Recipe.recipe_type">recipe_type</a></code></li>
<li><code><a title="liquer.recipes.Recipe.version" href="#liquer.recipes.Recipe.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.recipes.RecipeException" href="#liquer.recipes.RecipeException">RecipeException</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.recipes.RecipeRegistry" href="#liquer.recipes.RecipeRegistry">RecipeRegistry</a></code></h4>
<ul class="">
<li><code><a title="liquer.recipes.RecipeRegistry.from_dict" href="#liquer.recipes.RecipeRegistry.from_dict">from_dict</a></code></li>
<li><code><a title="liquer.recipes.RecipeRegistry.register" href="#liquer.recipes.RecipeRegistry.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="liquer.recipes.RecipeSpecStore" href="#liquer.recipes.RecipeSpecStore">RecipeSpecStore</a></code></h4>
</li>
<li>
<h4><code><a title="liquer.recipes.RecipeStore" href="#liquer.recipes.RecipeStore">RecipeStore</a></code></h4>
<ul class="two-column">
<li><code><a title="liquer.recipes.RecipeStore.get_context" href="#liquer.recipes.RecipeStore.get_context">get_context</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.ignore" href="#liquer.recipes.RecipeStore.ignore">ignore</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.make" href="#liquer.recipes.RecipeStore.make">make</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.mount_recipe" href="#liquer.recipes.RecipeStore.mount_recipe">mount_recipe</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.recipe_metadata" href="#liquer.recipes.RecipeStore.recipe_metadata">recipe_metadata</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.recipes" href="#liquer.recipes.RecipeStore.recipes">recipes</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.sync" href="#liquer.recipes.RecipeStore.sync">sync</a></code></li>
<li><code><a title="liquer.recipes.RecipeStore.with_context" href="#liquer.recipes.RecipeStore.with_context">with_context</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>